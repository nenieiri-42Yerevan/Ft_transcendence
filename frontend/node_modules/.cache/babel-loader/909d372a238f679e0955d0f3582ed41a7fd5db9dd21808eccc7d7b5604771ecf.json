{"ast":null,"code":";\n(function (root, factory) {\n  // istanbul ignore next\n  if (typeof define === \"function\" && define.amd) {\n    // istanbul ignore next\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    // istanbul ignore next\n    root.regexpToAst = factory();\n  }\n})(typeof self !== \"undefined\" ?\n// istanbul ignore next\nself : this, function () {\n  // references\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  function RegExpParser() {}\n  RegExpParser.prototype.saveState = function () {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  };\n  RegExpParser.prototype.restoreState = function (newState) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  };\n  RegExpParser.prototype.pattern = function (input) {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    var value = this.disjunction();\n    this.consumeChar(\"/\");\n    var flags = {\n      type: \"Flags\",\n      loc: {\n        begin: this.idx,\n        end: input.length\n      },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value,\n      loc: this.loc(0)\n    };\n  };\n  RegExpParser.prototype.disjunction = function () {\n    var alts = [];\n    var begin = this.idx;\n    alts.push(this.alternative());\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n    return {\n      type: \"Disjunction\",\n      value: alts,\n      loc: this.loc(begin)\n    };\n  };\n  RegExpParser.prototype.alternative = function () {\n    var terms = [];\n    var begin = this.idx;\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n    return {\n      type: \"Alternative\",\n      value: terms,\n      loc: this.loc(begin)\n    };\n  };\n  RegExpParser.prototype.term = function () {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  };\n  RegExpParser.prototype.assertion = function () {\n    var begin = this.idx;\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n      case \"$\":\n        return {\n          type: \"EndAnchor\",\n          loc: this.loc(begin)\n        };\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        }\n        // istanbul ignore next\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n      case \"(\":\n        this.consumeChar(\"?\");\n        var type;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n        var disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type: type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    }\n    // istanbul ignore next\n    ASSERT_NEVER_REACH_HERE();\n  };\n  RegExpParser.prototype.quantifier = function (isBacktracking) {\n    var range;\n    var begin = this.idx;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n      case \"{\":\n        var atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast\n            };\n            break;\n          case \",\":\n            var atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n\n    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n    ASSERT_EXISTS(range);\n    if (this.peekChar(0) === \"?\") {\n      this.consumeChar(\"?\");\n      range.greedy = false;\n    } else {\n      range.greedy = true;\n    }\n    range.type = \"Quantifier\";\n    range.loc = this.loc(begin);\n    return range;\n  };\n  RegExpParser.prototype.atom = function () {\n    var atom;\n    var begin = this.idx;\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n      case \"[\":\n        atom = this.characterClass();\n        break;\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n    ASSERT_EXISTS(atom);\n    atom.loc = this.loc(begin);\n    if (this.isQuantifier()) {\n      atom.quantifier = this.quantifier();\n    }\n    return atom;\n  };\n  RegExpParser.prototype.dotAll = function () {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  };\n  RegExpParser.prototype.atomEscape = function () {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n  RegExpParser.prototype.decimalEscapeAtom = function () {\n    var value = this.positiveInteger();\n    return {\n      type: \"GroupBackReference\",\n      value: value\n    };\n  };\n  RegExpParser.prototype.characterClassEscape = function () {\n    var set;\n    var complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n    ASSERT_EXISTS(set);\n    return {\n      type: \"Set\",\n      value: set,\n      complement: complement\n    };\n  };\n  RegExpParser.prototype.controlEscapeAtom = function () {\n    var escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n    ASSERT_EXISTS(escapeCode);\n    return {\n      type: \"Character\",\n      value: escapeCode\n    };\n  };\n  RegExpParser.prototype.controlLetterEscapeAtom = function () {\n    this.consumeChar(\"c\");\n    var letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n    var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return {\n      type: \"Character\",\n      value: letterCode\n    };\n  };\n  RegExpParser.prototype.nulCharacterAtom = function () {\n    // TODO implement '[lookahead ∉ DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return {\n      type: \"Character\",\n      value: cc(\"\\0\")\n    };\n  };\n  RegExpParser.prototype.hexEscapeSequenceAtom = function () {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  };\n  RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function () {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  };\n  RegExpParser.prototype.identityEscapeAtom = function () {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    var escapedChar = this.popChar();\n    return {\n      type: \"Character\",\n      value: cc(escapedChar)\n    };\n  };\n  RegExpParser.prototype.classPatternCharacterAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        var nextChar = this.popChar();\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n  RegExpParser.prototype.characterClass = function () {\n    var set = [];\n    var complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n    while (this.isClassAtom()) {\n      var from = this.classAtom();\n      var isFromSingleChar = from.type === \"Character\";\n      if (isFromSingleChar && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        var to = this.classAtom();\n        var isToSingleChar = to.type === \"Character\";\n\n        // a range can only be used when both sides are single characters\n        if (isToSingleChar) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({\n            from: from.value,\n            to: to.value\n          });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n    this.consumeChar(\"]\");\n    return {\n      type: \"Set\",\n      complement: complement,\n      value: set\n    };\n  };\n  RegExpParser.prototype.classAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\":\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  };\n  RegExpParser.prototype.classEscape = function () {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return {\n          type: \"Character\",\n          value: cc(\"\\u0008\")\n        };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n  RegExpParser.prototype.group = function () {\n    var capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    var value = this.disjunction();\n    this.consumeChar(\")\");\n    var groupAst = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value\n    };\n    if (capturing) {\n      groupAst.idx = this.groupIdx;\n    }\n    return groupAst;\n  };\n  RegExpParser.prototype.positiveInteger = function () {\n    var number = this.popChar();\n\n    // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  };\n  RegExpParser.prototype.integerIncludingZero = function () {\n    var number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  };\n  RegExpParser.prototype.patternCharacter = function () {\n    var nextChar = this.popChar();\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"^\":\n      // istanbul ignore next\n      case \"$\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \".\":\n      // istanbul ignore next\n      case \"*\":\n      // istanbul ignore next\n      case \"+\":\n      // istanbul ignore next\n      case \"?\":\n      // istanbul ignore next\n      case \"(\":\n      // istanbul ignore next\n      case \")\":\n      // istanbul ignore next\n      case \"[\":\n      // istanbul ignore next\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n      default:\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n  RegExpParser.prototype.isRegExpFlag = function () {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  RegExpParser.prototype.isRangeDash = function () {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  };\n  RegExpParser.prototype.isDigit = function () {\n    return decimalPattern.test(this.peekChar(0));\n  };\n  RegExpParser.prototype.isClassAtom = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  };\n  RegExpParser.prototype.isTerm = function () {\n    return this.isAtom() || this.isAssertion();\n  };\n  RegExpParser.prototype.isAtom = function () {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n      case \"(\":\n        // group\n        return true;\n      default:\n        return false;\n    }\n  };\n  RegExpParser.prototype.isAssertion = function () {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      // '(?=' or '(?!'\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n      default:\n        return false;\n    }\n  };\n  RegExpParser.prototype.isQuantifier = function () {\n    var prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  };\n  RegExpParser.prototype.isPatternCharacter = function () {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  };\n  RegExpParser.prototype.parseHexDigits = function (howMany) {\n    var hexString = \"\";\n    for (var i = 0; i < howMany; i++) {\n      var hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    var charCode = parseInt(hexString, 16);\n    return {\n      type: \"Character\",\n      value: charCode\n    };\n  };\n  RegExpParser.prototype.peekChar = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n    return this.input[this.idx + howMuch];\n  };\n  RegExpParser.prototype.popChar = function () {\n    var nextChar = this.peekChar(0);\n    this.consumeChar();\n    return nextChar;\n  };\n  RegExpParser.prototype.consumeChar = function (char) {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  };\n  RegExpParser.prototype.loc = function (begin) {\n    return {\n      begin: begin,\n      end: this.idx\n    };\n  };\n\n  // consts and utilities\n  var hexDigitPattern = /[0-9a-fA-F]/;\n  var decimalPattern = /[0-9]/;\n  var decimalPatternNoZero = /[1-9]/;\n  function cc(char) {\n    return char.charCodeAt(0);\n  }\n  function insertToSet(item, set) {\n    if (item.length !== undefined) {\n      item.forEach(function (subItem) {\n        set.push(subItem);\n      });\n    } else {\n      set.push(item);\n    }\n  }\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw \"duplicate flag \" + flagKey;\n    }\n    flagObj[flagKey] = true;\n  }\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n  }\n\n  // istanbul ignore next\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  var i;\n  var digitsCharCodes = [];\n  for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n  }\n  var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n  for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n  }\n  for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n  var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\\t\"), cc(\"\\v\"), cc(\"\\t\"), cc(\"\\u00a0\"), cc(\"\\u1680\"), cc(\"\\u2000\"), cc(\"\\u2001\"), cc(\"\\u2002\"), cc(\"\\u2003\"), cc(\"\\u2004\"), cc(\"\\u2005\"), cc(\"\\u2006\"), cc(\"\\u2007\"), cc(\"\\u2008\"), cc(\"\\u2009\"), cc(\"\\u200a\"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\"\\u202f\"), cc(\"\\u205f\"), cc(\"\\u3000\"), cc(\"\\ufeff\")];\n  function BaseRegExpVisitor() {}\n  BaseRegExpVisitor.prototype.visitChildren = function (node) {\n    for (var key in node) {\n      var child = node[key];\n      /* istanbul ignore else */\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach(function (subChild) {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  };\n  BaseRegExpVisitor.prototype.visit = function (node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n    this.visitChildren(node);\n  };\n  BaseRegExpVisitor.prototype.visitPattern = function (node) {};\n  BaseRegExpVisitor.prototype.visitFlags = function (node) {};\n  BaseRegExpVisitor.prototype.visitDisjunction = function (node) {};\n  BaseRegExpVisitor.prototype.visitAlternative = function (node) {};\n\n  // Assertion\n  BaseRegExpVisitor.prototype.visitStartAnchor = function (node) {};\n  BaseRegExpVisitor.prototype.visitEndAnchor = function (node) {};\n  BaseRegExpVisitor.prototype.visitWordBoundary = function (node) {};\n  BaseRegExpVisitor.prototype.visitNonWordBoundary = function (node) {};\n  BaseRegExpVisitor.prototype.visitLookahead = function (node) {};\n  BaseRegExpVisitor.prototype.visitNegativeLookahead = function (node) {};\n\n  // atoms\n  BaseRegExpVisitor.prototype.visitCharacter = function (node) {};\n  BaseRegExpVisitor.prototype.visitSet = function (node) {};\n  BaseRegExpVisitor.prototype.visitGroup = function (node) {};\n  BaseRegExpVisitor.prototype.visitGroupBackReference = function (node) {};\n  BaseRegExpVisitor.prototype.visitQuantifier = function (node) {};\n  return {\n    RegExpParser: RegExpParser,\n    BaseRegExpVisitor: BaseRegExpVisitor,\n    VERSION: \"0.5.0\"\n  };\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","regexpToAst","self","RegExpParser","prototype","saveState","idx","input","groupIdx","restoreState","newState","pattern","consumeChar","value","disjunction","flags","type","loc","begin","end","length","global","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","addFlag","Error","substring","alts","push","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","quantifier","isBacktracking","range","atLeast","atMost","Infinity","integerIncludingZero","isDigit","undefined","greedy","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","cc","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","set","digitsCharCodes","whitespaceCodes","wordCharCodes","escapeCode","letter","test","letterCode","toUpperCase","charCodeAt","parseHexDigits","escapedChar","classPatternCharacterAtom","nextChar","isClassAtom","from","classAtom","isFromSingleChar","isRangeDash","to","isToSingleChar","insertToSet","classEscape","capturing","groupAst","number","decimalPatternNoZero","decimalPattern","parseInt","howMuch","isAtom","prevState","e","howMany","hexString","i","hexChar","hexDigitPattern","charCode","char","item","forEach","subItem","flagObj","flagKey","obj","concat","BaseRegExpVisitor","visitChildren","node","key","child","hasOwnProperty","visit","Array","isArray","subChild","visitPattern","visitFlags","visitDisjunction","visitAlternative","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","VERSION"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/regexp-to-ast/lib/regexp-to-ast.js"],"sourcesContent":[";(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead ∉ DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}