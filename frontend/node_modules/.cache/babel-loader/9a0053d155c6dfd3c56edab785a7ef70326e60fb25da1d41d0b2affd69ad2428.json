{"ast":null,"code":"import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n  for (let i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  for (let i = 0; i < this.nMips; i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n    this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new FullScreenQuad(null);\n};\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function () {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n    this.renderTargetBright.dispose();\n  },\n  setSize: function (width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function (kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\n      fragmentShader: '#include <common>' + 'varying vec2 vUv;\\n' + 'uniform sampler2D colorTexture;\\n' + 'uniform vec2 texSize;' + 'uniform vec2 direction;' + '\\n' + 'float gaussianPdf(in float x, in float sigma) {' + '\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;' + '}' + 'void main() {\\n' + '\tvec2 invSize = 1.0 / texSize;' + '\tfloat fSigma = float(SIGMA);' + '\tfloat weightSum = gaussianPdf(0.0, fSigma);' + '\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;' + '\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {' + '\t\tfloat x = float(i);' + '\t\tfloat w = gaussianPdf(x, fSigma);' + '\t\tvec2 uvOffset = direction * invSize * x;' + '\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;' + '\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;' + '\t\tdiffuseSum += (sample1 + sample2) * w;' + '\t\tweightSum += 2.0 * w;' + '\t}' + '\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n' + '}'\n    });\n  },\n  getCompositeMaterial: function (nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\n      fragmentShader: 'varying vec2 vUv;' + 'uniform sampler2D blurTexture1;' + 'uniform sampler2D blurTexture2;' + 'uniform sampler2D blurTexture3;' + 'uniform sampler2D blurTexture4;' + 'uniform sampler2D blurTexture5;' + 'uniform sampler2D dirtTexture;' + 'uniform float bloomStrength;' + 'uniform float bloomRadius;' + 'uniform float bloomFactors[NUM_MIPS];' + 'uniform vec3 bloomTintColors[NUM_MIPS];' + '' + 'float lerpBloomFactor(const in float factor) { ' + '\tfloat mirrorFactor = 1.2 - factor;' + '\treturn mix(factor, mirrorFactor, bloomRadius);' + '}' + '' + 'void main() {' + '\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );' + '}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"names":["Vector2","Color","WebGLRenderTarget","UniformsUtils","ShaderMaterial","Vector3","AdditiveBlending","MeshBasicMaterial","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","LuminosityHighPassShader","UnrealBloomPass","resolution","strength","radius","threshold","undefined","x","y","clearColor","pars","minFilter","magFilter","format","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","prototype","Object","assign","create","constructor","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomRadius"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (let i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (let i = 0; i < this.nMips; i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n    this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function () {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function (width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function (kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\n      fragmentShader: '#include <common>' + 'varying vec2 vUv;\\n' + 'uniform sampler2D colorTexture;\\n' + 'uniform vec2 texSize;' + 'uniform vec2 direction;' + '\\n' + 'float gaussianPdf(in float x, in float sigma) {' + '\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;' + '}' + 'void main() {\\n' + '\tvec2 invSize = 1.0 / texSize;' + '\tfloat fSigma = float(SIGMA);' + '\tfloat weightSum = gaussianPdf(0.0, fSigma);' + '\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;' + '\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {' + '\t\tfloat x = float(i);' + '\t\tfloat w = gaussianPdf(x, fSigma);' + '\t\tvec2 uvOffset = direction * invSize * x;' + '\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;' + '\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;' + '\t\tdiffuseSum += (sample1 + sample2) * w;' + '\t\tweightSum += 2.0 * w;' + '\t}' + '\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n' + '}'\n    });\n  },\n  getCompositeMaterial: function (nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\n      fragmentShader: 'varying vec2 vUv;' + 'uniform sampler2D blurTexture1;' + 'uniform sampler2D blurTexture2;' + 'uniform sampler2D blurTexture3;' + 'uniform sampler2D blurTexture4;' + 'uniform sampler2D blurTexture5;' + 'uniform sampler2D dirtTexture;' + 'uniform float bloomStrength;' + 'uniform float bloomRadius;' + 'uniform float bloomFactors[NUM_MIPS];' + 'uniform vec3 bloomTintColors[NUM_MIPS];' + '' + 'float lerpBloomFactor(const in float factor) { ' + '\tfloat mirrorFactor = 1.2 - factor;' + '\treturn mix(factor, mirrorFactor, bloomRadius);' + '}' + '' + 'void main() {' + '\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );' + '}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\n\nexport { UnrealBloomPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}