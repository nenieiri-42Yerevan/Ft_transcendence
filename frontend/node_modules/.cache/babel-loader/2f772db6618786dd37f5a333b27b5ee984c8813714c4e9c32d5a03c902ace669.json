{"ast":null,"code":"import { Curve, Vector4, Vector3 } from 'three';\nimport { calcBSplinePoint, calcNURBSDerivatives } from './NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n  constructor(degree, knots\n  /* array of reals */, controlPoints\n  /* array of Vector(2|3|4) */, startKnot\n  /* index in knots */, endKnot\n  /* index in knots */) {\n    super();\n    this.degree = degree;\n    this.knots = knots;\n    this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\n\n    this.startKnot = startKnot || 0;\n    this.endKnot = endKnot || this.knots.length - 1;\n    for (let i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      const point = controlPoints[i];\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n  }\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector3();\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n    // following results in (wx, wy, wz, w) homogeneous point\n\n    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n    if (hpoint.w != 1.0) {\n      // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n      hpoint.divideScalar(hpoint.w);\n    }\n    return point.set(hpoint.x, hpoint.y, hpoint.z);\n  }\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector3();\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n    tangent.copy(ders[1]).normalize();\n    return tangent;\n  }\n}\nexport { NURBSCurve };","map":{"version":3,"names":["Curve","Vector4","Vector3","calcBSplinePoint","calcNURBSDerivatives","NURBSCurve","constructor","degree","knots","controlPoints","startKnot","endKnot","length","i","point","x","y","z","w","getPoint","t","optionalTarget","u","hpoint","divideScalar","set","getTangent","tangent","ders","copy","normalize"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/curves/NURBSCurve.js"],"sourcesContent":["import { Curve, Vector4, Vector3 } from 'three';\nimport { calcBSplinePoint, calcNURBSDerivatives } from './NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n  constructor(degree, knots\n  /* array of reals */\n  , controlPoints\n  /* array of Vector(2|3|4) */\n  , startKnot\n  /* index in knots */\n  , endKnot\n  /* index in knots */\n  ) {\n    super();\n    this.degree = degree;\n    this.knots = knots;\n    this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\n\n    this.startKnot = startKnot || 0;\n    this.endKnot = endKnot || this.knots.length - 1;\n\n    for (let i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      const point = controlPoints[i];\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n  }\n\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector3();\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n    // following results in (wx, wy, wz, w) homogeneous point\n\n    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n\n    if (hpoint.w != 1.0) {\n      // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n      hpoint.divideScalar(hpoint.w);\n    }\n\n    return point.set(hpoint.x, hpoint.y, hpoint.z);\n  }\n\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector3();\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n    tangent.copy(ders[1]).normalize();\n    return tangent;\n  }\n\n}\n\nexport { NURBSCurve };\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,OAAO,EAAEC,OAAO,QAAQ,OAAO;AAC/C,SAASC,gBAAgB,EAAEC,oBAAoB,QAAQ,iBAAiB;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,UAAU,SAASL,KAAK,CAAC;EAC7BM,WAAW,CAACC,MAAM,EAAEC;EACpB,sBACEC;EACF,8BACEC;EACF,sBACEC;EACF,sBACE;IACA,KAAK,EAAE;IACP,IAAI,CAACJ,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,aAAa,GAAG,EAAE,CAAC,CAAC;;IAEzB,IAAI,CAACC,SAAS,GAAGA,SAAS,IAAI,CAAC;IAC/B,IAAI,CAACC,OAAO,GAAGA,OAAO,IAAI,IAAI,CAACH,KAAK,CAACI,MAAM,GAAG,CAAC;IAE/C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,aAAa,CAACG,MAAM,EAAE,EAAEC,CAAC,EAAE;MAC7C;MACA,MAAMC,KAAK,GAAGL,aAAa,CAACI,CAAC,CAAC;MAC9B,IAAI,CAACJ,aAAa,CAACI,CAAC,CAAC,GAAG,IAAIZ,OAAO,CAACa,KAAK,CAACC,CAAC,EAAED,KAAK,CAACE,CAAC,EAAEF,KAAK,CAACG,CAAC,EAAEH,KAAK,CAACI,CAAC,CAAC;IACzE;EACF;EAEAC,QAAQ,CAACC,CAAC,EAAEC,cAAc,EAAE;IAC1B,MAAMP,KAAK,GAAGO,cAAc,IAAI,IAAInB,OAAO,EAAE;IAC7C,MAAMoB,CAAC,GAAG,IAAI,CAACd,KAAK,CAAC,IAAI,CAACE,SAAS,CAAC,GAAGU,CAAC,IAAI,IAAI,CAACZ,KAAK,CAAC,IAAI,CAACG,OAAO,CAAC,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,CAAC;IACpG;;IAEA,MAAMa,MAAM,GAAGpB,gBAAgB,CAAC,IAAI,CAACI,MAAM,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,aAAa,EAAEa,CAAC,CAAC;IAE/E,IAAIC,MAAM,CAACL,CAAC,IAAI,GAAG,EAAE;MACnB;MACAK,MAAM,CAACC,YAAY,CAACD,MAAM,CAACL,CAAC,CAAC;IAC/B;IAEA,OAAOJ,KAAK,CAACW,GAAG,CAACF,MAAM,CAACR,CAAC,EAAEQ,MAAM,CAACP,CAAC,EAAEO,MAAM,CAACN,CAAC,CAAC;EAChD;EAEAS,UAAU,CAACN,CAAC,EAAEC,cAAc,EAAE;IAC5B,MAAMM,OAAO,GAAGN,cAAc,IAAI,IAAInB,OAAO,EAAE;IAC/C,MAAMoB,CAAC,GAAG,IAAI,CAACd,KAAK,CAAC,CAAC,CAAC,GAAGY,CAAC,IAAI,IAAI,CAACZ,KAAK,CAAC,IAAI,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC;IACjF,MAAMoB,IAAI,GAAGxB,oBAAoB,CAAC,IAAI,CAACG,MAAM,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,aAAa,EAAEa,CAAC,EAAE,CAAC,CAAC;IACpFK,OAAO,CAACE,IAAI,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC,CAACE,SAAS,EAAE;IACjC,OAAOH,OAAO;EAChB;AAEF;AAEA,SAAStB,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}