{"ast":null,"code":"import { WebGLRenderTarget, LinearFilter, Vector2, Scene, Camera, BufferGeometry, BufferAttribute, Mesh } from 'three';\nimport { ConvolutionMaterial } from './ConvolutionMaterial.js';\nclass BlurPass {\n  constructor(_ref) {\n    let {\n      gl,\n      resolution,\n      width = 500,\n      height = 500,\n      minDepthThreshold = 0,\n      maxDepthThreshold = 1,\n      depthScale = 0,\n      depthToBlurRatioBias = 0.25\n    } = _ref;\n    this.renderToScreen = false;\n    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      stencilBuffer: false,\n      depthBuffer: false,\n      encoding: gl.outputEncoding\n    });\n    this.renderTargetB = this.renderTargetA.clone();\n    this.convolutionMaterial = new ConvolutionMaterial();\n    this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);\n    this.convolutionMaterial.setResolution(new Vector2(width, height));\n    this.scene = new Scene();\n    this.camera = new Camera();\n    this.convolutionMaterial.uniforms.minDepthThreshold.value = minDepthThreshold;\n    this.convolutionMaterial.uniforms.maxDepthThreshold.value = maxDepthThreshold;\n    this.convolutionMaterial.uniforms.depthScale.value = depthScale;\n    this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = depthToBlurRatioBias;\n    this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;\n    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));\n    this.screen = new Mesh(geometry, this.convolutionMaterial);\n    this.screen.frustumCulled = false;\n    this.scene.add(this.screen);\n  }\n  render(renderer, inputBuffer, outputBuffer) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    let material = this.convolutionMaterial;\n    let uniforms = material.uniforms;\n    uniforms.depthBuffer.value = inputBuffer.depthTexture;\n    const kernel = material.kernel;\n    let lastRT = inputBuffer;\n    let destRT;\n    let i, l; // Apply the multi-pass blur.\n\n    for (i = 0, l = kernel.length - 1; i < l; ++i) {\n      // Alternate between targets.\n      destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      uniforms.kernel.value = kernel[i];\n      uniforms.inputBuffer.value = lastRT.texture;\n      renderer.setRenderTarget(destRT);\n      renderer.render(scene, camera);\n      lastRT = destRT;\n    }\n    uniforms.kernel.value = kernel[i];\n    uniforms.inputBuffer.value = lastRT.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n}\nexport { BlurPass };","map":{"version":3,"names":["WebGLRenderTarget","LinearFilter","Vector2","Scene","Camera","BufferGeometry","BufferAttribute","Mesh","ConvolutionMaterial","BlurPass","constructor","gl","resolution","width","height","minDepthThreshold","maxDepthThreshold","depthScale","depthToBlurRatioBias","renderToScreen","renderTargetA","minFilter","magFilter","stencilBuffer","depthBuffer","encoding","outputEncoding","renderTargetB","clone","convolutionMaterial","setTexelSize","setResolution","scene","camera","uniforms","value","defines","USE_DEPTH","vertices","Float32Array","uvs","geometry","setAttribute","screen","frustumCulled","add","render","renderer","inputBuffer","outputBuffer","material","depthTexture","kernel","lastRT","destRT","i","l","length","texture","setRenderTarget"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/@react-three/drei/materials/BlurPass.js"],"sourcesContent":["import { WebGLRenderTarget, LinearFilter, Vector2, Scene, Camera, BufferGeometry, BufferAttribute, Mesh } from 'three';\nimport { ConvolutionMaterial } from './ConvolutionMaterial.js';\n\nclass BlurPass {\n  constructor({\n    gl,\n    resolution,\n    width = 500,\n    height = 500,\n    minDepthThreshold = 0,\n    maxDepthThreshold = 1,\n    depthScale = 0,\n    depthToBlurRatioBias = 0.25\n  }) {\n    this.renderToScreen = false;\n    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      stencilBuffer: false,\n      depthBuffer: false,\n      encoding: gl.outputEncoding\n    });\n    this.renderTargetB = this.renderTargetA.clone();\n    this.convolutionMaterial = new ConvolutionMaterial();\n    this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);\n    this.convolutionMaterial.setResolution(new Vector2(width, height));\n    this.scene = new Scene();\n    this.camera = new Camera();\n    this.convolutionMaterial.uniforms.minDepthThreshold.value = minDepthThreshold;\n    this.convolutionMaterial.uniforms.maxDepthThreshold.value = maxDepthThreshold;\n    this.convolutionMaterial.uniforms.depthScale.value = depthScale;\n    this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = depthToBlurRatioBias;\n    this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;\n    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));\n    this.screen = new Mesh(geometry, this.convolutionMaterial);\n    this.screen.frustumCulled = false;\n    this.scene.add(this.screen);\n  }\n\n  render(renderer, inputBuffer, outputBuffer) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    let material = this.convolutionMaterial;\n    let uniforms = material.uniforms;\n    uniforms.depthBuffer.value = inputBuffer.depthTexture;\n    const kernel = material.kernel;\n    let lastRT = inputBuffer;\n    let destRT;\n    let i, l; // Apply the multi-pass blur.\n\n    for (i = 0, l = kernel.length - 1; i < l; ++i) {\n      // Alternate between targets.\n      destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      uniforms.kernel.value = kernel[i];\n      uniforms.inputBuffer.value = lastRT.texture;\n      renderer.setRenderTarget(destRT);\n      renderer.render(scene, camera);\n      lastRT = destRT;\n    }\n\n    uniforms.kernel.value = kernel[i];\n    uniforms.inputBuffer.value = lastRT.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n\n}\n\nexport { BlurPass };\n"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,YAAY,EAAEC,OAAO,EAAEC,KAAK,EAAEC,MAAM,EAAEC,cAAc,EAAEC,eAAe,EAAEC,IAAI,QAAQ,OAAO;AACtH,SAASC,mBAAmB,QAAQ,0BAA0B;AAE9D,MAAMC,QAAQ,CAAC;EACbC,WAAW,OASR;IAAA,IATS;MACVC,EAAE;MACFC,UAAU;MACVC,KAAK,GAAG,GAAG;MACXC,MAAM,GAAG,GAAG;MACZC,iBAAiB,GAAG,CAAC;MACrBC,iBAAiB,GAAG,CAAC;MACrBC,UAAU,GAAG,CAAC;MACdC,oBAAoB,GAAG;IACzB,CAAC;IACC,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACC,aAAa,GAAG,IAAIpB,iBAAiB,CAACY,UAAU,EAAEA,UAAU,EAAE;MACjES,SAAS,EAAEpB,YAAY;MACvBqB,SAAS,EAAErB,YAAY;MACvBsB,aAAa,EAAE,KAAK;MACpBC,WAAW,EAAE,KAAK;MAClBC,QAAQ,EAAEd,EAAE,CAACe;IACf,CAAC,CAAC;IACF,IAAI,CAACC,aAAa,GAAG,IAAI,CAACP,aAAa,CAACQ,KAAK,EAAE;IAC/C,IAAI,CAACC,mBAAmB,GAAG,IAAIrB,mBAAmB,EAAE;IACpD,IAAI,CAACqB,mBAAmB,CAACC,YAAY,CAAC,GAAG,GAAGjB,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;IAChE,IAAI,CAACe,mBAAmB,CAACE,aAAa,CAAC,IAAI7B,OAAO,CAACW,KAAK,EAAEC,MAAM,CAAC,CAAC;IAClE,IAAI,CAACkB,KAAK,GAAG,IAAI7B,KAAK,EAAE;IACxB,IAAI,CAAC8B,MAAM,GAAG,IAAI7B,MAAM,EAAE;IAC1B,IAAI,CAACyB,mBAAmB,CAACK,QAAQ,CAACnB,iBAAiB,CAACoB,KAAK,GAAGpB,iBAAiB;IAC7E,IAAI,CAACc,mBAAmB,CAACK,QAAQ,CAAClB,iBAAiB,CAACmB,KAAK,GAAGnB,iBAAiB;IAC7E,IAAI,CAACa,mBAAmB,CAACK,QAAQ,CAACjB,UAAU,CAACkB,KAAK,GAAGlB,UAAU;IAC/D,IAAI,CAACY,mBAAmB,CAACK,QAAQ,CAAChB,oBAAoB,CAACiB,KAAK,GAAGjB,oBAAoB;IACnF,IAAI,CAACW,mBAAmB,CAACO,OAAO,CAACC,SAAS,GAAGpB,UAAU,GAAG,CAAC;IAC3D,MAAMqB,QAAQ,GAAG,IAAIC,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAClE,MAAMC,GAAG,GAAG,IAAID,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAChD,MAAME,QAAQ,GAAG,IAAIpC,cAAc,EAAE;IACrCoC,QAAQ,CAACC,YAAY,CAAC,UAAU,EAAE,IAAIpC,eAAe,CAACgC,QAAQ,EAAE,CAAC,CAAC,CAAC;IACnEG,QAAQ,CAACC,YAAY,CAAC,IAAI,EAAE,IAAIpC,eAAe,CAACkC,GAAG,EAAE,CAAC,CAAC,CAAC;IACxD,IAAI,CAACG,MAAM,GAAG,IAAIpC,IAAI,CAACkC,QAAQ,EAAE,IAAI,CAACZ,mBAAmB,CAAC;IAC1D,IAAI,CAACc,MAAM,CAACC,aAAa,GAAG,KAAK;IACjC,IAAI,CAACZ,KAAK,CAACa,GAAG,CAAC,IAAI,CAACF,MAAM,CAAC;EAC7B;EAEAG,MAAM,CAACC,QAAQ,EAAEC,WAAW,EAAEC,YAAY,EAAE;IAC1C,MAAMjB,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMC,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,MAAMb,aAAa,GAAG,IAAI,CAACA,aAAa;IACxC,MAAMO,aAAa,GAAG,IAAI,CAACA,aAAa;IACxC,IAAIuB,QAAQ,GAAG,IAAI,CAACrB,mBAAmB;IACvC,IAAIK,QAAQ,GAAGgB,QAAQ,CAAChB,QAAQ;IAChCA,QAAQ,CAACV,WAAW,CAACW,KAAK,GAAGa,WAAW,CAACG,YAAY;IACrD,MAAMC,MAAM,GAAGF,QAAQ,CAACE,MAAM;IAC9B,IAAIC,MAAM,GAAGL,WAAW;IACxB,IAAIM,MAAM;IACV,IAAIC,CAAC,EAAEC,CAAC,CAAC,CAAC;;IAEV,KAAKD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGJ,MAAM,CAACK,MAAM,GAAG,CAAC,EAAEF,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;MAC7C;MACAD,MAAM,GAAG,CAACC,CAAC,GAAG,CAAC,MAAM,CAAC,GAAGnC,aAAa,GAAGO,aAAa;MACtDO,QAAQ,CAACkB,MAAM,CAACjB,KAAK,GAAGiB,MAAM,CAACG,CAAC,CAAC;MACjCrB,QAAQ,CAACc,WAAW,CAACb,KAAK,GAAGkB,MAAM,CAACK,OAAO;MAC3CX,QAAQ,CAACY,eAAe,CAACL,MAAM,CAAC;MAChCP,QAAQ,CAACD,MAAM,CAACd,KAAK,EAAEC,MAAM,CAAC;MAC9BoB,MAAM,GAAGC,MAAM;IACjB;IAEApB,QAAQ,CAACkB,MAAM,CAACjB,KAAK,GAAGiB,MAAM,CAACG,CAAC,CAAC;IACjCrB,QAAQ,CAACc,WAAW,CAACb,KAAK,GAAGkB,MAAM,CAACK,OAAO;IAC3CX,QAAQ,CAACY,eAAe,CAAC,IAAI,CAACxC,cAAc,GAAG,IAAI,GAAG8B,YAAY,CAAC;IACnEF,QAAQ,CAACD,MAAM,CAACd,KAAK,EAAEC,MAAM,CAAC;EAChC;AAEF;AAEA,SAASxB,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}