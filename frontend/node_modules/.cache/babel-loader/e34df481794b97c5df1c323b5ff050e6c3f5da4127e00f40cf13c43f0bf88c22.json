{"ast":null,"code":"import { Triangle, Vector3 } from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nvar MeshSurfaceSampler = function () {\n  var _face = new Triangle();\n  var _color = new Vector3();\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function (name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function () {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n        _face.a.fromBufferAttribute(positionAttribute, i);\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n      for (let i = 0; i < faceWeights.length; i++) {\n        cumulativeTotal += faceWeights[i];\n        this.distribution[i] = cumulativeTotal;\n      }\n      return this;\n    },\n    setRandomGenerator: function (randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function (targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function (x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n      return index;\n    },\n    sampleFace: function (faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\nexport { MeshSurfaceSampler };","map":{"version":3,"names":["Triangle","Vector3","MeshSurfaceSampler","_face","_color","mesh","geometry","isBufferGeometry","attributes","position","itemSize","Error","index","console","warn","toNonIndexed","randomFunction","Math","random","positionAttribute","getAttribute","colorAttribute","weightAttribute","distribution","prototype","constructor","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","faceIndex","binarySearch","sampleFace","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","undefined","getNormal","r","g","y","z"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/math/MeshSurfaceSampler.js"],"sourcesContent":["import { Triangle, Vector3 } from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nvar MeshSurfaceSampler = function () {\n  var _face = new Triangle();\n\n  var _color = new Vector3();\n\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function (name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function () {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n\n        _face.a.fromBufferAttribute(positionAttribute, i);\n\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n\n      for (let i = 0; i < faceWeights.length; i++) {\n        cumulativeTotal += faceWeights[i];\n        this.distribution[i] = cumulativeTotal;\n      }\n\n      return this;\n    },\n    setRandomGenerator: function (randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function (targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function (x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n\n      return index;\n    },\n    sampleFace: function (faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\n\nexport { MeshSurfaceSampler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}