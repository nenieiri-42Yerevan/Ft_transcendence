{"ast":null,"code":"import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4 } from 'three';\nclass Refractor extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    this.type = 'Refractor';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Refractor.RefractorShader; //\n\n    const virtualCamera = new PerspectiveCamera();\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true; //\n\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4(); // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight); // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n    });\n\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    } //\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    } //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // Render\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return; // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n}\nRefractor.prototype.isRefractor = true;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\nexport { Refractor };","map":{"version":3,"names":["Mesh","Color","PerspectiveCamera","Plane","Matrix4","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","Refractor","constructor","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","RefractorShader","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","material","uniforms","clone","vertexShader","fragmentShader","transparent","value","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","encoding","outputEncoding","dispose","prototype","isRefractor","tDiffuse"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/objects/Refractor.js"],"sourcesContent":["import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4 } from 'three';\n\nclass Refractor extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Refractor';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Refractor.RefractorShader; //\n\n    const virtualCamera = new PerspectiveCamera();\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true; //\n\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4(); // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight); // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    } //\n\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    } //\n\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // Render\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return; // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nRefractor.prototype.isRefractor = true;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Refractor };\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,KAAK,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,cAAc,EAAEC,aAAa,EAAEC,OAAO,EAAEC,UAAU,EAAEC,OAAO,QAAQ,OAAO;AAEtJ,MAAMC,SAAS,SAASX,IAAI,CAAC;EAC3BY,WAAW,CAACC,QAAQ,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IAChC,KAAK,CAACD,QAAQ,CAAC;IACf,IAAI,CAACE,IAAI,GAAG,WAAW;IACvB,MAAMC,KAAK,GAAG,IAAI;IAClB,MAAMC,KAAK,GAAGH,OAAO,CAACG,KAAK,KAAKC,SAAS,GAAG,IAAIjB,KAAK,CAACa,OAAO,CAACG,KAAK,CAAC,GAAG,IAAIhB,KAAK,CAAC,QAAQ,CAAC;IAC1F,MAAMkB,YAAY,GAAGL,OAAO,CAACK,YAAY,IAAI,GAAG;IAChD,MAAMC,aAAa,GAAGN,OAAO,CAACM,aAAa,IAAI,GAAG;IAClD,MAAMC,QAAQ,GAAGP,OAAO,CAACO,QAAQ,IAAI,CAAC;IACtC,MAAMC,MAAM,GAAGR,OAAO,CAACQ,MAAM,IAAIX,SAAS,CAACY,eAAe,CAAC,CAAC;;IAE5D,MAAMC,aAAa,GAAG,IAAItB,iBAAiB,EAAE;IAC7CsB,aAAa,CAACC,gBAAgB,GAAG,KAAK;IACtCD,aAAa,CAACE,QAAQ,CAACC,SAAS,GAAG,IAAI,CAAC,CAAC;;IAEzC,MAAMC,cAAc,GAAG,IAAIzB,KAAK,EAAE;IAClC,MAAM0B,aAAa,GAAG,IAAIzB,OAAO,EAAE,CAAC,CAAC;;IAErC,MAAM0B,YAAY,GAAG,IAAIzB,iBAAiB,CAACc,YAAY,EAAEC,aAAa,CAAC,CAAC,CAAC;;IAEzE,IAAI,CAACW,QAAQ,GAAG,IAAIzB,cAAc,CAAC;MACjC0B,QAAQ,EAAEzB,aAAa,CAAC0B,KAAK,CAACX,MAAM,CAACU,QAAQ,CAAC;MAC9CE,YAAY,EAAEZ,MAAM,CAACY,YAAY;MACjCC,cAAc,EAAEb,MAAM,CAACa,cAAc;MACrCC,WAAW,EAAE,IAAI,CAAC;IAEpB,CAAC,CAAC;;IACF,IAAI,CAACL,QAAQ,CAACC,QAAQ,CAAC,OAAO,CAAC,CAACK,KAAK,GAAGpB,KAAK;IAC7C,IAAI,CAACc,QAAQ,CAACC,QAAQ,CAAC,UAAU,CAAC,CAACK,KAAK,GAAGP,YAAY,CAACQ,OAAO;IAC/D,IAAI,CAACP,QAAQ,CAACC,QAAQ,CAAC,eAAe,CAAC,CAACK,KAAK,GAAGR,aAAa,CAAC,CAAC;;IAE/D,MAAMU,OAAO,GAAG,YAAY;MAC1B,MAAMC,sBAAsB,GAAG,IAAIhC,OAAO,EAAE;MAC5C,MAAMiC,mBAAmB,GAAG,IAAIjC,OAAO,EAAE;MACzC,MAAMkC,cAAc,GAAG,IAAItC,OAAO,EAAE;MACpC,MAAMuC,IAAI,GAAG,IAAInC,OAAO,EAAE;MAC1B,MAAMoC,MAAM,GAAG,IAAIpC,OAAO,EAAE;MAC5B,OAAO,SAAS+B,OAAO,CAACM,MAAM,EAAE;QAC9BL,sBAAsB,CAACM,qBAAqB,CAAC9B,KAAK,CAAC+B,WAAW,CAAC;QAC/DN,mBAAmB,CAACK,qBAAqB,CAACD,MAAM,CAACE,WAAW,CAAC;QAC7DJ,IAAI,CAACK,UAAU,CAACR,sBAAsB,EAAEC,mBAAmB,CAAC;QAC5DC,cAAc,CAACO,eAAe,CAACjC,KAAK,CAAC+B,WAAW,CAAC;QACjDH,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACnBN,MAAM,CAACO,YAAY,CAACT,cAAc,CAAC;QACnC,OAAOC,IAAI,CAACS,GAAG,CAACR,MAAM,CAAC,GAAG,CAAC;MAC7B,CAAC;IACH,CAAC,EAAE;IAEH,MAAMS,oBAAoB,GAAG,YAAY;MACvC,MAAMT,MAAM,GAAG,IAAIpC,OAAO,EAAE;MAC5B,MAAM8C,QAAQ,GAAG,IAAI9C,OAAO,EAAE;MAC9B,MAAM+C,UAAU,GAAG,IAAI9C,UAAU,EAAE;MACnC,MAAM+C,KAAK,GAAG,IAAIhD,OAAO,EAAE;MAC3B,OAAO,SAAS6C,oBAAoB,GAAG;QACrCrC,KAAK,CAAC+B,WAAW,CAACU,SAAS,CAACH,QAAQ,EAAEC,UAAU,EAAEC,KAAK,CAAC;QACxDZ,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACQ,eAAe,CAACH,UAAU,CAAC,CAACI,SAAS,EAAE,CAAC,CAAC;;QAE7Df,MAAM,CAACgB,MAAM,EAAE;QACfhC,cAAc,CAACiC,6BAA6B,CAACjB,MAAM,EAAEU,QAAQ,CAAC;MAChE,CAAC;IACH,CAAC,EAAE;IAEH,MAAMQ,mBAAmB,GAAG,YAAY;MACtC,MAAMC,SAAS,GAAG,IAAI5D,KAAK,EAAE;MAC7B,MAAM6D,UAAU,GAAG,IAAItD,OAAO,EAAE;MAChC,MAAMuD,CAAC,GAAG,IAAIvD,OAAO,EAAE;MACvB,OAAO,SAASoD,mBAAmB,CAACjB,MAAM,EAAE;QAC1CrB,aAAa,CAACuB,WAAW,CAACmB,IAAI,CAACrB,MAAM,CAACE,WAAW,CAAC;QAClDvB,aAAa,CAAC2C,kBAAkB,CAACD,IAAI,CAAC1C,aAAa,CAACuB,WAAW,CAAC,CAACqB,MAAM,EAAE;QACzE5C,aAAa,CAAC6C,gBAAgB,CAACH,IAAI,CAACrB,MAAM,CAACwB,gBAAgB,CAAC;QAC5D7C,aAAa,CAAC8C,GAAG,GAAGzB,MAAM,CAACyB,GAAG,CAAC,CAAC;QAChC;QACA;QACA;;QAEAP,SAAS,CAACG,IAAI,CAACtC,cAAc,CAAC;QAC9BmC,SAAS,CAACZ,YAAY,CAAC3B,aAAa,CAAC2C,kBAAkB,CAAC;QACxDH,UAAU,CAACd,GAAG,CAACa,SAAS,CAACnB,MAAM,CAAC2B,CAAC,EAAER,SAAS,CAACnB,MAAM,CAAC4B,CAAC,EAAET,SAAS,CAACnB,MAAM,CAAC6B,CAAC,EAAEV,SAAS,CAACW,QAAQ,CAAC,CAAC,CAAC;QAChG;;QAEA,MAAML,gBAAgB,GAAG7C,aAAa,CAAC6C,gBAAgB;QACvDJ,CAAC,CAACM,CAAC,GAAG,CAACI,IAAI,CAACC,IAAI,CAACZ,UAAU,CAACO,CAAC,CAAC,GAAGF,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC;QAC7FZ,CAAC,CAACO,CAAC,GAAG,CAACG,IAAI,CAACC,IAAI,CAACZ,UAAU,CAACQ,CAAC,CAAC,GAAGH,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC;QAC7FZ,CAAC,CAACQ,CAAC,GAAG,CAAC,GAAG;QACVR,CAAC,CAACa,CAAC,GAAG,CAAC,GAAG,GAAGT,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;;QAE7Eb,UAAU,CAACe,cAAc,CAAC,GAAG,GAAGf,UAAU,CAACZ,GAAG,CAACa,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEpDI,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,GAAGb,UAAU,CAACO,CAAC;QAC3CF,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,GAAGb,UAAU,CAACQ,CAAC;QAC3CH,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,GAAGb,UAAU,CAACS,CAAC,GAAG,GAAG,GAAGpD,QAAQ;QAC7DgD,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,GAAGb,UAAU,CAACc,CAAC;MAC9C,CAAC;IACH,CAAC,EAAE,CAAC,CAAC;IACL;;IAGA,SAASE,mBAAmB,CAACnC,MAAM,EAAE;MACnC;MACAhB,aAAa,CAACqB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;MACnG;MACA;;MAEArB,aAAa,CAACoD,QAAQ,CAACpC,MAAM,CAACwB,gBAAgB,CAAC;MAC/CxC,aAAa,CAACoD,QAAQ,CAACpC,MAAM,CAACsB,kBAAkB,CAAC;MACjDtC,aAAa,CAACoD,QAAQ,CAACjE,KAAK,CAAC+B,WAAW,CAAC;IAC3C,CAAC,CAAC;;IAGF,SAASmC,MAAM,CAACC,QAAQ,EAAEC,KAAK,EAAEvC,MAAM,EAAE;MACvC7B,KAAK,CAACuB,OAAO,GAAG,KAAK;MACrB,MAAM8C,mBAAmB,GAAGF,QAAQ,CAACG,eAAe,EAAE;MACtD,MAAMC,gBAAgB,GAAGJ,QAAQ,CAACK,EAAE,CAACC,OAAO;MAC5C,MAAMC,uBAAuB,GAAGP,QAAQ,CAACQ,SAAS,CAACC,UAAU;MAC7DT,QAAQ,CAACK,EAAE,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;;MAE7BN,QAAQ,CAACQ,SAAS,CAACC,UAAU,GAAG,KAAK,CAAC,CAAC;;MAEvCT,QAAQ,CAACU,eAAe,CAAC/D,YAAY,CAAC;MACtC,IAAIqD,QAAQ,CAACW,SAAS,KAAK,KAAK,EAAEX,QAAQ,CAACY,KAAK,EAAE;MAClDZ,QAAQ,CAACD,MAAM,CAACE,KAAK,EAAE5D,aAAa,CAAC;MACrC2D,QAAQ,CAACK,EAAE,CAACC,OAAO,GAAGF,gBAAgB;MACtCJ,QAAQ,CAACQ,SAAS,CAACC,UAAU,GAAGF,uBAAuB;MACvDP,QAAQ,CAACU,eAAe,CAACR,mBAAmB,CAAC,CAAC,CAAC;;MAE/C,MAAMW,QAAQ,GAAGnD,MAAM,CAACmD,QAAQ;MAEhC,IAAIA,QAAQ,KAAK9E,SAAS,EAAE;QAC1BiE,QAAQ,CAACc,KAAK,CAACD,QAAQ,CAACA,QAAQ,CAAC;MACnC;MAEAhF,KAAK,CAACuB,OAAO,GAAG,IAAI;IACtB,CAAC,CAAC;;IAGF,IAAI,CAAC2D,cAAc,GAAG,UAAUf,QAAQ,EAAEC,KAAK,EAAEvC,MAAM,EAAE;MACvD;MACAf,YAAY,CAACQ,OAAO,CAAC6D,QAAQ,GAAGhB,QAAQ,CAACiB,cAAc,CAAC,CAAC;;MAEzD,IAAIvD,MAAM,CAACnB,QAAQ,CAACC,SAAS,KAAK,IAAI,EAAE,OAAO,CAAC;;MAEhD,IAAI,CAACY,OAAO,CAACM,MAAM,CAAC,KAAK,IAAI,EAAE,OAAO,CAAC;;MAEvCQ,oBAAoB,EAAE;MACtB2B,mBAAmB,CAACnC,MAAM,CAAC;MAC3BiB,mBAAmB,CAACjB,MAAM,CAAC;MAC3BqC,MAAM,CAACC,QAAQ,EAAEC,KAAK,EAAEvC,MAAM,CAAC;IACjC,CAAC;IAED,IAAI,CAACyC,eAAe,GAAG,YAAY;MACjC,OAAOxD,YAAY;IACrB,CAAC;IAED,IAAI,CAACuE,OAAO,GAAG,YAAY;MACzBvE,YAAY,CAACuE,OAAO,EAAE;MACtBrF,KAAK,CAACe,QAAQ,CAACsE,OAAO,EAAE;IAC1B,CAAC;EACH;AAEF;AAEA1F,SAAS,CAAC2F,SAAS,CAACC,WAAW,GAAG,IAAI;AACtC5F,SAAS,CAACY,eAAe,GAAG;EAC1BS,QAAQ,EAAE;IACRf,KAAK,EAAE;MACLoB,KAAK,EAAE;IACT,CAAC;IACDmE,QAAQ,EAAE;MACRnE,KAAK,EAAE;IACT,CAAC;IACDR,aAAa,EAAE;MACbQ,KAAK,EAAE;IACT;EACF,CAAC;EACDH,YAAY,EACZ;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EACFC,cAAc,EACd;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,SAASxB,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}