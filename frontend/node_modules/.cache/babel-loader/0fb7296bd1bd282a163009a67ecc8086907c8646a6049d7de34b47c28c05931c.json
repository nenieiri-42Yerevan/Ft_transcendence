{"ast":null,"code":"// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\nconst ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX',\n    // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX'\n  },\n  uniforms: {\n    bumpMap: {\n      value: null\n    },\n    map: {\n      value: null\n    },\n    parallaxScale: {\n      value: null\n    },\n    parallaxMinLayers: {\n      value: null\n    },\n    parallaxMaxLayers: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;',\n  // No Offset Limitting: messy, floating output at grazing angles.\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n  // Offset Limiting\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {',\n  // Determine number of layers from angle between V and N\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;',\n  // Shift of texture coordinates for each iteration\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n  // while ( heightFromTexture > currentLayerHeight )\n  // Infinite loops are not well supported. Do a \"large\" finite\n  // loop, but not too large, as it slows down some compilers.\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;',\n  // Shift texture coordinates along vector V\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;',\n  // Return to the mid point of previous layer\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;',\n  // Binary search to increase precision of Steep Parallax Mapping\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n  // Shift along or against vector V\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {',\n  // Below the surface\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {',\n  // above the surface\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;',\n  // Heights for linear interpolation\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;',\n  // Proportions for linear interpolation\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );',\n  // Interpolation of texture coordinates\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else',\n  // NO_PARALLAX\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\n};\nexport { ParallaxShader };","map":{"version":3,"names":["ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","bumpMap","value","map","parallaxScale","parallaxMinLayers","parallaxMaxLayers","vertexShader","join","fragmentShader"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/shaders/ParallaxShader.js"],"sourcesContent":["// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\nconst ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX',\n    // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX'\n  },\n  uniforms: {\n    bumpMap: {\n      value: null\n    },\n    map: {\n      value: null\n    },\n    parallaxScale: {\n      value: null\n    },\n    parallaxMinLayers: {\n      value: null\n    },\n    parallaxMaxLayers: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n  // Offset Limiting\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\n  // Infinite loops are not well supported. Do a \"large\" finite\n  // loop, but not too large, as it slows down some compilers.\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {', // above the surface\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else', // NO_PARALLAX\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\n};\n\nexport { ParallaxShader };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,MAAMA,cAAc,GAAG;EACrB;EACAC,KAAK,EAAE;IACLC,IAAI,EAAE,aAAa;IACnBC,KAAK,EAAE,oBAAoB;IAC3BC,KAAK,EAAE,oBAAoB;IAC3BC,SAAS,EAAE,uBAAuB;IAClC;IACAC,MAAM,EAAE;EACV,CAAC;EACDC,QAAQ,EAAE;IACRC,OAAO,EAAE;MACPC,KAAK,EAAE;IACT,CAAC;IACDC,GAAG,EAAE;MACHD,KAAK,EAAE;IACT,CAAC;IACDE,aAAa,EAAE;MACbF,KAAK,EAAE;IACT,CAAC;IACDG,iBAAiB,EAAE;MACjBH,KAAK,EAAE;IACT,CAAC;IACDI,iBAAiB,EAAE;MACjBJ,KAAK,EAAE;IACT;EACF,CAAC;EACDK,YAAY,EAAE,CAAC,mBAAmB,EAAE,6BAA6B,EAAE,uBAAuB,EAAE,eAAe,EAAE,YAAY,EAAE,6DAA6D,EAAE,mCAAmC,EAAE,gDAAgD,EAAE,+CAA+C,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EACjVC,cAAc,EAAE,CAAC,4BAA4B,EAAE,wBAAwB,EAAE,8BAA8B,EAAE,kCAAkC,EAAE,kCAAkC,EAAE,mBAAmB,EAAE,6BAA6B,EAAE,uBAAuB,EAAE,2BAA2B,EAAE,kCAAkC,EAAE,sDAAsD;EAAE;EACvX;EACA;EACA,+DAA+D,EAAE,gCAAgC,EAAE,IAAI,EAAE,OAAO,EAAE,kCAAkC;EAAE;EACtJ,0GAA0G,EAAE,wCAAwC,EAAE,mCAAmC;EAAE;EAC3L,uDAAuD,EAAE,oCAAoC,EAAE,2EAA2E;EAAE;EAC5K;EACA;EACA,uCAAuC,EAAE,qDAAqD,EAAE,YAAY,EAAE,MAAM,EAAE,uCAAuC;EAAE;EAC/J,kCAAkC,EAAE,sEAAsE,EAAE,KAAK,EAAE,6BAA6B,EAAE,iCAAiC,EAAE,wCAAwC,EAAE,qCAAqC,EAAE,2CAA2C;EAAE;EACnT,2CAA2C,EAAE,uCAAuC;EAAE;EACtF,+BAA+B,EAAE,iDAAiD,EAAE,2BAA2B,EAAE,yBAAyB,EAAE,uEAAuE;EAAE;EACrN,oDAAoD;EAAE;EACtD,6CAA6C,EAAE,yCAAyC,EAAE,cAAc;EAAE;EAC1G,6CAA6C,EAAE,yCAAyC,EAAE,OAAO,EAAE,MAAM,EAAE,iCAAiC,EAAE,0CAA0C,EAAE,oDAAoD;EAAE;EAChP,0DAA0D,EAAE,0FAA0F;EAAE;EACxJ,8CAA8C;EAAE;EAChD,2EAA2E,EAAE,SAAS;EAAE;EACxF,gBAAgB,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,2EAA2E,EAAE,4BAA4B,EAAE,4BAA4B,EAAE,uCAAuC,EAAE,uCAAuC,EAAE,2CAA2C,EAAE,2CAA2C,EAAE,oCAAoC,EAAE,gGAAgG,EAAE,kBAAkB,EAAE,4DAA4D,EAAE,iDAAiD,EAAE,mCAAmC,EAAE,GAAG,EAAE,eAAe,EAAE,8FAA8F,EAAE,0CAA0C,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;AACv0B,CAAC;AAED,SAASf,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}