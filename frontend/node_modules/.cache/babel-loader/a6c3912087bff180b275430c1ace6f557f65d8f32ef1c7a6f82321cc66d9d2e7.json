{"ast":null,"code":"import { Matrix3, OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\nconst AnaglyphEffect = function (renderer, width, height) {\n  // Dubois matrices from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.6968&rep=rep1&type=pdf#page=4\n  this.colorMatrixLeft = new Matrix3().fromArray([0.4561, -0.0400822, -0.0152161, 0.500484, -0.0378246, -0.0205971, 0.176381, -0.0157589, -0.00546856]);\n  this.colorMatrixRight = new Matrix3().fromArray([-0.0434706, 0.378476, -0.0721527, -0.0879388, 0.73364, -0.112961, -0.00155529, -0.0184503, 1.2264]);\n  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  const _scene = new Scene();\n  const _stereo = new StereoCamera();\n  const _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n  if (width === undefined) width = 512;\n  if (height === undefined) height = 512;\n  const _renderTargetL = new WebGLRenderTarget(width, height, _params);\n  const _renderTargetR = new WebGLRenderTarget(width, height, _params);\n  const _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      },\n      colorMatrixLeft: {\n        value: this.colorMatrixLeft\n      },\n      colorMatrixRight: {\n        value: this.colorMatrixRight\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'uniform mat3 colorMatrixLeft;', 'uniform mat3 colorMatrixRight;',\n    // These functions implement sRGB linearization and gamma correction\n    'float lin( float c ) {', '\treturn c <= 0.04045 ? c * 0.0773993808 :', '\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );', '}', 'vec4 lin( vec4 c ) {', '\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );', '}', 'float dev( float c ) {', '\treturn c <= 0.0031308 ? c * 12.92', '\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;', '}', 'void main() {', '\tvec2 uv = vUv;', '\tvec4 colorL = lin( texture2D( mapLeft, uv ) );', '\tvec4 colorR = lin( texture2D( mapRight, uv ) );', '\tvec3 color = clamp(', '\t\t\tcolorMatrixLeft * colorL.rgb +', '\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );', '\tgl_FragColor = vec4(', '\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),', '\t\t\tmax( colorL.a, colorR.a ) );', '}'].join('\\n')\n  });\n  const _mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n  _scene.add(_mesh);\n  this.setSize = (width, height) => {\n    renderer.setSize(width, height);\n    const pixelRatio = renderer.getPixelRatio();\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n  this.render = (scene, camera) => {\n    const currentRenderTarget = renderer.getRenderTarget();\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n    _stereo.update(camera);\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n  this.dispose = () => {\n    if (_renderTargetL) _renderTargetL.dispose();\n    if (_renderTargetR) _renderTargetR.dispose();\n    if (_mesh) _mesh.geometry.dispose();\n    if (_material) _material.dispose();\n  };\n};\nexport { AnaglyphEffect };","map":{"version":3,"names":["Matrix3","OrthographicCamera","Scene","StereoCamera","WebGLRenderTarget","ShaderMaterial","Mesh","PlaneGeometry","LinearFilter","NearestFilter","RGBAFormat","AnaglyphEffect","renderer","width","height","colorMatrixLeft","fromArray","colorMatrixRight","_camera","_scene","_stereo","_params","minFilter","magFilter","format","undefined","_renderTargetL","_renderTargetR","_material","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","_mesh","add","setSize","pixelRatio","getPixelRatio","render","scene","camera","currentRenderTarget","getRenderTarget","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR","dispose","geometry"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/effects/AnaglyphEffect.js"],"sourcesContent":["import { Matrix3, OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\n\nconst AnaglyphEffect = function (renderer, width, height) {\n  // Dubois matrices from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.6968&rep=rep1&type=pdf#page=4\n  this.colorMatrixLeft = new Matrix3().fromArray([0.4561, -0.0400822, -0.0152161, 0.500484, -0.0378246, -0.0205971, 0.176381, -0.0157589, -0.00546856]);\n  this.colorMatrixRight = new Matrix3().fromArray([-0.0434706, 0.378476, -0.0721527, -0.0879388, 0.73364, -0.112961, -0.00155529, -0.0184503, 1.2264]);\n\n  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  const _scene = new Scene();\n\n  const _stereo = new StereoCamera();\n\n  const _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n  if (width === undefined) width = 512;\n  if (height === undefined) height = 512;\n\n  const _renderTargetL = new WebGLRenderTarget(width, height, _params);\n\n  const _renderTargetR = new WebGLRenderTarget(width, height, _params);\n\n  const _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      },\n      colorMatrixLeft: {\n        value: this.colorMatrixLeft\n      },\n      colorMatrixRight: {\n        value: this.colorMatrixRight\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'uniform mat3 colorMatrixLeft;', 'uniform mat3 colorMatrixRight;', // These functions implement sRGB linearization and gamma correction\n    'float lin( float c ) {', '\treturn c <= 0.04045 ? c * 0.0773993808 :', '\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );', '}', 'vec4 lin( vec4 c ) {', '\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );', '}', 'float dev( float c ) {', '\treturn c <= 0.0031308 ? c * 12.92', '\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;', '}', 'void main() {', '\tvec2 uv = vUv;', '\tvec4 colorL = lin( texture2D( mapLeft, uv ) );', '\tvec4 colorR = lin( texture2D( mapRight, uv ) );', '\tvec3 color = clamp(', '\t\t\tcolorMatrixLeft * colorL.rgb +', '\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );', '\tgl_FragColor = vec4(', '\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),', '\t\t\tmax( colorL.a, colorR.a ) );', '}'].join('\\n')\n  });\n\n  const _mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n\n  _scene.add(_mesh);\n\n  this.setSize = (width, height) => {\n    renderer.setSize(width, height);\n    const pixelRatio = renderer.getPixelRatio();\n\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n\n  this.render = (scene, camera) => {\n    const currentRenderTarget = renderer.getRenderTarget();\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    _stereo.update(camera);\n\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n\n  this.dispose = () => {\n    if (_renderTargetL) _renderTargetL.dispose();\n    if (_renderTargetR) _renderTargetR.dispose();\n    if (_mesh) _mesh.geometry.dispose();\n    if (_material) _material.dispose();\n  };\n};\n\nexport { AnaglyphEffect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}