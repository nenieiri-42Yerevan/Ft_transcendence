{"ast":null,"code":"import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nclass Water2 extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    this.type = 'Water';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed || 0.03;\n    const reflectivity = options.reflectivity || 0.02;\n    const scale = options.scale || 1;\n    const shader = options.shader || Water2.WaterShader;\n    const encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n    const textureLoader = new TextureLoader();\n    const flowMap = options.flowMap || undefined;\n    const normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n    const normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n    const cycle = 0.15; // a cycle of a flow map phase\n\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock(); // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.');\n      return;\n    }\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.');\n      return;\n    }\n    const reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false; // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n    if (flowMap !== undefined) {\n      this.material.defines.USE_FLOWMAP = '';\n      this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection\n      };\n    } // maps\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n    this.material.uniforms['tNormalMap0'].value = normalMap0;\n    this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['reflectivity'].value = reflectivity;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n    this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n    this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n    this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n    this.material.uniforms['config'].value.w = scale; // scale\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms['config'];\n      config.value.x += flowSpeed * delta; // flowMapOffset0\n\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    } //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n}\nWater2.prototype.isWater = true;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader: /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n  fragmentShader: /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n};\nexport { Water2 };","map":{"version":3,"names":["Mesh","Color","Vector2","LinearEncoding","TextureLoader","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Vector4","Reflector","Refractor","Water2","constructor","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","textureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","prototype","isWater","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/objects/Water2.js"],"sourcesContent":["import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nclass Water2 extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Water';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed || 0.03;\n    const reflectivity = options.reflectivity || 0.02;\n    const scale = options.scale || 1;\n    const shader = options.shader || Water2.WaterShader;\n    const encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n    const textureLoader = new TextureLoader();\n    const flowMap = options.flowMap || undefined;\n    const normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n    const normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n    const cycle = 0.15; // a cycle of a flow map phase\n\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock(); // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.');\n      return;\n    }\n\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.');\n      return;\n    }\n\n    const reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false; // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n\n    if (flowMap !== undefined) {\n      this.material.defines.USE_FLOWMAP = '';\n      this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection\n      };\n    } // maps\n\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n    this.material.uniforms['tNormalMap0'].value = normalMap0;\n    this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['reflectivity'].value = reflectivity;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n    this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n    this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n    this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n    this.material.uniforms['config'].value.w = scale; // scale\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms['config'];\n      config.value.x += flowSpeed * delta; // flowMapOffset0\n\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    } //\n\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n\n}\n\nWater2.prototype.isWater = true;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n};\n\nexport { Water2 };\n"],"mappings":"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EAAE;MACvDD,mBAAmB,CAACC,MAAM,CAAC;MAC3BM,UAAU,EAAE;MACZpD,KAAK,CAAC2D,OAAO,GAAG,KAAK;MACrBnC,SAAS,CAAC2B,WAAW,CAACS,IAAI,CAAC5D,KAAK,CAACmD,WAAW,CAAC;MAC7C1B,SAAS,CAAC0B,WAAW,CAACS,IAAI,CAAC5D,KAAK,CAACmD,WAAW,CAAC;MAC7C3B,SAAS,CAACgC,cAAc,CAACC,QAAQ,EAAEC,KAAK,EAAEZ,MAAM,CAAC;MACjDrB,SAAS,CAAC+B,cAAc,CAACC,QAAQ,EAAEC,KAAK,EAAEZ,MAAM,CAAC;MACjD9C,KAAK,CAAC2D,OAAO,GAAG,IAAI;IACtB,CAAC;EACH;AAEF;AAEAhE,MAAM,CAACkE,SAAS,CAACC,OAAO,GAAG,IAAI;AAC/BnE,MAAM,CAACgB,WAAW,GAAG;EACnBiB,QAAQ,EAAE;IACR3B,KAAK,EAAE;MACLF,IAAI,EAAE,GAAG;MACTqC,KAAK,EAAE;IACT,CAAC;IACD5B,YAAY,EAAE;MACZT,IAAI,EAAE,GAAG;MACTqC,KAAK,EAAE;IACT,CAAC;IACD2B,cAAc,EAAE;MACdhE,IAAI,EAAE,GAAG;MACTqC,KAAK,EAAE;IACT,CAAC;IACD4B,cAAc,EAAE;MACdjE,IAAI,EAAE,GAAG;MACTqC,KAAK,EAAE;IACT,CAAC;IACD6B,WAAW,EAAE;MACXlE,IAAI,EAAE,GAAG;MACTqC,KAAK,EAAE;IACT,CAAC;IACD8B,WAAW,EAAE;MACXnE,IAAI,EAAE,GAAG;MACTqC,KAAK,EAAE;IACT,CAAC;IACDhB,aAAa,EAAE;MACbrB,IAAI,EAAE,IAAI;MACVqC,KAAK,EAAE;IACT,CAAC;IACDmB,MAAM,EAAE;MACNxD,IAAI,EAAE,IAAI;MACVqC,KAAK,EAAE,IAAI5C,OAAO;IACpB;EACF,CAAC;EACDsC,YAAY,EACZ;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EACFC,cAAc,EACd;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,SAASpC,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}