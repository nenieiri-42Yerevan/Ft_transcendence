{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\nconst _positionVector = /*@__PURE__*/new Vector3();\nconst _normalVector = /*@__PURE__*/new Vector3();\nconst _tangentVector = /*@__PURE__*/new Vector3();\nconst _tangentVector4 = /*@__PURE__*/new Vector4();\nconst _morphVector = /*@__PURE__*/new Vector3();\nconst _temp = /*@__PURE__*/new Vector3();\nconst _skinIndex = /*@__PURE__*/new Vector4();\nconst _skinWeight = /*@__PURE__*/new Vector4();\nconst _matrix = /*@__PURE__*/new Matrix4();\nconst _boneMatrix = /*@__PURE__*/new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n  const sameCount = attr1.count === attr2.count;\n  const sameNormalized = attr1.normalized === attr2.normalized;\n  const sameType = attr1.array.constructor === attr2.array.constructor;\n  const sameItemSize = attr1.itemSize === attr2.itemSize;\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone(attr) {\n  let countOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const cons = attr.array.constructor;\n  const normalized = attr.normalized;\n  const itemSize = attr.itemSize;\n  const count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents(attr, target) {\n  let targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (attr.isInterleavedBufferAttribute) {\n    const itemSize = attr.itemSize;\n    for (let i = 0, l = attr.count; i < l; i++) {\n      const io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    const array = target.array;\n    const cons = array.constructor;\n    const byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    const temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix(target, matrix, scale) {\n  const targetArray = target.elements;\n  const matrixArray = matrix.elements;\n  for (let i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform(mesh, index, target) {\n  const skeleton = mesh.skeleton;\n  const geometry = mesh.geometry;\n  const bones = skeleton.bones;\n  const boneInverses = skeleton.boneInverses;\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n  _matrix.elements.fill(0);\n  for (let i = 0; i < 4; i++) {\n    const weight = _skinWeight.getComponent(i);\n    if (weight !== 0) {\n      const boneIndex = _skinIndex.getComponent(i);\n      _boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n  target.transformDirection(_matrix);\n  return target;\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n  for (let j = 0, jl = morphData.length; j < jl; j++) {\n    const influence = morphInfluences[j];\n    const morphAttribute = morphData[j];\n    if (influence === 0) continue;\n    _temp.fromBufferAttribute(morphAttribute, i);\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n  target.add(_morphVector);\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries(geometries) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    useGroups: false,\n    updateIndex: false,\n    skipAttributes: []\n  };\n  let targetGeometry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BufferGeometry();\n  const isIndexed = geometries[0].index !== null;\n  const {\n    useGroups = false,\n    updateIndex = false,\n    skipAttributes = []\n  } = options;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const attributes = {};\n  let offset = 0;\n  targetGeometry.clearGroups();\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    }\n\n    // gather attributes, exit early if they're different\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n    if (useGroups) {\n      let count;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n  if (isIndexed) {\n    let forceUpdateIndex = false;\n    if (!targetGeometry.index) {\n      let indexCount = 0;\n      for (let i = 0; i < geometries.length; ++i) {\n        indexCount += geometries[i].index.count;\n      }\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpdateIndex = true;\n    }\n    if (updateIndex || forceUpdateIndex) {\n      const targetIndex = targetGeometry.index;\n      let targetOffset = 0;\n      let indexOffset = 0;\n      for (let i = 0; i < geometries.length; ++i) {\n        const geometry = geometries[i];\n        const index = geometry.index;\n        if (skipAttributes[i] !== true) {\n          for (let j = 0; j < index.count; ++j) {\n            targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n            targetOffset++;\n          }\n        }\n        indexOffset += geometry.attributes.position.count;\n      }\n    }\n  }\n\n  // merge attributes\n  for (const name in attributes) {\n    const attrList = attributes[name];\n    if (!(name in targetGeometry.attributes)) {\n      let count = 0;\n      for (const key in attrList) {\n        count += attrList[key].count;\n      }\n      targetGeometry.setAttribute(name, createAttributeClone(attributes[name][0], count));\n    }\n    const targetAttribute = targetGeometry.attributes[name];\n    let offset = 0;\n    for (let i = 0, l = attrList.length; i < l; i++) {\n      const attr = attrList[i];\n      if (skipAttributes[i] !== true) {\n        copyAttributeContents(attr, targetAttribute, offset);\n      }\n      offset += attr.count;\n    }\n  }\n  return targetGeometry;\n}\nfunction checkTypedArrayEquality(a, b) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n  constructor(mesh) {\n    this.matrixWorld = new Matrix4();\n    this.geometryHash = null;\n    this.boneMatrices = null;\n    this.primitiveCount = -1;\n    this.mesh = mesh;\n    this.update();\n  }\n  update() {\n    const mesh = this.mesh;\n    const geometry = mesh.geometry;\n    const skeleton = mesh.skeleton;\n    const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    this.matrixWorld.copy(mesh.matrixWorld);\n    this.geometryHash = geometry.attributes.position.version;\n    this.primitiveCount = primitiveCount;\n    if (skeleton) {\n      // ensure the bone matrix array is updated to the appropriate length\n      if (!skeleton.boneTexture) {\n        skeleton.computeBoneTexture();\n      }\n      skeleton.update();\n\n      // copy data if possible otherwise clone it\n      const boneMatrices = skeleton.boneMatrices;\n      if (!this.boneMatrices || this.boneMatrices.length !== boneMatrices.length) {\n        this.boneMatrices = boneMatrices.slice();\n      } else {\n        this.boneMatrices.set(boneMatrices);\n      }\n    } else {\n      this.boneMatrices = null;\n    }\n  }\n  didChange() {\n    const mesh = this.mesh;\n    const geometry = mesh.geometry;\n    const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === geometry.attributes.position.version && checkTypedArrayEquality(mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === primitiveCount;\n    return !identical;\n  }\n}\nexport class StaticGeometryGenerator {\n  constructor(meshes) {\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    const finalMeshes = [];\n    meshes.forEach(object => {\n      object.traverseVisible(c => {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'color', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(() => new BufferGeometry());\n    this._diffMap = new WeakMap();\n  }\n  getMaterials() {\n    const materials = [];\n    this.meshes.forEach(mesh => {\n      if (Array.isArray(mesh.material)) {\n        materials.push(...mesh.material);\n      } else {\n        materials.push(mesh.material);\n      }\n    });\n    return materials;\n  }\n  generate() {\n    let targetGeometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n    let skipAttributes = [];\n    const {\n      meshes,\n      useGroups,\n      _intermediateGeometry,\n      _diffMap\n    } = this;\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i];\n      const geom = _intermediateGeometry[i];\n      const diff = _diffMap.get(mesh);\n      if (!diff || diff.didChange(mesh)) {\n        this._convertToStaticGeometry(mesh, geom);\n        skipAttributes.push(false);\n        if (!diff) {\n          _diffMap.set(mesh, new GeometryDiff(mesh));\n        } else {\n          diff.update();\n        }\n      } else {\n        skipAttributes.push(true);\n      }\n    }\n    mergeBufferGeometries(_intermediateGeometry, {\n      useGroups,\n      skipAttributes\n    }, targetGeometry);\n    for (const key in targetGeometry.attributes) {\n      targetGeometry.attributes[key].needsUpdate = true;\n    }\n    return targetGeometry;\n  }\n  _convertToStaticGeometry(mesh) {\n    let targetGeometry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BufferGeometry();\n    const geometry = mesh.geometry;\n    const applyWorldTransforms = this.applyWorldTransforms;\n    const includeNormal = this.attributes.includes('normal');\n    const includeTangent = this.attributes.includes('tangent');\n    const attributes = geometry.attributes;\n    const targetAttributes = targetGeometry.attributes;\n\n    // initialize the attributes if they don't exist\n    if (!targetGeometry.index) {\n      targetGeometry.index = geometry.index;\n    }\n    if (!targetAttributes.position) {\n      targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n    }\n    if (includeNormal && !targetAttributes.normal && attributes.normal) {\n      targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n    }\n    if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n      targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n    }\n\n    // ensure the attributes are consistent\n    validateAttributes(geometry.index, targetGeometry.index);\n    validateAttributes(attributes.position, targetAttributes.position);\n    if (includeNormal) {\n      validateAttributes(attributes.normal, targetAttributes.normal);\n    }\n    if (includeTangent) {\n      validateAttributes(attributes.tangent, targetAttributes.tangent);\n    }\n\n    // generate transformed vertex attribute data\n    const position = attributes.position;\n    const normal = includeNormal ? attributes.normal : null;\n    const tangent = includeTangent ? attributes.tangent : null;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphNormal = geometry.morphAttributes.normal;\n    const morphTangent = geometry.morphAttributes.tangent;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const morphInfluences = mesh.morphTargetInfluences;\n    const normalMatrix = new Matrix3();\n    normalMatrix.getNormalMatrix(mesh.matrixWorld);\n    for (let i = 0, l = attributes.position.count; i < l; i++) {\n      _positionVector.fromBufferAttribute(position, i);\n      if (normal) {\n        _normalVector.fromBufferAttribute(normal, i);\n      }\n      if (tangent) {\n        _tangentVector4.fromBufferAttribute(tangent, i);\n        _tangentVector.fromBufferAttribute(tangent, i);\n      }\n\n      // apply morph target transform\n      if (morphInfluences) {\n        if (morphPosition) {\n          applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n        }\n        if (morphNormal) {\n          applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n        }\n        if (morphTangent) {\n          applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n        }\n      }\n\n      // apply bone transform\n      if (mesh.isSkinnedMesh) {\n        mesh.boneTransform(i, _positionVector);\n        if (normal) {\n          boneNormalTransform(mesh, i, _normalVector);\n        }\n        if (tangent) {\n          boneNormalTransform(mesh, i, _tangentVector);\n        }\n      }\n\n      // update the vectors of the attributes\n      if (applyWorldTransforms) {\n        _positionVector.applyMatrix4(mesh.matrixWorld);\n      }\n      targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n      if (normal) {\n        if (applyWorldTransforms) {\n          _normalVector.applyNormalMatrix(normalMatrix);\n        }\n        targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n      }\n      if (tangent) {\n        if (applyWorldTransforms) {\n          _tangentVector.transformDirection(mesh.matrixWorld);\n        }\n        targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n      }\n    }\n\n    // copy other attributes over\n    for (const i in this.attributes) {\n      const key = this.attributes[i];\n      if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n        continue;\n      }\n      if (!targetAttributes[key]) {\n        targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n      }\n      validateAttributes(attributes[key], targetAttributes[key]);\n      copyAttributeContents(attributes[key], targetAttributes[key]);\n    }\n    return targetGeometry;\n  }\n}","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Vector3","Vector4","Matrix4","Matrix3","_positionVector","_normalVector","_tangentVector","_tangentVector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","validateAttributes","attr1","attr2","sameCount","count","sameNormalized","normalized","sameType","array","constructor","sameItemSize","itemSize","Error","createAttributeClone","attr","countOverride","cons","copyAttributeContents","target","targetOffset","isInterleavedBufferAttribute","i","l","io","setX","getX","setY","getY","setZ","getZ","setW","getW","byteOffset","BYTES_PER_ELEMENT","temp","buffer","length","set","addScaledMatrix","matrix","scale","targetArray","elements","matrixArray","boneNormalTransform","mesh","index","skeleton","geometry","bones","boneInverses","fromBufferAttribute","attributes","skinIndex","skinWeight","fill","weight","getComponent","boneIndex","multiplyMatrices","matrixWorld","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","addScaledVector","sub","add","mergeBufferGeometries","geometries","options","useGroups","updateIndex","skipAttributes","targetGeometry","isIndexed","attributesUsed","Set","Object","keys","offset","clearGroups","attributesCount","name","has","undefined","push","size","position","addGroup","forceUpdateIndex","indexCount","setIndex","Uint32Array","targetIndex","indexOffset","attrList","key","setAttribute","targetAttribute","checkTypedArrayEquality","a","b","GeometryDiff","geometryHash","boneMatrices","primitiveCount","update","copy","version","boneTexture","computeBoneTexture","slice","didChange","identical","equals","StaticGeometryGenerator","meshes","Array","isArray","finalMeshes","forEach","object","traverseVisible","c","isMesh","applyWorldTransforms","_intermediateGeometry","map","_diffMap","WeakMap","getMaterials","materials","material","generate","geom","diff","get","_convertToStaticGeometry","needsUpdate","includeNormal","includes","includeTangent","targetAttributes","normal","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","getNormalMatrix","isSkinnedMesh","boneTransform","applyMatrix4","setXYZ","x","y","z","applyNormalMatrix","setXYZW","w"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index;\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.boneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}