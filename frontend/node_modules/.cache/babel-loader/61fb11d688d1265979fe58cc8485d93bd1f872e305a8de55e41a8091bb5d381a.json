{"ast":null,"code":"/**\n * Based on Nvidia Cg tutorial\n */\nconst FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2.0\n    },\n    mFresnelScale: {\n      value: 1.0\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\n};\nexport { FresnelShader };","map":{"version":3,"names":["FresnelShader","uniforms","mRefractionRatio","value","mFresnelBias","mFresnelPower","mFresnelScale","tCube","vertexShader","join","fragmentShader"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/shaders/FresnelShader.js"],"sourcesContent":["/**\n * Based on Nvidia Cg tutorial\n */\nconst FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2.0\n    },\n    mFresnelScale: {\n      value: 1.0\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\n};\n\nexport { FresnelShader };\n"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,aAAa,GAAG;EACpBC,QAAQ,EAAE;IACRC,gBAAgB,EAAE;MAChBC,KAAK,EAAE;IACT,CAAC;IACDC,YAAY,EAAE;MACZD,KAAK,EAAE;IACT,CAAC;IACDE,aAAa,EAAE;MACbF,KAAK,EAAE;IACT,CAAC;IACDG,aAAa,EAAE;MACbH,KAAK,EAAE;IACT,CAAC;IACDI,KAAK,EAAE;MACLJ,KAAK,EAAE;IACT;EACF,CAAC;EACDK,YAAY,EAAE,CAAC,iCAAiC,EAAE,6BAA6B,EAAE,8BAA8B,EAAE,8BAA8B,EAAE,wBAAwB,EAAE,2BAA2B,EAAE,kCAAkC,EAAE,eAAe,EAAE,6DAA6D,EAAE,4DAA4D,EAAE,+GAA+G,EAAE,+CAA+C,EAAE,wCAAwC,EAAE,0EAA0E,EAAE,iFAAiF,EAAE,iFAAiF,EAAE,qHAAqH,EAAE,+CAA+C,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAC/+BC,cAAc,EAAE,CAAC,4BAA4B,EAAE,wBAAwB,EAAE,2BAA2B,EAAE,kCAAkC,EAAE,eAAe,EAAE,gFAAgF,EAAE,qCAAqC,EAAE,qFAAqF,EAAE,qFAAqF,EAAE,qFAAqF,EAAE,8FAA8F,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;AACzoB,CAAC;AAED,SAAST,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}