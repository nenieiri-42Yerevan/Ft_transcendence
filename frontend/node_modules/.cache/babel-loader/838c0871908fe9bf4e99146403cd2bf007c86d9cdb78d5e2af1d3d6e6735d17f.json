{"ast":null,"code":"import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nvar SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new Color();\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\n};\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function () {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function (width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function (renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        format: RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n      height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625,\n        // 0.0625 = 1 / 16\n        width, height);\n      }\n      var sampleWeight = baseSampleWeight;\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n      this.fsQuad.render(renderer);\n    }\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { SSAARenderPass };","map":{"version":3,"names":["Color","UniformsUtils","ShaderMaterial","AdditiveBlending","WebGLRenderTarget","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","SSAARenderPass","scene","camera","clearColor","clearAlpha","sampleLevel","unbiased","undefined","_oldClearColor","console","error","copyShader","copyUniforms","clone","uniforms","copyMaterial","vertexShader","fragmentShader","premultipliedAlpha","transparent","blending","depthTest","depthWrite","fsQuad","prototype","Object","assign","create","constructor","dispose","sampleRenderTarget","setSize","width","height","render","renderer","writeBuffer","readBuffer","minFilter","magFilter","format","texture","name","jitterOffsets","JitterVectors","Math","max","min","autoClear","getClearColor","oldClearAlpha","getClearAlpha","baseSampleWeight","length","roundingRange","value","i","jitterOffset","setViewOffset","sampleWeight","uniformCenteredDistribution","setClearColor","setRenderTarget","clear","renderToScreen","clearViewOffset"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/postprocessing/SSAARenderPass.js"],"sourcesContent":["import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nvar SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new Color();\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\n};\n\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function () {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function (width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function (renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        format: RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n        width, height);\n      }\n\n      var sampleWeight = baseSampleWeight;\n\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n\n      this.fsQuad.render(renderer);\n    }\n\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\n\nexport { SSAARenderPass };\n"],"mappings":"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C,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAEhmB,SAAS5C,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}