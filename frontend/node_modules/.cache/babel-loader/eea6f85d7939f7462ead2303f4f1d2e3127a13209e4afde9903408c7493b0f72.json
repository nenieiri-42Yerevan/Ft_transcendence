{"ast":null,"code":"import { Vector3, Color, SphericalHarmonics3, LightProbe, LinearEncoding, sRGBEncoding } from 'three';\nvar LightProbeGenerator = {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  fromCubeTexture: function (cubeTexture) {\n    var norm,\n      lengthSq,\n      weight,\n      totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var image = cubeTexture.image[faceIndex];\n      var width = image.width;\n      var height = image.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      var imageData = context.getImageData(0, 0, width, height);\n      var data = imageData.data;\n      var imageWidth = imageData.width; // assumed to be square\n\n      var pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n          case 1:\n            coord.set(1, row, col);\n            break;\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n    norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  },\n  fromCubeRenderTarget: function (renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    var norm,\n      lengthSq,\n      weight,\n      totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\n\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      var pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n          case 1:\n            coord.set(-1, row, col);\n            break;\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n          case 3:\n            coord.set(col, -1, row);\n            break;\n          case 4:\n            coord.set(col, row, 1);\n            break;\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n    norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n};\nvar convertColorToLinear = function (color, encoding) {\n  switch (encoding) {\n    case sRGBEncoding:\n      color.convertSRGBToLinear();\n      break;\n    case LinearEncoding:\n      break;\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\n      break;\n  }\n  return color;\n};\nexport { LightProbeGenerator };","map":{"version":3,"names":["Vector3","Color","SphericalHarmonics3","LightProbe","LinearEncoding","sRGBEncoding","LightProbeGenerator","fromCubeTexture","cubeTexture","norm","lengthSq","weight","totalWeight","coord","dir","color","shBasis","sh","shCoefficients","coefficients","faceIndex","image","width","height","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","imageWidth","pixelSize","i","il","length","setRGB","convertColorToLinear","encoding","pixelIndex","col","row","Math","floor","set","sqrt","copy","normalize","getBasisAt","j","x","r","y","g","z","b","PI","fromCubeRenderTarget","renderer","cubeRenderTarget","Uint8Array","readRenderTargetPixels","texture","convertSRGBToLinear","console","warn"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/lights/LightProbeGenerator.js"],"sourcesContent":["import { Vector3, Color, SphericalHarmonics3, LightProbe, LinearEncoding, sRGBEncoding } from 'three';\n\nvar LightProbeGenerator = {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  fromCubeTexture: function (cubeTexture) {\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var image = cubeTexture.image[faceIndex];\n      var width = image.width;\n      var height = image.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      var imageData = context.getImageData(0, 0, width, height);\n      var data = imageData.data;\n      var imageWidth = imageData.width; // assumed to be square\n\n      var pixelSize = 2 / imageWidth;\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n\n          case 1:\n            coord.set(1, row, col);\n            break;\n\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  },\n  fromCubeRenderTarget: function (renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\n\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      var pixelSize = 2 / imageWidth;\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n\n          case 1:\n            coord.set(-1, row, col);\n            break;\n\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(col, -1, row);\n            break;\n\n          case 4:\n            coord.set(col, row, 1);\n            break;\n\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  }\n};\n\nvar convertColorToLinear = function (color, encoding) {\n  switch (encoding) {\n    case sRGBEncoding:\n      color.convertSRGBToLinear();\n      break;\n\n    case LinearEncoding:\n      break;\n\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\n      break;\n  }\n\n  return color;\n};\n\nexport { LightProbeGenerator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}