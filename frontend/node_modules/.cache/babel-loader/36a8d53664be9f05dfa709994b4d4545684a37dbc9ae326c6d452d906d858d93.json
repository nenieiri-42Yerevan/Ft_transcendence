{"ast":null,"code":"import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nvar ShadowMapViewer = function (light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function (width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function (x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n      if (doRenderLabel) {\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n      }\n    }\n  };\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n  this.update();\n};\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\nexport { ShadowMapViewer };","map":{"version":3,"names":["OrthographicCamera","Scene","UniformsUtils","ShaderMaterial","PlaneGeometry","Mesh","Texture","LinearFilter","MeshBasicMaterial","DoubleSide","UnpackDepthRGBAShader","ShadowMapViewer","light","scope","doRenderLabel","name","undefined","userAutoClearSetting","frame","x","y","width","height","camera","window","innerWidth","innerHeight","position","set","scene","shader","uniforms","clone","material","vertexShader","fragmentShader","plane","mesh","add","labelCanvas","labelMesh","document","createElement","context","getContext","font","labelWidth","measureText","fillStyle","fillText","labelTexture","magFilter","minFilter","needsUpdate","labelMaterial","map","side","transparent","labelPlane","resetPosition","enabled","size","scale","render","renderer","tDiffuse","value","shadow","texture","autoClear","clearDepth","updateForWindowResize","left","right","top","bottom","updateProjectionMatrix","update","prototype","constructor"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/utils/ShadowMapViewer.js"],"sourcesContent":["import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nvar ShadowMapViewer = function (light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function (width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function (x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n\n      if (doRenderLabel) {\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n      }\n    }\n  };\n\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n\n  this.update();\n};\n\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\n\nexport { ShadowMapViewer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}