{"ast":null,"code":"import { BufferGeometry, Vector3, Float32BufferAttribute } from 'three';\n\n/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nclass ParametricGeometry extends BufferGeometry {\n  constructor() {\n    let func = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v));\n    let slices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n    let stacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    super();\n    this.type = 'ParametricGeometry';\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    }; // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const EPS = 0.00001;\n    const normal = new Vector3();\n    const p0 = new Vector3(),\n      p1 = new Vector3();\n    const pu = new Vector3(),\n      pv = new Vector3(); // generate vertices, normals and uvs\n\n    const sliceCount = slices + 1;\n    for (let i = 0; i <= stacks; i++) {\n      const v = i / stacks;\n      for (let j = 0; j <= slices; j++) {\n        const u = j / slices; // vertex\n\n        func(u, v, p0);\n        vertices.push(p0.x, p0.y, p0.z); // normal\n        // approximate tangent vectors via finite differences\n\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1);\n          pu.subVectors(p0, p1);\n        } else {\n          func(u + EPS, v, p1);\n          pu.subVectors(p1, p0);\n        }\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1);\n          pv.subVectors(p0, p1);\n        } else {\n          func(u, v + EPS, p1);\n          pv.subVectors(p1, p0);\n        } // cross product of tangent vectors returns surface normal\n\n        normal.crossVectors(pu, pv).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u, v);\n      }\n    } // generate indices\n\n    for (let i = 0; i < stacks; i++) {\n      for (let j = 0; j < slices; j++) {\n        const a = i * sliceCount + j;\n        const b = i * sliceCount + j + 1;\n        const c = (i + 1) * sliceCount + j + 1;\n        const d = (i + 1) * sliceCount + j; // faces one and two\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n}\nexport { ParametricGeometry };","map":{"version":3,"names":["BufferGeometry","Vector3","Float32BufferAttribute","ParametricGeometry","constructor","func","u","v","target","set","Math","cos","sin","slices","stacks","type","parameters","indices","vertices","normals","uvs","EPS","normal","p0","p1","pu","pv","sliceCount","i","j","push","x","y","z","subVectors","crossVectors","normalize","a","b","c","d","setIndex","setAttribute"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/geometries/ParametricGeometry.js"],"sourcesContent":["import { BufferGeometry, Vector3, Float32BufferAttribute } from 'three';\n\n/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nclass ParametricGeometry extends BufferGeometry {\n  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {\n    super();\n    this.type = 'ParametricGeometry';\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    }; // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const EPS = 0.00001;\n    const normal = new Vector3();\n    const p0 = new Vector3(),\n          p1 = new Vector3();\n    const pu = new Vector3(),\n          pv = new Vector3(); // generate vertices, normals and uvs\n\n    const sliceCount = slices + 1;\n\n    for (let i = 0; i <= stacks; i++) {\n      const v = i / stacks;\n\n      for (let j = 0; j <= slices; j++) {\n        const u = j / slices; // vertex\n\n        func(u, v, p0);\n        vertices.push(p0.x, p0.y, p0.z); // normal\n        // approximate tangent vectors via finite differences\n\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1);\n          pu.subVectors(p0, p1);\n        } else {\n          func(u + EPS, v, p1);\n          pu.subVectors(p1, p0);\n        }\n\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1);\n          pv.subVectors(p0, p1);\n        } else {\n          func(u, v + EPS, p1);\n          pv.subVectors(p1, p0);\n        } // cross product of tangent vectors returns surface normal\n\n\n        normal.crossVectors(pu, pv).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u, v);\n      }\n    } // generate indices\n\n\n    for (let i = 0; i < stacks; i++) {\n      for (let j = 0; j < slices; j++) {\n        const a = i * sliceCount + j;\n        const b = i * sliceCount + j + 1;\n        const c = (i + 1) * sliceCount + j + 1;\n        const d = (i + 1) * sliceCount + j; // faces one and two\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n}\n\nexport { ParametricGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}