{"ast":null,"code":"import { Vector2, Matrix4 } from 'three';\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 0.005\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;',\n  // avoid artifacts caused by neighbour fragments with minimal depth difference\n  'uniform float maxDistance;',\n  // avoid the influence of fragments which are too far away\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;',\n  // compute matrix used to reorient a kernel vector\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];',\n  // reorient sample vector in view space\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );',\n  // calculate sample point\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );',\n  // project point and calculate NDC\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;',\n  // compute uv coordinates\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );',\n  // get linear depth from depth texture\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );',\n  // compute linear depth of the sample view Z value\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {',\n  // if fragment is before sample point, increase occlusion\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };","map":{"version":3,"names":["Vector2","Matrix4","SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","cameraProjectionMatrix","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/shaders/SSAOShader.js"],"sourcesContent":["import { Vector2, Matrix4 } from 'three';\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 0.005\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\n};\n\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,OAAO,QAAQ,OAAO;;AAExC;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,UAAU,GAAG;EACjBC,OAAO,EAAE;IACPC,kBAAkB,EAAE,CAAC;IACrBC,WAAW,EAAE;EACf,CAAC;EACDC,QAAQ,EAAE;IACRC,QAAQ,EAAE;MACRC,KAAK,EAAE;IACT,CAAC;IACDC,OAAO,EAAE;MACPD,KAAK,EAAE;IACT,CAAC;IACDE,MAAM,EAAE;MACNF,KAAK,EAAE;IACT,CAAC;IACDG,MAAM,EAAE;MACNH,KAAK,EAAE;IACT,CAAC;IACDI,MAAM,EAAE;MACNJ,KAAK,EAAE;IACT,CAAC;IACDK,UAAU,EAAE;MACVL,KAAK,EAAE;IACT,CAAC;IACDM,SAAS,EAAE;MACTN,KAAK,EAAE;IACT,CAAC;IACDO,UAAU,EAAE;MACVP,KAAK,EAAE,IAAIR,OAAO;IACpB,CAAC;IACDgB,sBAAsB,EAAE;MACtBR,KAAK,EAAE,IAAIP,OAAO;IACpB,CAAC;IACDgB,6BAA6B,EAAE;MAC7BT,KAAK,EAAE,IAAIP,OAAO;IACpB,CAAC;IACDiB,YAAY,EAAE;MACZV,KAAK,EAAE;IACT,CAAC;IACDW,WAAW,EAAE;MACXX,KAAK,EAAE;IACT,CAAC;IACDY,WAAW,EAAE;MACXZ,KAAK,EAAE;IACT;EACF,CAAC;EACDa,YAAY,EAAE,CAAC,mBAAmB,EAAE,eAAe,EAAE,YAAY,EAAE,4EAA4E,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAChKC,cAAc,EAAE,CAAC,6BAA6B,EAAE,4BAA4B,EAAE,2BAA2B,EAAE,2BAA2B,EAAE,qCAAqC,EAAE,0BAA0B,EAAE,2BAA2B,EAAE,0BAA0B,EAAE,sCAAsC,EAAE,6CAA6C,EAAE,6BAA6B,EAAE,4BAA4B;EAAE;EACxZ,4BAA4B;EAAE;EAC9B,mBAAmB,EAAE,oBAAoB,EAAE,kDAAkD,EAAE,gDAAgD,EAAE,GAAG,EAAE,wDAAwD,EAAE,8BAA8B,EAAE,6DAA6D,EAAE,+EAA+E,EAAE,oEAAoE,EAAE,QAAQ,EAAE,iDAAiD,EAAE,SAAS,EAAE,GAAG,EAAE,0CAA0C,EAAE,8BAA8B,EAAE,mEAAmE,EAAE,QAAQ,EAAE,oEAAoE,EAAE,SAAS,EAAE,GAAG,EAAE,oGAAoG,EAAE,qFAAqF,EAAE,kFAAkF,EAAE,0CAA0C,EAAE,+DAA+D,EAAE,GAAG,EAAE,sDAAsD,EAAE,wEAAwE,EAAE,GAAG,EAAE,eAAe,EAAE,iCAAiC,EAAE,mCAAmC,EAAE,4DAA4D,EAAE,0CAA0C,EAAE,oEAAoE,EAAE,2DAA2D;EAAE;EACplD,+EAA+E,EAAE,iDAAiD,EAAE,8DAA8D,EAAE,yBAAyB,EAAE,6CAA6C,EAAE,mDAAmD;EAAE;EACnU,sEAAsE;EAAE;EACxE,4EAA4E;EAAE;EAC9E,uCAAuC,EAAE,uDAAuD;EAAE;EAClG,sDAAsD;EAAE;EACxD,yFAAyF;EAAE;EAC3F,0CAA0C,EAAE,uDAAuD;EAAE;EACrG,sBAAsB,EAAE,KAAK,EAAE,IAAI,EAAE,mEAAmE,EAAE,uDAAuD,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;AACnL,CAAC;AACD,MAAME,eAAe,GAAG;EACtBrB,OAAO,EAAE;IACPC,kBAAkB,EAAE;EACtB,CAAC;EACDE,QAAQ,EAAE;IACRI,MAAM,EAAE;MACNF,KAAK,EAAE;IACT,CAAC;IACDK,UAAU,EAAE;MACVL,KAAK,EAAE;IACT,CAAC;IACDM,SAAS,EAAE;MACTN,KAAK,EAAE;IACT;EACF,CAAC;EACDa,YAAY,EAAE,CAAC,mBAAmB,EAAE,eAAe,EAAE,YAAY,EAAE,4EAA4E,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAChKC,cAAc,EAAE,CAAC,2BAA2B,EAAE,2BAA2B,EAAE,0BAA0B,EAAE,mBAAmB,EAAE,oBAAoB,EAAE,wDAAwD,EAAE,8BAA8B,EAAE,6DAA6D,EAAE,+EAA+E,EAAE,oEAAoE,EAAE,QAAQ,EAAE,iDAAiD,EAAE,SAAS,EAAE,GAAG,EAAE,eAAe,EAAE,uCAAuC,EAAE,mDAAmD,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;AAC9oB,CAAC;AACD,MAAMG,cAAc,GAAG;EACrBnB,QAAQ,EAAE;IACRC,QAAQ,EAAE;MACRC,KAAK,EAAE;IACT,CAAC;IACDO,UAAU,EAAE;MACVP,KAAK,EAAE,IAAIR,OAAO;IACpB;EACF,CAAC;EACDqB,YAAY,EAAE,CAAC,mBAAmB,EAAE,eAAe,EAAE,YAAY,EAAE,4EAA4E,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAChKC,cAAc,EAAE,CAAC,6BAA6B,EAAE,0BAA0B,EAAE,mBAAmB,EAAE,eAAe,EAAE,yCAAyC,EAAE,sBAAsB,EAAE,sCAAsC,EAAE,uCAAuC,EAAE,kEAAkE,EAAE,qDAAqD,EAAE,KAAK,EAAE,IAAI,EAAE,8DAA8D,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;AAC9d,CAAC;AAED,SAASG,cAAc,EAAED,eAAe,EAAEtB,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}