{"ast":null,"code":"import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from 'three';\nimport potpack from 'potpack';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\n\nclass ProgressiveLightMap {\n  constructor(renderer) {\n    let res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\n\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]; // If this object is a light, simply add it to the internal scene\n\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!');\n        continue;\n      }\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      } // Apply the lightmap to the object\n\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object: object\n      });\n      this.compiled = false;\n    } // Pack the objects' lightmap UVs into the same global space\n\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv2 = objects[box.index].geometry.getAttribute('uv').clone();\n      for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {\n        uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n        uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute('uv2', uv2);\n      objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n\n  update(camera) {\n    let blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (this.blurringPlane == null) {\n      return;\n    } // Store the original Render Target\n\n    const oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\n\n    this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    } // Render once normally to initialize everything\n\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    } // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    } // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    } // Restore the original Render Target\n\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n\n  showDebugLightmap(visible) {\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!');\n        this.warned = true;\n      }\n      return;\n    }\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position != undefined) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n\n  _initializeBlurPlane(res) {\n    let lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1.0 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0\n    };\n    blurMaterial.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`; // Set the LightMap Accumulation Buffer\n\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\n\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = 'Blurring Plane';\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n}\nexport { ProgressiveLightMap };","map":{"version":3,"names":["Scene","WebGLRenderTarget","FloatType","MeshPhongMaterial","MeshBasicMaterial","DoubleSide","PlaneGeometry","Mesh","potpack","ProgressiveLightMap","constructor","renderer","res","lightMapContainers","compiled","scene","background","tinyTarget","buffer1Active","firstUpdate","warned","format","test","navigator","userAgent","alfFloatType","progressiveLightMap1","type","progressiveLightMap2","uvMat","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","texture","averagingWindow","userData","addObjectsToLightMap","objects","uv_boxes","padding","ob","length","object","isLight","attach","geometry","hasAttribute","console","warn","blurringPlane","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","forEach","box","uv2","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","setRenderTarget","render","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","showDebugLightmap","position","undefined","labelMesh","labelMaterial","map","side","labelPlane","add","copy","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/misc/ProgressiveLightmap.js"],"sourcesContent":["import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from 'three';\nimport potpack from 'potpack';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\n\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\n\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n\n\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]; // If this object is a light, simply add it to the internal scene\n\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!');\n        continue;\n      }\n\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      } // Apply the lightmap to the object\n\n\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object: object\n      });\n      this.compiled = false;\n    } // Pack the objects' lightmap UVs into the same global space\n\n\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv2 = objects[box.index].geometry.getAttribute('uv').clone();\n\n      for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {\n        uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n        uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n\n      objects[box.index].geometry.setAttribute('uv2', uv2);\n      objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n\n\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    } // Store the original Render Target\n\n\n    const oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\n\n    this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    } // Render once normally to initialize everything\n\n\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    } // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    } // Ping-pong two surface buffers for reading/writing\n\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    } // Restore the original Render Target\n\n\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n\n\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!');\n        this.warned = true;\n      }\n\n      return;\n    }\n\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n\n    if (position != undefined) {\n      this.labelMesh.position.copy(position);\n    }\n\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n\n\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1.0 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0\n    };\n\n    blurMaterial.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`; // Set the LightMap Accumulation Buffer\n\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\n\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = 'Blurring Plane';\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n\n}\n\nexport { ProgressiveLightMap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}