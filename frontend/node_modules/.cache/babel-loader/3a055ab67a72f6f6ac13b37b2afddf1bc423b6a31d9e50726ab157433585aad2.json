{"ast":null,"code":"import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n    const groups = geometry.groups;\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n    this.computeFaceNormals();\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n  computeVertexNormals() {\n    let areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const vertices = new Array(this.vertices.length);\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n        ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n  merge(geometry, matrix) {\n    let materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors;\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n        faceCopy.vertexNormals.push(normal);\n      }\n      faceCopy.color.copy(face.color);\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n  mergeVertices() {\n    let precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n      changes = [];\n    const precision = Math.pow(10, precisionPoints);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n    const faceIndicesToRemove = [];\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n  setFromPoints(points) {\n    this.vertices = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n    return this;\n  }\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n      return data;\n    }\n    const vertices = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n    const colors = source.colors;\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n    const faces = source.faces;\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n    const morphTargets = source.morphTargets;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n    const morphNormals = source.morphNormals;\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n    const skinWeights = source.skinWeights;\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n    const skinIndices = source.skinIndices;\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n    const lineDistances = source.lineDistances;\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n    return buffergeometry;\n  }\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n}\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n  return buffergeometry;\n};\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color) {\n    let materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport { Face3, Geometry };","map":{"version":3,"names":["Matrix4","Object3D","Vector3","EventDispatcher","MathUtils","Matrix3","Color","Box3","Sphere","BufferGeometry","BufferAttribute","Float32BufferAttribute","Vector2","_m1","_obj","_offset","Geometry","constructor","isGeometry","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","applyMatrix4","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","toBufferGeometry","DirectGeometry","fromGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/deprecated/Geometry.js"],"sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,eAAe,EAAEC,SAAS,EAAEC,OAAO,EAAEC,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,cAAc,EAAEC,eAAe,EAAEC,sBAAsB,EAAEC,OAAO,QAAQ,OAAO;AAE9K,MAAMC,GAAG,GAAG,IAAIb,OAAO,EAAE;AAEzB,MAAMc,IAAI,GAAG,IAAIb,QAAQ,EAAE;AAE3B,MAAMc,OAAO,GAAG,IAAIb,OAAO,EAAE;AAE7B,MAAMc,QAAQ,SAASb,eAAe,CAAC;EACrCc,WAAW,GAAG;IACZ,KAAK,EAAE;IACP,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,IAAI,GAAGf,SAAS,CAACgB,YAAY,EAAE;IACpC,IAAI,CAACC,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,IAAI,GAAG,UAAU;IACtB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,CAAC,EAAE,CAAC;IACzB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,cAAc,GAAG,IAAI,CAAC,CAAC;;IAE5B,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,uBAAuB,GAAG,KAAK;IACpC,IAAI,CAACC,gBAAgB,GAAG,KAAK;EAC/B;EAEAC,YAAY,CAACC,MAAM,EAAE;IACnB,MAAMC,YAAY,GAAG,IAAItC,OAAO,EAAE,CAACuC,eAAe,CAACF,MAAM,CAAC;IAE1D,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvB,QAAQ,CAACwB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD,MAAMG,MAAM,GAAG,IAAI,CAACzB,QAAQ,CAACsB,CAAC,CAAC;MAC/BG,MAAM,CAACP,YAAY,CAACC,MAAM,CAAC;IAC7B;IAEA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACrB,KAAK,CAACsB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMI,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACoB,CAAC,CAAC;MAC1BI,IAAI,CAACC,MAAM,CAACC,YAAY,CAACR,YAAY,CAAC,CAACS,SAAS,EAAE;MAElD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGL,IAAI,CAACM,aAAa,CAACR,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC3DJ,IAAI,CAACM,aAAa,CAACF,CAAC,CAAC,CAACF,YAAY,CAACR,YAAY,CAAC,CAACS,SAAS,EAAE;MAC9D;IACF;IAEA,IAAI,IAAI,CAACpB,WAAW,KAAK,IAAI,EAAE;MAC7B,IAAI,CAACwB,kBAAkB,EAAE;IAC3B;IAEA,IAAI,IAAI,CAACvB,cAAc,KAAK,IAAI,EAAE;MAChC,IAAI,CAACwB,qBAAqB,EAAE;IAC9B;IAEA,IAAI,CAACtB,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACE,iBAAiB,GAAG,IAAI;IAC7B,OAAO,IAAI;EACb;EAEAqB,OAAO,CAACC,KAAK,EAAE;IACb;IACA9C,GAAG,CAAC+C,aAAa,CAACD,KAAK,CAAC;IAExB,IAAI,CAAClB,YAAY,CAAC5B,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EAEAgD,OAAO,CAACF,KAAK,EAAE;IACb;IACA9C,GAAG,CAACiD,aAAa,CAACH,KAAK,CAAC;IAExB,IAAI,CAAClB,YAAY,CAAC5B,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EAEAkD,OAAO,CAACJ,KAAK,EAAE;IACb;IACA9C,GAAG,CAACmD,aAAa,CAACL,KAAK,CAAC;IAExB,IAAI,CAAClB,YAAY,CAAC5B,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EAEAoD,SAAS,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACjB;IACAvD,GAAG,CAACwD,eAAe,CAACH,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IAE5B,IAAI,CAAC3B,YAAY,CAAC5B,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EAEAyD,KAAK,CAACJ,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACb;IACAvD,GAAG,CAAC0D,SAAS,CAACL,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IAEtB,IAAI,CAAC3B,YAAY,CAAC5B,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EAEA2D,MAAM,CAACC,MAAM,EAAE;IACb3D,IAAI,CAAC0D,MAAM,CAACC,MAAM,CAAC;IAEnB3D,IAAI,CAAC4D,YAAY,EAAE;IAEnB,IAAI,CAACjC,YAAY,CAAC3B,IAAI,CAAC4B,MAAM,CAAC;IAC9B,OAAO,IAAI;EACb;EAEAiC,kBAAkB,CAACC,QAAQ,EAAE;IAC3B,MAAMC,KAAK,GAAG,IAAI;IAClB,MAAMC,KAAK,GAAGF,QAAQ,CAACE,KAAK,KAAK,IAAI,GAAGF,QAAQ,CAACE,KAAK,GAAGC,SAAS;IAClE,MAAMC,UAAU,GAAGJ,QAAQ,CAACI,UAAU;IAEtC,IAAIA,UAAU,CAACC,QAAQ,KAAKF,SAAS,EAAE;MACrCG,OAAO,CAACC,KAAK,CAAC,kFAAkF,CAAC;MACjG,OAAO,IAAI;IACb;IAEA,MAAMF,QAAQ,GAAGD,UAAU,CAACC,QAAQ;IACpC,MAAM/B,MAAM,GAAG8B,UAAU,CAAC9B,MAAM;IAChC,MAAMkC,KAAK,GAAGJ,UAAU,CAACI,KAAK;IAC9B,MAAMC,EAAE,GAAGL,UAAU,CAACK,EAAE;IACxB,MAAMC,GAAG,GAAGN,UAAU,CAACM,GAAG;IAC1B,IAAIA,GAAG,KAAKP,SAAS,EAAE,IAAI,CAACrD,aAAa,CAAC,CAAC,CAAC,GAAG,EAAE;IAEjD,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAACM,KAAK,EAAE1C,CAAC,EAAE,EAAE;MACvCgC,KAAK,CAACtD,QAAQ,CAACiE,IAAI,CAAC,IAAItF,OAAO,EAAE,CAACuF,mBAAmB,CAACR,QAAQ,EAAEpC,CAAC,CAAC,CAAC;MAEnE,IAAIuC,KAAK,KAAKL,SAAS,EAAE;QACvBF,KAAK,CAACrD,MAAM,CAACgE,IAAI,CAAC,IAAIlF,KAAK,EAAE,CAACmF,mBAAmB,CAACL,KAAK,EAAEvC,CAAC,CAAC,CAAC;MAC9D;IACF;IAEA,SAAS6C,OAAO,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,aAAa,EAAE;MACvC,MAAMC,YAAY,GAAGX,KAAK,KAAKL,SAAS,GAAG,EAAE,GAAG,CAACF,KAAK,CAACrD,MAAM,CAACmE,CAAC,CAAC,CAACK,KAAK,EAAE,EAAEnB,KAAK,CAACrD,MAAM,CAACoE,CAAC,CAAC,CAACI,KAAK,EAAE,EAAEnB,KAAK,CAACrD,MAAM,CAACqE,CAAC,CAAC,CAACG,KAAK,EAAE,CAAC;MAC3H,MAAMzC,aAAa,GAAGL,MAAM,KAAK6B,SAAS,GAAG,EAAE,GAAG,CAAC,IAAI7E,OAAO,EAAE,CAACuF,mBAAmB,CAACvC,MAAM,EAAEyC,CAAC,CAAC,EAAE,IAAIzF,OAAO,EAAE,CAACuF,mBAAmB,CAACvC,MAAM,EAAE0C,CAAC,CAAC,EAAE,IAAI1F,OAAO,EAAE,CAACuF,mBAAmB,CAACvC,MAAM,EAAE2C,CAAC,CAAC,CAAC;MAC5L,MAAM5C,IAAI,GAAG,IAAIgD,KAAK,CAACN,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEtC,aAAa,EAAEwC,YAAY,EAAED,aAAa,CAAC;MAC3EjB,KAAK,CAACpD,KAAK,CAAC+D,IAAI,CAACvC,IAAI,CAAC;MAEtB,IAAIoC,EAAE,KAAKN,SAAS,EAAE;QACpBF,KAAK,CAACnD,aAAa,CAAC,CAAC,CAAC,CAAC8D,IAAI,CAAC,CAAC,IAAI5E,OAAO,EAAE,CAAC6E,mBAAmB,CAACJ,EAAE,EAAEM,CAAC,CAAC,EAAE,IAAI/E,OAAO,EAAE,CAAC6E,mBAAmB,CAACJ,EAAE,EAAEO,CAAC,CAAC,EAAE,IAAIhF,OAAO,EAAE,CAAC6E,mBAAmB,CAACJ,EAAE,EAAEQ,CAAC,CAAC,CAAC,CAAC;MAC7J;MAEA,IAAIP,GAAG,KAAKP,SAAS,EAAE;QACrBF,KAAK,CAACnD,aAAa,CAAC,CAAC,CAAC,CAAC8D,IAAI,CAAC,CAAC,IAAI5E,OAAO,EAAE,CAAC6E,mBAAmB,CAACH,GAAG,EAAEK,CAAC,CAAC,EAAE,IAAI/E,OAAO,EAAE,CAAC6E,mBAAmB,CAACH,GAAG,EAAEM,CAAC,CAAC,EAAE,IAAIhF,OAAO,EAAE,CAAC6E,mBAAmB,CAACH,GAAG,EAAEO,CAAC,CAAC,CAAC,CAAC;MAChK;IACF;IAEA,MAAMK,MAAM,GAAGtB,QAAQ,CAACsB,MAAM;IAE9B,IAAIA,MAAM,CAACnD,MAAM,GAAG,CAAC,EAAE;MACrB,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqD,MAAM,CAACnD,MAAM,EAAEF,CAAC,EAAE,EAAE;QACtC,MAAMsD,KAAK,GAAGD,MAAM,CAACrD,CAAC,CAAC;QACvB,MAAMuD,KAAK,GAAGD,KAAK,CAACC,KAAK;QACzB,MAAMb,KAAK,GAAGY,KAAK,CAACZ,KAAK;QAEzB,KAAK,IAAIlC,CAAC,GAAG+C,KAAK,EAAE9C,EAAE,GAAG8C,KAAK,GAAGb,KAAK,EAAElC,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAI,CAAC,EAAE;UACtD,IAAIyB,KAAK,KAAKC,SAAS,EAAE;YACvBW,OAAO,CAACZ,KAAK,CAACuB,IAAI,CAAChD,CAAC,CAAC,EAAEyB,KAAK,CAACuB,IAAI,CAAChD,CAAC,GAAG,CAAC,CAAC,EAAEyB,KAAK,CAACuB,IAAI,CAAChD,CAAC,GAAG,CAAC,CAAC,EAAE8C,KAAK,CAACL,aAAa,CAAC;UACnF,CAAC,MAAM;YACLJ,OAAO,CAACrC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE8C,KAAK,CAACL,aAAa,CAAC;UAC/C;QACF;MACF;IACF,CAAC,MAAM;MACL,IAAIhB,KAAK,KAAKC,SAAS,EAAE;QACvB,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,KAAK,CAACS,KAAK,EAAE1C,CAAC,IAAI,CAAC,EAAE;UACvC6C,OAAO,CAACZ,KAAK,CAACuB,IAAI,CAACxD,CAAC,CAAC,EAAEiC,KAAK,CAACuB,IAAI,CAACxD,CAAC,GAAG,CAAC,CAAC,EAAEiC,KAAK,CAACuB,IAAI,CAACxD,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D;MACF,CAAC,MAAM;QACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAACM,KAAK,EAAE1C,CAAC,IAAI,CAAC,EAAE;UAC1C6C,OAAO,CAAC7C,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;QAC1B;MACF;IACF;IAEA,IAAI,CAACyD,kBAAkB,EAAE;IAEzB,IAAI1B,QAAQ,CAAC5C,WAAW,KAAK,IAAI,EAAE;MACjC,IAAI,CAACA,WAAW,GAAG4C,QAAQ,CAAC5C,WAAW,CAACgE,KAAK,EAAE;IACjD;IAEA,IAAIpB,QAAQ,CAAC3C,cAAc,KAAK,IAAI,EAAE;MACpC,IAAI,CAACA,cAAc,GAAG2C,QAAQ,CAAC3C,cAAc,CAAC+D,KAAK,EAAE;IACvD;IAEA,OAAO,IAAI;EACb;EAEAO,MAAM,GAAG;IACP,IAAI,CAAC/C,kBAAkB,EAAE;IACzB,IAAI,CAACxB,WAAW,CAACwE,SAAS,CAACzF,OAAO,CAAC,CAAC0F,MAAM,EAAE;IAC5C,IAAI,CAACxC,SAAS,CAAClD,OAAO,CAACmD,CAAC,EAAEnD,OAAO,CAACoD,CAAC,EAAEpD,OAAO,CAACqD,CAAC,CAAC;IAC/C,OAAO,IAAI;EACb;EAEAhB,SAAS,GAAG;IACV,IAAI,CAACK,qBAAqB,EAAE;IAC5B,MAAM8C,MAAM,GAAG,IAAI,CAACtE,cAAc,CAACsE,MAAM;IACzC,MAAMG,MAAM,GAAG,IAAI,CAACzE,cAAc,CAACyE,MAAM;IACzC,MAAMC,CAAC,GAAGD,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,GAAGA,MAAM;IACzC,MAAMhE,MAAM,GAAG,IAAI1C,OAAO,EAAE;IAC5B0C,MAAM,CAACkE,GAAG,CAACD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAACA,CAAC,GAAGJ,MAAM,CAACrC,CAAC,EAAE,CAAC,EAAEyC,CAAC,EAAE,CAAC,EAAE,CAACA,CAAC,GAAGJ,MAAM,CAACpC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEwC,CAAC,EAAE,CAACA,CAAC,GAAGJ,MAAM,CAACnC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC9F,IAAI,CAAC3B,YAAY,CAACC,MAAM,CAAC;IACzB,OAAO,IAAI;EACb;EAEA4D,kBAAkB,GAAG;IACnB,MAAMO,EAAE,GAAG,IAAI3G,OAAO,EAAE;MAClB4G,EAAE,GAAG,IAAI5G,OAAO,EAAE;IAExB,KAAK,IAAI6G,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;MAC1B,MAAME,EAAE,GAAG,IAAI,CAAC1F,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC;MAChC,MAAMuB,EAAE,GAAG,IAAI,CAAC3F,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC;MAChC,MAAMuB,EAAE,GAAG,IAAI,CAAC5F,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC;MAChCgB,EAAE,CAACO,UAAU,CAACD,EAAE,EAAED,EAAE,CAAC;MACrBJ,EAAE,CAACM,UAAU,CAACH,EAAE,EAAEC,EAAE,CAAC;MACrBL,EAAE,CAACQ,KAAK,CAACP,EAAE,CAAC;MACZD,EAAE,CAACzD,SAAS,EAAE;MACdH,IAAI,CAACC,MAAM,CAACoE,IAAI,CAACT,EAAE,CAAC;IACtB;EACF;EAEAU,oBAAoB,GAAsB;IAAA,IAArBC,YAAY,uEAAG,IAAI;IACtC,MAAMjG,QAAQ,GAAG,IAAIkG,KAAK,CAAC,IAAI,CAAClG,QAAQ,CAACwB,MAAM,CAAC;IAEhD,KAAK,IAAI2E,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACpG,QAAQ,CAACwB,MAAM,EAAE2E,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtDnG,QAAQ,CAACmG,CAAC,CAAC,GAAG,IAAIxH,OAAO,EAAE;IAC7B;IAEA,IAAIsH,YAAY,EAAE;MAChB;MACA;MACA,MAAMX,EAAE,GAAG,IAAI3G,OAAO,EAAE;QAClB4G,EAAE,GAAG,IAAI5G,OAAO,EAAE;MAExB,KAAK,IAAI6G,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;QAC1B,MAAME,EAAE,GAAG,IAAI,CAAC1F,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC;QAChC,MAAMuB,EAAE,GAAG,IAAI,CAAC3F,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC;QAChC,MAAMuB,EAAE,GAAG,IAAI,CAAC5F,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC;QAChCgB,EAAE,CAACO,UAAU,CAACD,EAAE,EAAED,EAAE,CAAC;QACrBJ,EAAE,CAACM,UAAU,CAACH,EAAE,EAAEC,EAAE,CAAC;QACrBL,EAAE,CAACQ,KAAK,CAACP,EAAE,CAAC;QACZvF,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC,CAACiC,GAAG,CAACf,EAAE,CAAC;QACxBtF,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC,CAACgC,GAAG,CAACf,EAAE,CAAC;QACxBtF,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC,CAAC+B,GAAG,CAACf,EAAE,CAAC;MAC1B;IACF,CAAC,MAAM;MACL,IAAI,CAACP,kBAAkB,EAAE;MAEzB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;QAC1BxF,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC,CAACiC,GAAG,CAAC3E,IAAI,CAACC,MAAM,CAAC;QACjC3B,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC,CAACgC,GAAG,CAAC3E,IAAI,CAACC,MAAM,CAAC;QACjC3B,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC,CAAC+B,GAAG,CAAC3E,IAAI,CAACC,MAAM,CAAC;MACnC;IACF;IAEA,KAAK,IAAIwE,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACpG,QAAQ,CAACwB,MAAM,EAAE2E,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtDnG,QAAQ,CAACmG,CAAC,CAAC,CAACtE,SAAS,EAAE;IACzB;IAEA,KAAK,IAAI2D,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;MAC1B,MAAMxD,aAAa,GAAGN,IAAI,CAACM,aAAa;MAExC,IAAIA,aAAa,CAACR,MAAM,KAAK,CAAC,EAAE;QAC9BQ,aAAa,CAAC,CAAC,CAAC,CAAC+D,IAAI,CAAC/F,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC,CAAC;QACvCpC,aAAa,CAAC,CAAC,CAAC,CAAC+D,IAAI,CAAC/F,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC,CAAC;QACvCrC,aAAa,CAAC,CAAC,CAAC,CAAC+D,IAAI,CAAC/F,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC,CAAC;MACzC,CAAC,MAAM;QACLtC,aAAa,CAAC,CAAC,CAAC,GAAGhC,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC,CAACK,KAAK,EAAE;QAC3CzC,aAAa,CAAC,CAAC,CAAC,GAAGhC,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC,CAACI,KAAK,EAAE;QAC3CzC,aAAa,CAAC,CAAC,CAAC,GAAGhC,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC,CAACG,KAAK,EAAE;MAC7C;IACF;IAEA,IAAI,IAAI,CAACvE,KAAK,CAACsB,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAACV,iBAAiB,GAAG,IAAI;IAC/B;EACF;EAEAwF,wBAAwB,GAAG;IACzB,IAAI,CAACvB,kBAAkB,EAAE;IAEzB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;MAC1B,MAAMxD,aAAa,GAAGN,IAAI,CAACM,aAAa;MAExC,IAAIA,aAAa,CAACR,MAAM,KAAK,CAAC,EAAE;QAC9BQ,aAAa,CAAC,CAAC,CAAC,CAAC+D,IAAI,CAACrE,IAAI,CAACC,MAAM,CAAC;QAClCK,aAAa,CAAC,CAAC,CAAC,CAAC+D,IAAI,CAACrE,IAAI,CAACC,MAAM,CAAC;QAClCK,aAAa,CAAC,CAAC,CAAC,CAAC+D,IAAI,CAACrE,IAAI,CAACC,MAAM,CAAC;MACpC,CAAC,MAAM;QACLK,aAAa,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACC,MAAM,CAAC8C,KAAK,EAAE;QACtCzC,aAAa,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACC,MAAM,CAAC8C,KAAK,EAAE;QACtCzC,aAAa,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACC,MAAM,CAAC8C,KAAK,EAAE;MACxC;IACF;IAEA,IAAI,IAAI,CAACvE,KAAK,CAACsB,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAACV,iBAAiB,GAAG,IAAI;IAC/B;EACF;EAEAyF,mBAAmB,GAAG;IACpB;IACA;IACA;IACA,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;MAE1B,IAAI,CAAC9D,IAAI,CAAC8E,oBAAoB,EAAE;QAC9B9E,IAAI,CAAC8E,oBAAoB,GAAG9E,IAAI,CAACC,MAAM,CAAC8C,KAAK,EAAE;MACjD,CAAC,MAAM;QACL/C,IAAI,CAAC8E,oBAAoB,CAACT,IAAI,CAACrE,IAAI,CAACC,MAAM,CAAC;MAC7C;MAEA,IAAI,CAACD,IAAI,CAAC+E,uBAAuB,EAAE/E,IAAI,CAAC+E,uBAAuB,GAAG,EAAE;MAEpE,KAAK,IAAInF,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGG,IAAI,CAACM,aAAa,CAACR,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC3D,IAAI,CAACI,IAAI,CAAC+E,uBAAuB,CAACnF,CAAC,CAAC,EAAE;UACpCI,IAAI,CAAC+E,uBAAuB,CAACnF,CAAC,CAAC,GAAGI,IAAI,CAACM,aAAa,CAACV,CAAC,CAAC,CAACmD,KAAK,EAAE;QACjE,CAAC,MAAM;UACL/C,IAAI,CAAC+E,uBAAuB,CAACnF,CAAC,CAAC,CAACyE,IAAI,CAACrE,IAAI,CAACM,aAAa,CAACV,CAAC,CAAC,CAAC;QAC7D;MACF;IACF,CAAC,CAAC;;IAGF,MAAMoF,MAAM,GAAG,IAAIjH,QAAQ,EAAE;IAC7BiH,MAAM,CAACxG,KAAK,GAAG,IAAI,CAACA,KAAK;IAEzB,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACnB,YAAY,CAACoB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC1D;MACA,IAAI,CAAC,IAAI,CAACjB,YAAY,CAACiB,CAAC,CAAC,EAAE;QACzB,IAAI,CAACjB,YAAY,CAACiB,CAAC,CAAC,GAAG,CAAC,CAAC;QACzB,IAAI,CAACjB,YAAY,CAACiB,CAAC,CAAC,CAACqF,WAAW,GAAG,EAAE;QACrC,IAAI,CAACtG,YAAY,CAACiB,CAAC,CAAC,CAACU,aAAa,GAAG,EAAE;QACvC,MAAM4E,cAAc,GAAG,IAAI,CAACvG,YAAY,CAACiB,CAAC,CAAC,CAACqF,WAAW;QACvD,MAAME,gBAAgB,GAAG,IAAI,CAACxG,YAAY,CAACiB,CAAC,CAAC,CAACU,aAAa;QAE3D,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACnD,MAAMsB,UAAU,GAAG,IAAInI,OAAO,EAAE;UAChC,MAAMqD,aAAa,GAAG;YACpBoC,CAAC,EAAE,IAAIzF,OAAO,EAAE;YAChB0F,CAAC,EAAE,IAAI1F,OAAO,EAAE;YAChB2F,CAAC,EAAE,IAAI3F,OAAO;UAChB,CAAC;UACDiI,cAAc,CAAC3C,IAAI,CAAC6C,UAAU,CAAC;UAC/BD,gBAAgB,CAAC5C,IAAI,CAACjC,aAAa,CAAC;QACtC;MACF;MAEA,MAAM3B,YAAY,GAAG,IAAI,CAACA,YAAY,CAACiB,CAAC,CAAC,CAAC,CAAC;;MAE3CoF,MAAM,CAAC1G,QAAQ,GAAG,IAAI,CAACI,YAAY,CAACkB,CAAC,CAAC,CAACtB,QAAQ,CAAC,CAAC;;MAEjD0G,MAAM,CAAC3B,kBAAkB,EAAE;MAC3B2B,MAAM,CAACV,oBAAoB,EAAE,CAAC,CAAC;;MAE/B,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;QAC1B,MAAMsB,UAAU,GAAGzG,YAAY,CAACsG,WAAW,CAACnB,CAAC,CAAC;QAC9C,MAAMxD,aAAa,GAAG3B,YAAY,CAAC2B,aAAa,CAACwD,CAAC,CAAC;QACnDsB,UAAU,CAACf,IAAI,CAACrE,IAAI,CAACC,MAAM,CAAC;QAC5BK,aAAa,CAACoC,CAAC,CAAC2B,IAAI,CAACrE,IAAI,CAACM,aAAa,CAAC,CAAC,CAAC,CAAC;QAC3CA,aAAa,CAACqC,CAAC,CAAC0B,IAAI,CAACrE,IAAI,CAACM,aAAa,CAAC,CAAC,CAAC,CAAC;QAC3CA,aAAa,CAACsC,CAAC,CAACyB,IAAI,CAACrE,IAAI,CAACM,aAAa,CAAC,CAAC,CAAC,CAAC;MAC7C;IACF,CAAC,CAAC;;IAGF,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvF,KAAK,CAACsB,MAAM,EAAEgE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM9D,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsF,CAAC,CAAC;MAC1B9D,IAAI,CAACC,MAAM,GAAGD,IAAI,CAAC8E,oBAAoB;MACvC9E,IAAI,CAACM,aAAa,GAAGN,IAAI,CAAC+E,uBAAuB;IACnD;EACF;EAEAxE,kBAAkB,GAAG;IACnB,IAAI,IAAI,CAACxB,WAAW,KAAK,IAAI,EAAE;MAC7B,IAAI,CAACA,WAAW,GAAG,IAAIzB,IAAI,EAAE;IAC/B;IAEA,IAAI,CAACyB,WAAW,CAACsG,aAAa,CAAC,IAAI,CAAC/G,QAAQ,CAAC;EAC/C;EAEAkC,qBAAqB,GAAG;IACtB,IAAI,IAAI,CAACxB,cAAc,KAAK,IAAI,EAAE;MAChC,IAAI,CAACA,cAAc,GAAG,IAAIzB,MAAM,EAAE;IACpC;IAEA,IAAI,CAACyB,cAAc,CAACqG,aAAa,CAAC,IAAI,CAAC/G,QAAQ,CAAC;EAClD;EAEAgH,KAAK,CAAC3D,QAAQ,EAAElC,MAAM,EAA2B;IAAA,IAAzB8F,mBAAmB,uEAAG,CAAC;IAC7C,IAAI,EAAE5D,QAAQ,IAAIA,QAAQ,CAAC1D,UAAU,CAAC,EAAE;MACtCgE,OAAO,CAACC,KAAK,CAAC,qEAAqE,EAAEP,QAAQ,CAAC;MAC9F;IACF;IAEA,IAAIjC,YAAY;IAChB,MAAM8F,YAAY,GAAG,IAAI,CAAClH,QAAQ,CAACwB,MAAM;MACnC2F,SAAS,GAAG,IAAI,CAACnH,QAAQ;MACzBoH,SAAS,GAAG/D,QAAQ,CAACrD,QAAQ;MAC7BqH,MAAM,GAAG,IAAI,CAACnH,KAAK;MACnBoH,MAAM,GAAGjE,QAAQ,CAACnD,KAAK;MACvBqH,OAAO,GAAG,IAAI,CAACtH,MAAM;MACrBuH,OAAO,GAAGnE,QAAQ,CAACpD,MAAM;IAE/B,IAAIkB,MAAM,KAAKqC,SAAS,EAAE;MACxBpC,YAAY,GAAG,IAAItC,OAAO,EAAE,CAACuC,eAAe,CAACF,MAAM,CAAC;IACtD,CAAC,CAAC;;IAGF,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG6F,SAAS,CAAC5F,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAClD,MAAMG,MAAM,GAAG2F,SAAS,CAAC9F,CAAC,CAAC;MAC3B,MAAMmG,UAAU,GAAGhG,MAAM,CAACgD,KAAK,EAAE;MACjC,IAAItD,MAAM,KAAKqC,SAAS,EAAEiE,UAAU,CAACvG,YAAY,CAACC,MAAM,CAAC;MACzDgG,SAAS,CAAClD,IAAI,CAACwD,UAAU,CAAC;IAC5B,CAAC,CAAC;;IAGF,KAAK,IAAInG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGiG,OAAO,CAAChG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAChDiG,OAAO,CAACtD,IAAI,CAACuD,OAAO,CAAClG,CAAC,CAAC,CAACmD,KAAK,EAAE,CAAC;IAClC,CAAC,CAAC;;IAGF,KAAK,IAAInD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG+F,MAAM,CAAC9F,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC/C,MAAMI,IAAI,GAAG4F,MAAM,CAAChG,CAAC,CAAC;MACtB,IAAIK,MAAM,EAAEkC,KAAK;MACjB,MAAM6D,iBAAiB,GAAGhG,IAAI,CAACM,aAAa;QACtC2F,gBAAgB,GAAGjG,IAAI,CAAC8C,YAAY;MAC1C,MAAMoD,QAAQ,GAAG,IAAIlD,KAAK,CAAChD,IAAI,CAAC0C,CAAC,GAAG8C,YAAY,EAAExF,IAAI,CAAC2C,CAAC,GAAG6C,YAAY,EAAExF,IAAI,CAAC4C,CAAC,GAAG4C,YAAY,CAAC;MAC/FU,QAAQ,CAACjG,MAAM,CAACoE,IAAI,CAACrE,IAAI,CAACC,MAAM,CAAC;MAEjC,IAAIP,YAAY,KAAKoC,SAAS,EAAE;QAC9BoE,QAAQ,CAACjG,MAAM,CAACC,YAAY,CAACR,YAAY,CAAC,CAACS,SAAS,EAAE;MACxD;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG2F,iBAAiB,CAAClG,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC1DH,MAAM,GAAG+F,iBAAiB,CAAC5F,CAAC,CAAC,CAAC2C,KAAK,EAAE;QAErC,IAAIrD,YAAY,KAAKoC,SAAS,EAAE;UAC9B7B,MAAM,CAACC,YAAY,CAACR,YAAY,CAAC,CAACS,SAAS,EAAE;QAC/C;QAEA+F,QAAQ,CAAC5F,aAAa,CAACiC,IAAI,CAACtC,MAAM,CAAC;MACrC;MAEAiG,QAAQ,CAAC/D,KAAK,CAACkC,IAAI,CAACrE,IAAI,CAACmC,KAAK,CAAC;MAE/B,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG4F,gBAAgB,CAACnG,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACzD+B,KAAK,GAAG8D,gBAAgB,CAAC7F,CAAC,CAAC;QAC3B8F,QAAQ,CAACpD,YAAY,CAACP,IAAI,CAACJ,KAAK,CAACY,KAAK,EAAE,CAAC;MAC3C;MAEAmD,QAAQ,CAACrD,aAAa,GAAG7C,IAAI,CAAC6C,aAAa,GAAG0C,mBAAmB;MACjEI,MAAM,CAACpD,IAAI,CAAC2D,QAAQ,CAAC;IACvB,CAAC,CAAC;;IAGF,KAAK,IAAItG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG8B,QAAQ,CAAClD,aAAa,CAACqB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC/D,MAAMuG,cAAc,GAAGxE,QAAQ,CAAClD,aAAa,CAACmB,CAAC,CAAC;MAChD,IAAI,IAAI,CAACnB,aAAa,CAACmB,CAAC,CAAC,KAAKkC,SAAS,EAAE,IAAI,CAACrD,aAAa,CAACmB,CAAC,CAAC,GAAG,EAAE;MAEnE,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG8F,cAAc,CAACrG,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACvD,MAAMgG,IAAI,GAAGD,cAAc,CAAC/F,CAAC,CAAC;UACxBiG,OAAO,GAAG,EAAE;QAElB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACtG,MAAM,EAAEwG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UAC7CD,OAAO,CAAC9D,IAAI,CAAC6D,IAAI,CAACE,CAAC,CAAC,CAACvD,KAAK,EAAE,CAAC;QAC/B;QAEA,IAAI,CAACtE,aAAa,CAACmB,CAAC,CAAC,CAAC2C,IAAI,CAAC8D,OAAO,CAAC;MACrC;IACF;EACF;EAEAG,SAAS,CAACC,IAAI,EAAE;IACd,IAAI,EAAEA,IAAI,IAAIA,IAAI,CAACC,MAAM,CAAC,EAAE;MAC1BzE,OAAO,CAACC,KAAK,CAAC,iEAAiE,EAAEuE,IAAI,CAAC;MACtF;IACF;IAEA,IAAIA,IAAI,CAACE,gBAAgB,EAAEF,IAAI,CAAChF,YAAY,EAAE;IAC9C,IAAI,CAAC6D,KAAK,CAACmB,IAAI,CAAC9E,QAAQ,EAAE8E,IAAI,CAAChH,MAAM,CAAC;EACxC;EACA;AACF;AACA;AACA;AACA;;EAGEmH,aAAa,GAAsB;IAAA,IAArBC,eAAe,uEAAG,CAAC;IAC/B,MAAMC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;;IAExB,MAAMC,MAAM,GAAG,EAAE;MACXC,OAAO,GAAG,EAAE;IAClB,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,EAAE,EAAEN,eAAe,CAAC;IAE/C,KAAK,IAAIjH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACvB,QAAQ,CAACwB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD,MAAM6E,CAAC,GAAG,IAAI,CAACnG,QAAQ,CAACsB,CAAC,CAAC;MAC1B,MAAMwH,GAAG,GAAI,GAAEF,IAAI,CAACG,KAAK,CAAC5C,CAAC,CAACxD,CAAC,GAAGgG,SAAS,CAAE,IAAGC,IAAI,CAACG,KAAK,CAAC5C,CAAC,CAACvD,CAAC,GAAG+F,SAAS,CAAE,IAAGC,IAAI,CAACG,KAAK,CAAC5C,CAAC,CAACtD,CAAC,GAAG8F,SAAS,CAAE,EAAC;MAE1G,IAAIH,WAAW,CAACM,GAAG,CAAC,KAAKtF,SAAS,EAAE;QAClCgF,WAAW,CAACM,GAAG,CAAC,GAAGxH,CAAC;QACpBmH,MAAM,CAACxE,IAAI,CAAC,IAAI,CAACjE,QAAQ,CAACsB,CAAC,CAAC,CAAC;QAC7BoH,OAAO,CAACpH,CAAC,CAAC,GAAGmH,MAAM,CAACjH,MAAM,GAAG,CAAC;MAChC,CAAC,MAAM;QACL;QACAkH,OAAO,CAACpH,CAAC,CAAC,GAAGoH,OAAO,CAACF,WAAW,CAACM,GAAG,CAAC,CAAC;MACxC;IACF,CAAC,CAAC;IACF;;IAGA,MAAME,mBAAmB,GAAG,EAAE;IAE9B,KAAK,IAAI1H,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACrB,KAAK,CAACsB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMI,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACoB,CAAC,CAAC;MAC1BI,IAAI,CAAC0C,CAAC,GAAGsE,OAAO,CAAChH,IAAI,CAAC0C,CAAC,CAAC;MACxB1C,IAAI,CAAC2C,CAAC,GAAGqE,OAAO,CAAChH,IAAI,CAAC2C,CAAC,CAAC;MACxB3C,IAAI,CAAC4C,CAAC,GAAGoE,OAAO,CAAChH,IAAI,CAAC4C,CAAC,CAAC;MACxB,MAAM2E,OAAO,GAAG,CAACvH,IAAI,CAAC0C,CAAC,EAAE1C,IAAI,CAAC2C,CAAC,EAAE3C,IAAI,CAAC4C,CAAC,CAAC,CAAC,CAAC;MAC1C;;MAEA,KAAK,IAAI4E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,IAAID,OAAO,CAACC,CAAC,CAAC,KAAKD,OAAO,CAAC,CAACC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;UACvCF,mBAAmB,CAAC/E,IAAI,CAAC3C,CAAC,CAAC;UAC3B;QACF;MACF;IACF;IAEA,KAAK,IAAIA,CAAC,GAAG0H,mBAAmB,CAACxH,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxD,MAAM6H,GAAG,GAAGH,mBAAmB,CAAC1H,CAAC,CAAC;MAClC,IAAI,CAACpB,KAAK,CAACkJ,MAAM,CAACD,GAAG,EAAE,CAAC,CAAC;MAEzB,KAAK,IAAIrH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAC5B,aAAa,CAACqB,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC3D,IAAI,CAAC3B,aAAa,CAAC2B,CAAC,CAAC,CAACsH,MAAM,CAACD,GAAG,EAAE,CAAC,CAAC;MACtC;IACF,CAAC,CAAC;;IAGF,MAAME,IAAI,GAAG,IAAI,CAACrJ,QAAQ,CAACwB,MAAM,GAAGiH,MAAM,CAACjH,MAAM;IACjD,IAAI,CAACxB,QAAQ,GAAGyI,MAAM;IACtB,OAAOY,IAAI;EACb;EAEAtC,aAAa,CAACuC,MAAM,EAAE;IACpB,IAAI,CAACtJ,QAAQ,GAAG,EAAE;IAElB,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEiI,CAAC,GAAGD,MAAM,CAAC9H,MAAM,EAAEF,CAAC,GAAGiI,CAAC,EAAEjI,CAAC,EAAE,EAAE;MAC7C,MAAMkI,KAAK,GAAGF,MAAM,CAAChI,CAAC,CAAC;MACvB,IAAI,CAACtB,QAAQ,CAACiE,IAAI,CAAC,IAAItF,OAAO,CAAC6K,KAAK,CAAC7G,CAAC,EAAE6G,KAAK,CAAC5G,CAAC,EAAE4G,KAAK,CAAC3G,CAAC,IAAI,CAAC,CAAC,CAAC;IACjE;IAEA,OAAO,IAAI;EACb;EAEA4G,wBAAwB,GAAG;IACzB,MAAMvJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMsB,MAAM,GAAGtB,KAAK,CAACsB,MAAM,CAAC,CAAC;;IAE7B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC/BpB,KAAK,CAACoB,CAAC,CAAC,CAACoI,GAAG,GAAGpI,CAAC;IAClB,CAAC,CAAC;;IAGF,SAASqI,iBAAiB,CAACvF,CAAC,EAAEC,CAAC,EAAE;MAC/B,OAAOD,CAAC,CAACG,aAAa,GAAGF,CAAC,CAACE,aAAa;IAC1C;IAEArE,KAAK,CAAC0J,IAAI,CAACD,iBAAiB,CAAC,CAAC,CAAC;;IAE/B,MAAME,IAAI,GAAG,IAAI,CAAC1J,aAAa,CAAC,CAAC,CAAC;IAClC,MAAM2H,IAAI,GAAG,IAAI,CAAC3H,aAAa,CAAC,CAAC,CAAC;IAClC,IAAI2J,OAAO,EAAEC,OAAO;IACpB,IAAIF,IAAI,IAAIA,IAAI,CAACrI,MAAM,KAAKA,MAAM,EAAEsI,OAAO,GAAG,EAAE;IAChD,IAAIhC,IAAI,IAAIA,IAAI,CAACtG,MAAM,KAAKA,MAAM,EAAEuI,OAAO,GAAG,EAAE;IAEhD,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC/B,MAAM0I,EAAE,GAAG9J,KAAK,CAACoB,CAAC,CAAC,CAACoI,GAAG;MACvB,IAAII,OAAO,EAAEA,OAAO,CAAC7F,IAAI,CAAC4F,IAAI,CAACG,EAAE,CAAC,CAAC;MACnC,IAAID,OAAO,EAAEA,OAAO,CAAC9F,IAAI,CAAC6D,IAAI,CAACkC,EAAE,CAAC,CAAC;IACrC;IAEA,IAAIF,OAAO,EAAE,IAAI,CAAC3J,aAAa,CAAC,CAAC,CAAC,GAAG2J,OAAO;IAC5C,IAAIC,OAAO,EAAE,IAAI,CAAC5J,aAAa,CAAC,CAAC,CAAC,GAAG4J,OAAO;EAC9C;EAEAE,MAAM,GAAG;IACP,MAAMC,IAAI,GAAG;MACXC,QAAQ,EAAE;QACRC,OAAO,EAAE,GAAG;QACZrK,IAAI,EAAE,UAAU;QAChBsK,SAAS,EAAE;MACb;IACF,CAAC,CAAC,CAAC;;IAEHH,IAAI,CAACtK,IAAI,GAAG,IAAI,CAACA,IAAI;IACrBsK,IAAI,CAACnK,IAAI,GAAG,IAAI,CAACA,IAAI;IACrB,IAAI,IAAI,CAACD,IAAI,KAAK,EAAE,EAAEoK,IAAI,CAACpK,IAAI,GAAG,IAAI,CAACA,IAAI;IAE3C,IAAI,IAAI,CAACwK,UAAU,KAAK9G,SAAS,EAAE;MACjC,MAAM8G,UAAU,GAAG,IAAI,CAACA,UAAU;MAElC,KAAK,IAAIxB,GAAG,IAAIwB,UAAU,EAAE;QAC1B,IAAIA,UAAU,CAACxB,GAAG,CAAC,KAAKtF,SAAS,EAAE0G,IAAI,CAACpB,GAAG,CAAC,GAAGwB,UAAU,CAACxB,GAAG,CAAC;MAChE;MAEA,OAAOoB,IAAI;IACb;IAEA,MAAMlK,QAAQ,GAAG,EAAE;IAEnB,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,QAAQ,CAACwB,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC7C,MAAMG,MAAM,GAAG,IAAI,CAACzB,QAAQ,CAACsB,CAAC,CAAC;MAC/BtB,QAAQ,CAACiE,IAAI,CAACxC,MAAM,CAACkB,CAAC,EAAElB,MAAM,CAACmB,CAAC,EAAEnB,MAAM,CAACoB,CAAC,CAAC;IAC7C;IAEA,MAAM3C,KAAK,GAAG,EAAE;IAChB,MAAMqK,OAAO,GAAG,EAAE;IAClB,MAAMC,WAAW,GAAG,CAAC,CAAC;IACtB,MAAMvK,MAAM,GAAG,EAAE;IACjB,MAAMwK,UAAU,GAAG,CAAC,CAAC;IACrB,MAAMC,GAAG,GAAG,EAAE;IACd,MAAMC,OAAO,GAAG,CAAC,CAAC;IAElB,KAAK,IAAIrJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpB,KAAK,CAACsB,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC1C,MAAMI,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACoB,CAAC,CAAC;MAC1B,MAAMsJ,WAAW,GAAG,IAAI;MACxB,MAAMC,SAAS,GAAG,KAAK,CAAC,CAAC;;MAEzB,MAAMC,eAAe,GAAG,IAAI,CAAC3K,aAAa,CAAC,CAAC,CAAC,CAACmB,CAAC,CAAC,KAAKkC,SAAS;MAC9D,MAAMuH,aAAa,GAAGrJ,IAAI,CAACC,MAAM,CAACH,MAAM,EAAE,GAAG,CAAC;MAC9C,MAAMwJ,mBAAmB,GAAGtJ,IAAI,CAACM,aAAa,CAACR,MAAM,GAAG,CAAC;MACzD,MAAMyJ,YAAY,GAAGvJ,IAAI,CAACmC,KAAK,CAACqH,CAAC,KAAK,CAAC,IAAIxJ,IAAI,CAACmC,KAAK,CAACsH,CAAC,KAAK,CAAC,IAAIzJ,IAAI,CAACmC,KAAK,CAACQ,CAAC,KAAK,CAAC;MACnF,MAAM+G,kBAAkB,GAAG1J,IAAI,CAAC8C,YAAY,CAAChD,MAAM,GAAG,CAAC;MACvD,IAAI6J,QAAQ,GAAG,CAAC;MAChBA,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;MAEnCA,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAET,WAAW,CAAC;MAC3CS,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAER,SAAS,CAAC;MACzCQ,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEP,eAAe,CAAC;MAC/CO,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEN,aAAa,CAAC;MAC7CM,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEL,mBAAmB,CAAC;MACnDK,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEJ,YAAY,CAAC;MAC5CI,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAED,kBAAkB,CAAC;MAClDlL,KAAK,CAAC+D,IAAI,CAACoH,QAAQ,CAAC;MACpBnL,KAAK,CAAC+D,IAAI,CAACvC,IAAI,CAAC0C,CAAC,EAAE1C,IAAI,CAAC2C,CAAC,EAAE3C,IAAI,CAAC4C,CAAC,CAAC;MAClCpE,KAAK,CAAC+D,IAAI,CAACvC,IAAI,CAAC6C,aAAa,CAAC;MAE9B,IAAIuG,eAAe,EAAE;QACnB,MAAM3K,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC,CAAC,CAAC,CAACmB,CAAC,CAAC;QAC9CpB,KAAK,CAAC+D,IAAI,CAACsH,UAAU,CAACpL,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEoL,UAAU,CAACpL,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEoL,UAAU,CAACpL,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;MACtG;MAEA,IAAI4K,aAAa,EAAE;QACjB7K,KAAK,CAAC+D,IAAI,CAACuH,cAAc,CAAC9J,IAAI,CAACC,MAAM,CAAC,CAAC;MACzC;MAEA,IAAIqJ,mBAAmB,EAAE;QACvB,MAAMhJ,aAAa,GAAGN,IAAI,CAACM,aAAa;QACxC9B,KAAK,CAAC+D,IAAI,CAACuH,cAAc,CAACxJ,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEwJ,cAAc,CAACxJ,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEwJ,cAAc,CAACxJ,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;MAClH;MAEA,IAAIiJ,YAAY,EAAE;QAChB/K,KAAK,CAAC+D,IAAI,CAACwH,aAAa,CAAC/J,IAAI,CAACmC,KAAK,CAAC,CAAC;MACvC;MAEA,IAAIuH,kBAAkB,EAAE;QACtB,MAAM5G,YAAY,GAAG9C,IAAI,CAAC8C,YAAY;QACtCtE,KAAK,CAAC+D,IAAI,CAACwH,aAAa,CAACjH,YAAY,CAAC,CAAC,CAAC,CAAC,EAAEiH,aAAa,CAACjH,YAAY,CAAC,CAAC,CAAC,CAAC,EAAEiH,aAAa,CAACjH,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5G;IACF;IAEA,SAAS8G,MAAM,CAACI,KAAK,EAAEhI,QAAQ,EAAEiI,OAAO,EAAE;MACxC,OAAOA,OAAO,GAAGD,KAAK,GAAG,CAAC,IAAIhI,QAAQ,GAAGgI,KAAK,GAAG,EAAE,CAAC,IAAIhI,QAAQ,CAAC;IACnE;IAEA,SAAS8H,cAAc,CAAC7J,MAAM,EAAE;MAC9B,MAAMiK,IAAI,GAAGjK,MAAM,CAACgB,CAAC,CAACkJ,QAAQ,EAAE,GAAGlK,MAAM,CAACiB,CAAC,CAACiJ,QAAQ,EAAE,GAAGlK,MAAM,CAACkB,CAAC,CAACgJ,QAAQ,EAAE;MAE5E,IAAIrB,WAAW,CAACoB,IAAI,CAAC,KAAKpI,SAAS,EAAE;QACnC,OAAOgH,WAAW,CAACoB,IAAI,CAAC;MAC1B;MAEApB,WAAW,CAACoB,IAAI,CAAC,GAAGrB,OAAO,CAAC/I,MAAM,GAAG,CAAC;MACtC+I,OAAO,CAACtG,IAAI,CAACtC,MAAM,CAACgB,CAAC,EAAEhB,MAAM,CAACiB,CAAC,EAAEjB,MAAM,CAACkB,CAAC,CAAC;MAC1C,OAAO2H,WAAW,CAACoB,IAAI,CAAC;IAC1B;IAEA,SAASH,aAAa,CAAC5H,KAAK,EAAE;MAC5B,MAAM+H,IAAI,GAAG/H,KAAK,CAACqH,CAAC,CAACW,QAAQ,EAAE,GAAGhI,KAAK,CAACsH,CAAC,CAACU,QAAQ,EAAE,GAAGhI,KAAK,CAACQ,CAAC,CAACwH,QAAQ,EAAE;MAEzE,IAAIpB,UAAU,CAACmB,IAAI,CAAC,KAAKpI,SAAS,EAAE;QAClC,OAAOiH,UAAU,CAACmB,IAAI,CAAC;MACzB;MAEAnB,UAAU,CAACmB,IAAI,CAAC,GAAG3L,MAAM,CAACuB,MAAM;MAChCvB,MAAM,CAACgE,IAAI,CAACJ,KAAK,CAACiI,MAAM,EAAE,CAAC;MAC3B,OAAOrB,UAAU,CAACmB,IAAI,CAAC;IACzB;IAEA,SAASL,UAAU,CAACzH,EAAE,EAAE;MACtB,MAAM8H,IAAI,GAAG9H,EAAE,CAACnB,CAAC,CAACkJ,QAAQ,EAAE,GAAG/H,EAAE,CAAClB,CAAC,CAACiJ,QAAQ,EAAE;MAE9C,IAAIlB,OAAO,CAACiB,IAAI,CAAC,KAAKpI,SAAS,EAAE;QAC/B,OAAOmH,OAAO,CAACiB,IAAI,CAAC;MACtB;MAEAjB,OAAO,CAACiB,IAAI,CAAC,GAAGlB,GAAG,CAAClJ,MAAM,GAAG,CAAC;MAC9BkJ,GAAG,CAACzG,IAAI,CAACH,EAAE,CAACnB,CAAC,EAAEmB,EAAE,CAAClB,CAAC,CAAC;MACpB,OAAO+H,OAAO,CAACiB,IAAI,CAAC;IACtB;IAEA1B,IAAI,CAACA,IAAI,GAAG,CAAC,CAAC;IACdA,IAAI,CAACA,IAAI,CAAClK,QAAQ,GAAGA,QAAQ;IAC7BkK,IAAI,CAACA,IAAI,CAACK,OAAO,GAAGA,OAAO;IAC3B,IAAItK,MAAM,CAACuB,MAAM,GAAG,CAAC,EAAE0I,IAAI,CAACA,IAAI,CAACjK,MAAM,GAAGA,MAAM;IAChD,IAAIyK,GAAG,CAAClJ,MAAM,GAAG,CAAC,EAAE0I,IAAI,CAACA,IAAI,CAACQ,GAAG,GAAG,CAACA,GAAG,CAAC,CAAC,CAAC;;IAE3CR,IAAI,CAACA,IAAI,CAAChK,KAAK,GAAGA,KAAK;IACvB,OAAOgK,IAAI;EACb;EAEAzF,KAAK,GAAG;IACN;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,OAAO,IAAIhF,QAAQ,EAAE,CAACsG,IAAI,CAAC,IAAI,CAAC;EAClC;EAEAA,IAAI,CAACgG,MAAM,EAAE;IACX;IACA,IAAI,CAAC/L,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,CAAC,EAAE,CAAC;IACzB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,cAAc,GAAG,IAAI,CAAC,CAAC;;IAE5B,IAAI,CAACZ,IAAI,GAAGiM,MAAM,CAACjM,IAAI,CAAC,CAAC;;IAEzB,MAAME,QAAQ,GAAG+L,MAAM,CAAC/L,QAAQ;IAEhC,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGvB,QAAQ,CAACwB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACjD,IAAI,CAACtB,QAAQ,CAACiE,IAAI,CAACjE,QAAQ,CAACsB,CAAC,CAAC,CAACmD,KAAK,EAAE,CAAC;IACzC,CAAC,CAAC;;IAGF,MAAMxE,MAAM,GAAG8L,MAAM,CAAC9L,MAAM;IAE5B,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGtB,MAAM,CAACuB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC/C,IAAI,CAACrB,MAAM,CAACgE,IAAI,CAAChE,MAAM,CAACqB,CAAC,CAAC,CAACmD,KAAK,EAAE,CAAC;IACrC,CAAC,CAAC;;IAGF,MAAMvE,KAAK,GAAG6L,MAAM,CAAC7L,KAAK;IAE1B,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGrB,KAAK,CAACsB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC9C,IAAI,CAACpB,KAAK,CAAC+D,IAAI,CAAC/D,KAAK,CAACoB,CAAC,CAAC,CAACmD,KAAK,EAAE,CAAC;IACnC,CAAC,CAAC;;IAGF,KAAK,IAAInD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGwK,MAAM,CAAC5L,aAAa,CAACqB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC7D,MAAMnB,aAAa,GAAG4L,MAAM,CAAC5L,aAAa,CAACmB,CAAC,CAAC;MAE7C,IAAI,IAAI,CAACnB,aAAa,CAACmB,CAAC,CAAC,KAAKkC,SAAS,EAAE;QACvC,IAAI,CAACrD,aAAa,CAACmB,CAAC,CAAC,GAAG,EAAE;MAC5B;MAEA,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG5B,aAAa,CAACqB,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACtD,MAAM4I,GAAG,GAAGvK,aAAa,CAAC2B,CAAC,CAAC;UACtBiG,OAAO,GAAG,EAAE;QAElB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGyC,GAAG,CAAClJ,MAAM,EAAEwG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UAC5C,MAAMlE,EAAE,GAAG4G,GAAG,CAAC1C,CAAC,CAAC;UACjBD,OAAO,CAAC9D,IAAI,CAACH,EAAE,CAACW,KAAK,EAAE,CAAC;QAC1B;QAEA,IAAI,CAACtE,aAAa,CAACmB,CAAC,CAAC,CAAC2C,IAAI,CAAC8D,OAAO,CAAC;MACrC;IACF,CAAC,CAAC;;IAGF,MAAM3H,YAAY,GAAG2L,MAAM,CAAC3L,YAAY;IAExC,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGnB,YAAY,CAACoB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACrD,MAAM0K,WAAW,GAAG,CAAC,CAAC;MACtBA,WAAW,CAAClM,IAAI,GAAGM,YAAY,CAACkB,CAAC,CAAC,CAACxB,IAAI,CAAC,CAAC;;MAEzC,IAAIM,YAAY,CAACkB,CAAC,CAAC,CAACtB,QAAQ,KAAKwD,SAAS,EAAE;QAC1CwI,WAAW,CAAChM,QAAQ,GAAG,EAAE;QAEzB,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG3B,YAAY,CAACkB,CAAC,CAAC,CAACtB,QAAQ,CAACwB,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACjEkK,WAAW,CAAChM,QAAQ,CAACiE,IAAI,CAAC7D,YAAY,CAACkB,CAAC,CAAC,CAACtB,QAAQ,CAAC8B,CAAC,CAAC,CAAC2C,KAAK,EAAE,CAAC;QAChE;MACF,CAAC,CAAC;;MAGF,IAAIrE,YAAY,CAACkB,CAAC,CAAC,CAACiJ,OAAO,KAAK/G,SAAS,EAAE;QACzCwI,WAAW,CAACzB,OAAO,GAAG,EAAE;QAExB,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG3B,YAAY,CAACkB,CAAC,CAAC,CAACiJ,OAAO,CAAC/I,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UAChEkK,WAAW,CAACzB,OAAO,CAACtG,IAAI,CAAC7D,YAAY,CAACkB,CAAC,CAAC,CAACiJ,OAAO,CAACzI,CAAC,CAAC,CAAC2C,KAAK,EAAE,CAAC;QAC9D;MACF;MAEA,IAAI,CAACrE,YAAY,CAAC6D,IAAI,CAAC+H,WAAW,CAAC;IACrC,CAAC,CAAC;;IAGF,MAAM3L,YAAY,GAAG0L,MAAM,CAAC1L,YAAY;IAExC,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGlB,YAAY,CAACmB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACrD,MAAM2K,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;;MAExB,IAAI5L,YAAY,CAACiB,CAAC,CAAC,CAACU,aAAa,KAAKwB,SAAS,EAAE;QAC/CyI,WAAW,CAACjK,aAAa,GAAG,EAAE;QAE9B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG1B,YAAY,CAACiB,CAAC,CAAC,CAACU,aAAa,CAACR,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACtE,MAAMoK,eAAe,GAAG7L,YAAY,CAACiB,CAAC,CAAC,CAACU,aAAa,CAACF,CAAC,CAAC;UACxD,MAAMqK,gBAAgB,GAAG,CAAC,CAAC;UAC3BA,gBAAgB,CAAC/H,CAAC,GAAG8H,eAAe,CAAC9H,CAAC,CAACK,KAAK,EAAE;UAC9C0H,gBAAgB,CAAC9H,CAAC,GAAG6H,eAAe,CAAC7H,CAAC,CAACI,KAAK,EAAE;UAC9C0H,gBAAgB,CAAC7H,CAAC,GAAG4H,eAAe,CAAC5H,CAAC,CAACG,KAAK,EAAE;UAC9CwH,WAAW,CAACjK,aAAa,CAACiC,IAAI,CAACkI,gBAAgB,CAAC;QAClD;MACF,CAAC,CAAC;;MAGF,IAAI9L,YAAY,CAACiB,CAAC,CAAC,CAACqF,WAAW,KAAKnD,SAAS,EAAE;QAC7CyI,WAAW,CAACtF,WAAW,GAAG,EAAE;QAE5B,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG1B,YAAY,CAACiB,CAAC,CAAC,CAACqF,WAAW,CAACnF,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACpEmK,WAAW,CAACtF,WAAW,CAAC1C,IAAI,CAAC5D,YAAY,CAACiB,CAAC,CAAC,CAACqF,WAAW,CAAC7E,CAAC,CAAC,CAAC2C,KAAK,EAAE,CAAC;QACtE;MACF;MAEA,IAAI,CAACpE,YAAY,CAAC4D,IAAI,CAACgI,WAAW,CAAC;IACrC,CAAC,CAAC;;IAGF,MAAM3L,WAAW,GAAGyL,MAAM,CAACzL,WAAW;IAEtC,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGjB,WAAW,CAACkB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACpD,IAAI,CAAChB,WAAW,CAAC2D,IAAI,CAAC3D,WAAW,CAACgB,CAAC,CAAC,CAACmD,KAAK,EAAE,CAAC;IAC/C,CAAC,CAAC;;IAGF,MAAMlE,WAAW,GAAGwL,MAAM,CAACxL,WAAW;IAEtC,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGhB,WAAW,CAACiB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACpD,IAAI,CAACf,WAAW,CAAC0D,IAAI,CAAC1D,WAAW,CAACe,CAAC,CAAC,CAACmD,KAAK,EAAE,CAAC;IAC/C,CAAC,CAAC;;IAGF,MAAMjE,aAAa,GAAGuL,MAAM,CAACvL,aAAa;IAE1C,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGf,aAAa,CAACgB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD,IAAI,CAACd,aAAa,CAACyD,IAAI,CAACzD,aAAa,CAACc,CAAC,CAAC,CAAC;IAC3C,CAAC,CAAC;;IAGF,MAAMb,WAAW,GAAGsL,MAAM,CAACtL,WAAW;IAEtC,IAAIA,WAAW,KAAK,IAAI,EAAE;MACxB,IAAI,CAACA,WAAW,GAAGA,WAAW,CAACgE,KAAK,EAAE;IACxC,CAAC,CAAC;;IAGF,MAAM/D,cAAc,GAAGqL,MAAM,CAACrL,cAAc;IAE5C,IAAIA,cAAc,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACA,cAAc,GAAGA,cAAc,CAAC+D,KAAK,EAAE;IAC9C,CAAC,CAAC;;IAGF,IAAI,CAAC9D,kBAAkB,GAAGoL,MAAM,CAACpL,kBAAkB;IACnD,IAAI,CAACC,kBAAkB,GAAGmL,MAAM,CAACnL,kBAAkB;IACnD,IAAI,CAACC,aAAa,GAAGkL,MAAM,CAAClL,aAAa;IACzC,IAAI,CAACC,iBAAiB,GAAGiL,MAAM,CAACjL,iBAAiB;IACjD,IAAI,CAACC,gBAAgB,GAAGgL,MAAM,CAAChL,gBAAgB;IAC/C,IAAI,CAACC,uBAAuB,GAAG+K,MAAM,CAAC/K,uBAAuB;IAC7D,IAAI,CAACC,gBAAgB,GAAG8K,MAAM,CAAC9K,gBAAgB;IAC/C,OAAO,IAAI;EACb;EAEAmL,gBAAgB,GAAG;IACjB,MAAM/I,QAAQ,GAAG,IAAIgJ,cAAc,EAAE,CAACC,YAAY,CAAC,IAAI,CAAC;IACxD,MAAMC,cAAc,GAAG,IAAIrN,cAAc,EAAE;IAC3C,MAAMsN,SAAS,GAAG,IAAIC,YAAY,CAACpJ,QAAQ,CAACrD,QAAQ,CAACwB,MAAM,GAAG,CAAC,CAAC;IAChE+K,cAAc,CAACG,YAAY,CAAC,UAAU,EAAE,IAAIvN,eAAe,CAACqN,SAAS,EAAE,CAAC,CAAC,CAACG,iBAAiB,CAACtJ,QAAQ,CAACrD,QAAQ,CAAC,CAAC;IAE/G,IAAIqD,QAAQ,CAACkH,OAAO,CAAC/I,MAAM,GAAG,CAAC,EAAE;MAC/B,MAAM+I,OAAO,GAAG,IAAIkC,YAAY,CAACpJ,QAAQ,CAACkH,OAAO,CAAC/I,MAAM,GAAG,CAAC,CAAC;MAC7D+K,cAAc,CAACG,YAAY,CAAC,QAAQ,EAAE,IAAIvN,eAAe,CAACoL,OAAO,EAAE,CAAC,CAAC,CAACoC,iBAAiB,CAACtJ,QAAQ,CAACkH,OAAO,CAAC,CAAC;IAC5G;IAEA,IAAIlH,QAAQ,CAACpD,MAAM,CAACuB,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAMvB,MAAM,GAAG,IAAIwM,YAAY,CAACpJ,QAAQ,CAACpD,MAAM,CAACuB,MAAM,GAAG,CAAC,CAAC;MAC3D+K,cAAc,CAACG,YAAY,CAAC,OAAO,EAAE,IAAIvN,eAAe,CAACc,MAAM,EAAE,CAAC,CAAC,CAAC2M,eAAe,CAACvJ,QAAQ,CAACpD,MAAM,CAAC,CAAC;IACvG;IAEA,IAAIoD,QAAQ,CAACqH,GAAG,CAAClJ,MAAM,GAAG,CAAC,EAAE;MAC3B,MAAMkJ,GAAG,GAAG,IAAI+B,YAAY,CAACpJ,QAAQ,CAACqH,GAAG,CAAClJ,MAAM,GAAG,CAAC,CAAC;MACrD+K,cAAc,CAACG,YAAY,CAAC,IAAI,EAAE,IAAIvN,eAAe,CAACuL,GAAG,EAAE,CAAC,CAAC,CAACmC,iBAAiB,CAACxJ,QAAQ,CAACqH,GAAG,CAAC,CAAC;IAChG;IAEA,IAAIrH,QAAQ,CAACyE,IAAI,CAACtG,MAAM,GAAG,CAAC,EAAE;MAC5B,MAAMsG,IAAI,GAAG,IAAI2E,YAAY,CAACpJ,QAAQ,CAACyE,IAAI,CAACtG,MAAM,GAAG,CAAC,CAAC;MACvD+K,cAAc,CAACG,YAAY,CAAC,KAAK,EAAE,IAAIvN,eAAe,CAAC2I,IAAI,EAAE,CAAC,CAAC,CAAC+E,iBAAiB,CAACxJ,QAAQ,CAACyE,IAAI,CAAC,CAAC;IACnG,CAAC,CAAC;;IAGFyE,cAAc,CAAC5H,MAAM,GAAGtB,QAAQ,CAACsB,MAAM,CAAC,CAAC;;IAEzC,KAAK,IAAI7E,IAAI,IAAIuD,QAAQ,CAACjD,YAAY,EAAE;MACtC,MAAM0M,KAAK,GAAG,EAAE;MAChB,MAAM1M,YAAY,GAAGiD,QAAQ,CAACjD,YAAY,CAACN,IAAI,CAAC;MAEhD,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEiI,CAAC,GAAGnJ,YAAY,CAACoB,MAAM,EAAEF,CAAC,GAAGiI,CAAC,EAAEjI,CAAC,EAAE,EAAE;QACnD,MAAM0K,WAAW,GAAG5L,YAAY,CAACkB,CAAC,CAAC;QACnC,MAAMyL,SAAS,GAAG,IAAI3N,sBAAsB,CAAC4M,WAAW,CAAC9B,IAAI,CAAC1I,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;QAC5EuL,SAAS,CAACjN,IAAI,GAAGkM,WAAW,CAAClM,IAAI;QACjCgN,KAAK,CAAC7I,IAAI,CAAC8I,SAAS,CAACJ,iBAAiB,CAACX,WAAW,CAAC9B,IAAI,CAAC,CAAC;MAC3D;MAEAqC,cAAc,CAACS,eAAe,CAAClN,IAAI,CAAC,GAAGgN,KAAK;IAC9C,CAAC,CAAC;;IAGF,IAAIzJ,QAAQ,CAAC9C,WAAW,CAACiB,MAAM,GAAG,CAAC,EAAE;MACnC,MAAMjB,WAAW,GAAG,IAAInB,sBAAsB,CAACiE,QAAQ,CAAC9C,WAAW,CAACiB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;MAClF+K,cAAc,CAACG,YAAY,CAAC,WAAW,EAAEnM,WAAW,CAAC0M,iBAAiB,CAAC5J,QAAQ,CAAC9C,WAAW,CAAC,CAAC;IAC/F;IAEA,IAAI8C,QAAQ,CAAC/C,WAAW,CAACkB,MAAM,GAAG,CAAC,EAAE;MACnC,MAAMlB,WAAW,GAAG,IAAIlB,sBAAsB,CAACiE,QAAQ,CAAC/C,WAAW,CAACkB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;MAClF+K,cAAc,CAACG,YAAY,CAAC,YAAY,EAAEpM,WAAW,CAAC2M,iBAAiB,CAAC5J,QAAQ,CAAC/C,WAAW,CAAC,CAAC;IAChG,CAAC,CAAC;;IAGF,IAAI+C,QAAQ,CAAC3C,cAAc,KAAK,IAAI,EAAE;MACpC6L,cAAc,CAAC7L,cAAc,GAAG2C,QAAQ,CAAC3C,cAAc,CAAC+D,KAAK,EAAE;IACjE;IAEA,IAAIpB,QAAQ,CAAC5C,WAAW,KAAK,IAAI,EAAE;MACjC8L,cAAc,CAAC9L,WAAW,GAAG4C,QAAQ,CAAC5C,WAAW,CAACgE,KAAK,EAAE;IAC3D;IAEA,OAAO8H,cAAc;EACvB;EAEAW,eAAe,GAAG;IAChBvJ,OAAO,CAACC,KAAK,CAAC,sDAAsD,CAAC;EACvE;EAEAuJ,oBAAoB,GAAG;IACrBxJ,OAAO,CAACC,KAAK,CAAC,0GAA0G,CAAC;EAC3H;EAEAwJ,WAAW,CAACjM,MAAM,EAAE;IAClBwC,OAAO,CAAC0J,IAAI,CAAC,qEAAqE,CAAC;IACnF,OAAO,IAAI,CAACnM,YAAY,CAACC,MAAM,CAAC;EAClC;EAEAmM,OAAO,GAAG;IACR,IAAI,CAACC,aAAa,CAAC;MACjBxN,IAAI,EAAE;IACR,CAAC,CAAC;EACJ;AAEF;AAEAN,QAAQ,CAAC+N,8BAA8B,GAAGC,MAAM,IAAI;EAClD,IAAIlB,cAAc,GAAG,IAAIrN,cAAc,EAAE;EACzC,MAAMmE,QAAQ,GAAGoK,MAAM,CAACpK,QAAQ;EAEhC,IAAIoK,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACE,MAAM,EAAE;IACpC,MAAMnB,SAAS,GAAG,IAAIpN,sBAAsB,CAACiE,QAAQ,CAACrD,QAAQ,CAACwB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;IAC7E,MAAMvB,MAAM,GAAG,IAAIb,sBAAsB,CAACiE,QAAQ,CAACpD,MAAM,CAACuB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;IACxE+K,cAAc,CAACG,YAAY,CAAC,UAAU,EAAEF,SAAS,CAACG,iBAAiB,CAACtJ,QAAQ,CAACrD,QAAQ,CAAC,CAAC;IACvFuM,cAAc,CAACG,YAAY,CAAC,OAAO,EAAEzM,MAAM,CAAC2M,eAAe,CAACvJ,QAAQ,CAACpD,MAAM,CAAC,CAAC;IAE7E,IAAIoD,QAAQ,CAAC7C,aAAa,IAAI6C,QAAQ,CAAC7C,aAAa,CAACgB,MAAM,KAAK6B,QAAQ,CAACrD,QAAQ,CAACwB,MAAM,EAAE;MACxF,MAAMhB,aAAa,GAAG,IAAIpB,sBAAsB,CAACiE,QAAQ,CAAC7C,aAAa,CAACgB,MAAM,EAAE,CAAC,CAAC;MAClF+K,cAAc,CAACG,YAAY,CAAC,cAAc,EAAElM,aAAa,CAACoN,SAAS,CAACvK,QAAQ,CAAC7C,aAAa,CAAC,CAAC;IAC9F;IAEA,IAAI6C,QAAQ,CAAC3C,cAAc,KAAK,IAAI,EAAE;MACpC6L,cAAc,CAAC7L,cAAc,GAAG2C,QAAQ,CAAC3C,cAAc,CAAC+D,KAAK,EAAE;IACjE;IAEA,IAAIpB,QAAQ,CAAC5C,WAAW,KAAK,IAAI,EAAE;MACjC8L,cAAc,CAAC9L,WAAW,GAAG4C,QAAQ,CAAC5C,WAAW,CAACgE,KAAK,EAAE;IAC3D;EACF,CAAC,MAAM,IAAIgJ,MAAM,CAACrF,MAAM,EAAE;IACxBmE,cAAc,GAAGlJ,QAAQ,CAAC+I,gBAAgB,EAAE;EAC9C;EAEA,OAAOG,cAAc;AACvB,CAAC;AAED,MAAMF,cAAc,CAAC;EACnB3M,WAAW,GAAG;IACZ,IAAI,CAACM,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACuK,OAAO,GAAG,EAAE;IACjB,IAAI,CAACtK,MAAM,GAAG,EAAE;IAChB,IAAI,CAACyK,GAAG,GAAG,EAAE;IACb,IAAI,CAAC5C,IAAI,GAAG,EAAE;IACd,IAAI,CAACnD,MAAM,GAAG,EAAE;IAChB,IAAI,CAACvE,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACE,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE,CAAC,CAAC;;IAEvB,IAAI,CAACE,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,cAAc,GAAG,IAAI,CAAC,CAAC;;IAE5B,IAAI,CAACE,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACE,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACF,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACI,gBAAgB,GAAG,KAAK;EAC/B;EAEA4M,aAAa,CAACxK,QAAQ,EAAE;IACtB,MAAMsB,MAAM,GAAG,EAAE;IACjB,IAAIC,KAAK,EAAEtD,CAAC;IACZ,IAAIiD,aAAa,GAAGf,SAAS;IAC7B,MAAMtD,KAAK,GAAGmD,QAAQ,CAACnD,KAAK;IAE5B,KAAKoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,KAAK,CAACsB,MAAM,EAAEF,CAAC,EAAE,EAAE;MACjC,MAAMI,IAAI,GAAGxB,KAAK,CAACoB,CAAC,CAAC,CAAC,CAAC;;MAEvB,IAAII,IAAI,CAAC6C,aAAa,KAAKA,aAAa,EAAE;QACxCA,aAAa,GAAG7C,IAAI,CAAC6C,aAAa;QAElC,IAAIK,KAAK,KAAKpB,SAAS,EAAE;UACvBoB,KAAK,CAACZ,KAAK,GAAG1C,CAAC,GAAG,CAAC,GAAGsD,KAAK,CAACC,KAAK;UACjCF,MAAM,CAACV,IAAI,CAACW,KAAK,CAAC;QACpB;QAEAA,KAAK,GAAG;UACNC,KAAK,EAAEvD,CAAC,GAAG,CAAC;UACZiD;QACF,CAAC;MACH;IACF;IAEA,IAAIK,KAAK,KAAKpB,SAAS,EAAE;MACvBoB,KAAK,CAACZ,KAAK,GAAG1C,CAAC,GAAG,CAAC,GAAGsD,KAAK,CAACC,KAAK;MACjCF,MAAM,CAACV,IAAI,CAACW,KAAK,CAAC;IACpB;IAEA,IAAI,CAACD,MAAM,GAAGA,MAAM;EACtB;EAEA2H,YAAY,CAACjJ,QAAQ,EAAE;IACrB,MAAMnD,KAAK,GAAGmD,QAAQ,CAACnD,KAAK;IAC5B,MAAMF,QAAQ,GAAGqD,QAAQ,CAACrD,QAAQ;IAClC,MAAMG,aAAa,GAAGkD,QAAQ,CAAClD,aAAa;IAC5C,MAAM2K,eAAe,GAAG3K,aAAa,CAAC,CAAC,CAAC,IAAIA,aAAa,CAAC,CAAC,CAAC,CAACqB,MAAM,GAAG,CAAC;IACvE,MAAMsM,gBAAgB,GAAG3N,aAAa,CAAC,CAAC,CAAC,IAAIA,aAAa,CAAC,CAAC,CAAC,CAACqB,MAAM,GAAG,CAAC,CAAC,CAAC;;IAE1E,MAAMpB,YAAY,GAAGiD,QAAQ,CAACjD,YAAY;IAC1C,MAAM2N,kBAAkB,GAAG3N,YAAY,CAACoB,MAAM;IAC9C,IAAIwM,oBAAoB;IAExB,IAAID,kBAAkB,GAAG,CAAC,EAAE;MAC1BC,oBAAoB,GAAG,EAAE;MAEzB,KAAK,IAAI1M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyM,kBAAkB,EAAEzM,CAAC,EAAE,EAAE;QAC3C0M,oBAAoB,CAAC1M,CAAC,CAAC,GAAG;UACxBxB,IAAI,EAAEM,YAAY,CAACkB,CAAC,CAAC,CAACxB,IAAI;UAC1BoK,IAAI,EAAE;QACR,CAAC;MACH;MAEA,IAAI,CAAC9J,YAAY,CAACsD,QAAQ,GAAGsK,oBAAoB;IACnD;IAEA,MAAM3N,YAAY,GAAGgD,QAAQ,CAAChD,YAAY;IAC1C,MAAM4N,kBAAkB,GAAG5N,YAAY,CAACmB,MAAM;IAC9C,IAAI0M,kBAAkB;IAEtB,IAAID,kBAAkB,GAAG,CAAC,EAAE;MAC1BC,kBAAkB,GAAG,EAAE;MAEvB,KAAK,IAAI5M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2M,kBAAkB,EAAE3M,CAAC,EAAE,EAAE;QAC3C4M,kBAAkB,CAAC5M,CAAC,CAAC,GAAG;UACtBxB,IAAI,EAAEO,YAAY,CAACiB,CAAC,CAAC,CAACxB,IAAI;UAC1BoK,IAAI,EAAE;QACR,CAAC;MACH;MAEA,IAAI,CAAC9J,YAAY,CAACuB,MAAM,GAAGuM,kBAAkB;IAC/C,CAAC,CAAC;;IAGF,MAAM3N,WAAW,GAAG8C,QAAQ,CAAC9C,WAAW;IACxC,MAAMD,WAAW,GAAG+C,QAAQ,CAAC/C,WAAW;IACxC,MAAM6N,cAAc,GAAG5N,WAAW,CAACiB,MAAM,KAAKxB,QAAQ,CAACwB,MAAM;IAC7D,MAAM4M,cAAc,GAAG9N,WAAW,CAACkB,MAAM,KAAKxB,QAAQ,CAACwB,MAAM,CAAC,CAAC;;IAE/D,IAAIxB,QAAQ,CAACwB,MAAM,GAAG,CAAC,IAAItB,KAAK,CAACsB,MAAM,KAAK,CAAC,EAAE;MAC7CmC,OAAO,CAACC,KAAK,CAAC,8DAA8D,CAAC;IAC/E;IAEA,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,KAAK,CAACsB,MAAM,EAAEF,CAAC,EAAE,EAAE;MACrC,MAAMI,IAAI,GAAGxB,KAAK,CAACoB,CAAC,CAAC;MACrB,IAAI,CAACtB,QAAQ,CAACiE,IAAI,CAACjE,QAAQ,CAAC0B,IAAI,CAAC0C,CAAC,CAAC,EAAEpE,QAAQ,CAAC0B,IAAI,CAAC2C,CAAC,CAAC,EAAErE,QAAQ,CAAC0B,IAAI,CAAC4C,CAAC,CAAC,CAAC;MACxE,MAAMtC,aAAa,GAAGN,IAAI,CAACM,aAAa;MAExC,IAAIA,aAAa,CAACR,MAAM,KAAK,CAAC,EAAE;QAC9B,IAAI,CAAC+I,OAAO,CAACtG,IAAI,CAACjC,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,CAAC;MACzE,CAAC,MAAM;QACL,MAAML,MAAM,GAAGD,IAAI,CAACC,MAAM;QAC1B,IAAI,CAAC4I,OAAO,CAACtG,IAAI,CAACtC,MAAM,EAAEA,MAAM,EAAEA,MAAM,CAAC;MAC3C;MAEA,MAAM6C,YAAY,GAAG9C,IAAI,CAAC8C,YAAY;MAEtC,IAAIA,YAAY,CAAChD,MAAM,KAAK,CAAC,EAAE;QAC7B,IAAI,CAACvB,MAAM,CAACgE,IAAI,CAACO,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAAC,CAAC,CAAC,CAAC;MACrE,CAAC,MAAM;QACL,MAAMX,KAAK,GAAGnC,IAAI,CAACmC,KAAK;QACxB,IAAI,CAAC5D,MAAM,CAACgE,IAAI,CAACJ,KAAK,EAAEA,KAAK,EAAEA,KAAK,CAAC;MACvC;MAEA,IAAIiH,eAAe,KAAK,IAAI,EAAE;QAC5B,MAAMuD,SAAS,GAAGlO,aAAa,CAAC,CAAC,CAAC,CAACmB,CAAC,CAAC;QAErC,IAAI+M,SAAS,KAAK7K,SAAS,EAAE;UAC3B,IAAI,CAACkH,GAAG,CAACzG,IAAI,CAACoK,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;QACzD,CAAC,MAAM;UACL1K,OAAO,CAAC0J,IAAI,CAAC,0DAA0D,EAAE/L,CAAC,CAAC;UAC3E,IAAI,CAACoJ,GAAG,CAACzG,IAAI,CAAC,IAAI5E,OAAO,EAAE,EAAE,IAAIA,OAAO,EAAE,EAAE,IAAIA,OAAO,EAAE,CAAC;QAC5D;MACF;MAEA,IAAIyO,gBAAgB,KAAK,IAAI,EAAE;QAC7B,MAAMO,SAAS,GAAGlO,aAAa,CAAC,CAAC,CAAC,CAACmB,CAAC,CAAC;QAErC,IAAI+M,SAAS,KAAK7K,SAAS,EAAE;UAC3B,IAAI,CAACsE,IAAI,CAAC7D,IAAI,CAACoK,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;QAC1D,CAAC,MAAM;UACL1K,OAAO,CAAC0J,IAAI,CAAC,2DAA2D,EAAE/L,CAAC,CAAC;UAC5E,IAAI,CAACwG,IAAI,CAAC7D,IAAI,CAAC,IAAI5E,OAAO,EAAE,EAAE,IAAIA,OAAO,EAAE,EAAE,IAAIA,OAAO,EAAE,CAAC;QAC7D;MACF,CAAC,CAAC;;MAGF,KAAK,IAAIyC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiM,kBAAkB,EAAEjM,CAAC,EAAE,EAAE;QAC3C,MAAMkK,WAAW,GAAG5L,YAAY,CAAC0B,CAAC,CAAC,CAAC9B,QAAQ;QAC5CgO,oBAAoB,CAAClM,CAAC,CAAC,CAACoI,IAAI,CAACjG,IAAI,CAAC+H,WAAW,CAACtK,IAAI,CAAC0C,CAAC,CAAC,EAAE4H,WAAW,CAACtK,IAAI,CAAC2C,CAAC,CAAC,EAAE2H,WAAW,CAACtK,IAAI,CAAC4C,CAAC,CAAC,CAAC;MAClG;MAEA,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmM,kBAAkB,EAAEnM,CAAC,EAAE,EAAE;QAC3C,MAAMmK,WAAW,GAAG5L,YAAY,CAACyB,CAAC,CAAC,CAACE,aAAa,CAACV,CAAC,CAAC;QACpD4M,kBAAkB,CAACpM,CAAC,CAAC,CAACoI,IAAI,CAACjG,IAAI,CAACgI,WAAW,CAAC7H,CAAC,EAAE6H,WAAW,CAAC5H,CAAC,EAAE4H,WAAW,CAAC3H,CAAC,CAAC;MAC9E,CAAC,CAAC;;MAGF,IAAI6J,cAAc,EAAE;QAClB,IAAI,CAAC5N,WAAW,CAAC0D,IAAI,CAAC1D,WAAW,CAACmB,IAAI,CAAC0C,CAAC,CAAC,EAAE7D,WAAW,CAACmB,IAAI,CAAC2C,CAAC,CAAC,EAAE9D,WAAW,CAACmB,IAAI,CAAC4C,CAAC,CAAC,CAAC;MACtF;MAEA,IAAI8J,cAAc,EAAE;QAClB,IAAI,CAAC9N,WAAW,CAAC2D,IAAI,CAAC3D,WAAW,CAACoB,IAAI,CAAC0C,CAAC,CAAC,EAAE9D,WAAW,CAACoB,IAAI,CAAC2C,CAAC,CAAC,EAAE/D,WAAW,CAACoB,IAAI,CAAC4C,CAAC,CAAC,CAAC;MACtF;IACF;IAEA,IAAI,CAACuJ,aAAa,CAACxK,QAAQ,CAAC;IAC5B,IAAI,CAACzC,kBAAkB,GAAGyC,QAAQ,CAACzC,kBAAkB;IACrD,IAAI,CAACE,iBAAiB,GAAGuC,QAAQ,CAACvC,iBAAiB;IACnD,IAAI,CAACC,gBAAgB,GAAGsC,QAAQ,CAACtC,gBAAgB;IACjD,IAAI,CAACF,aAAa,GAAGwC,QAAQ,CAACxC,aAAa;IAC3C,IAAI,CAACI,gBAAgB,GAAGoC,QAAQ,CAACpC,gBAAgB;IAEjD,IAAIoC,QAAQ,CAAC3C,cAAc,KAAK,IAAI,EAAE;MACpC,IAAI,CAACA,cAAc,GAAG2C,QAAQ,CAAC3C,cAAc,CAAC+D,KAAK,EAAE;IACvD;IAEA,IAAIpB,QAAQ,CAAC5C,WAAW,KAAK,IAAI,EAAE;MACjC,IAAI,CAACA,WAAW,GAAG4C,QAAQ,CAAC5C,WAAW,CAACgE,KAAK,EAAE;IACjD;IAEA,OAAO,IAAI;EACb;AAEF;AAEA,MAAMC,KAAK,CAAC;EACVhF,WAAW,CAAC0E,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE3C,MAAM,EAAEkC,KAAK,EAAqB;IAAA,IAAnBU,aAAa,uEAAG,CAAC;IACnD,IAAI,CAACH,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGA,CAAC;IACV,IAAI,CAAC3C,MAAM,GAAGA,MAAM,IAAIA,MAAM,CAAC2M,SAAS,GAAG3M,MAAM,GAAG,IAAIhD,OAAO,EAAE;IACjE,IAAI,CAACqD,aAAa,GAAGkE,KAAK,CAACqI,OAAO,CAAC5M,MAAM,CAAC,GAAGA,MAAM,GAAG,EAAE;IACxD,IAAI,CAACkC,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAAC2K,OAAO,GAAG3K,KAAK,GAAG,IAAI9E,KAAK,EAAE;IACzD,IAAI,CAACyF,YAAY,GAAG0B,KAAK,CAACqI,OAAO,CAAC1K,KAAK,CAAC,GAAGA,KAAK,GAAG,EAAE;IACrD,IAAI,CAACU,aAAa,GAAGA,aAAa;EACpC;EAEAE,KAAK,GAAG;IACN,OAAO,IAAI,IAAI,CAAC/E,WAAW,EAAE,CAACqG,IAAI,CAAC,IAAI,CAAC;EAC1C;EAEAA,IAAI,CAACgG,MAAM,EAAE;IACX,IAAI,CAAC3H,CAAC,GAAG2H,MAAM,CAAC3H,CAAC;IACjB,IAAI,CAACC,CAAC,GAAG0H,MAAM,CAAC1H,CAAC;IACjB,IAAI,CAACC,CAAC,GAAGyH,MAAM,CAACzH,CAAC;IACjB,IAAI,CAAC3C,MAAM,CAACoE,IAAI,CAACgG,MAAM,CAACpK,MAAM,CAAC;IAC/B,IAAI,CAACkC,KAAK,CAACkC,IAAI,CAACgG,MAAM,CAAClI,KAAK,CAAC;IAC7B,IAAI,CAACU,aAAa,GAAGwH,MAAM,CAACxH,aAAa;IAEzC,KAAK,IAAIjD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGwK,MAAM,CAAC/J,aAAa,CAACR,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC7D,IAAI,CAACU,aAAa,CAACV,CAAC,CAAC,GAAGyK,MAAM,CAAC/J,aAAa,CAACV,CAAC,CAAC,CAACmD,KAAK,EAAE;IACzD;IAEA,KAAK,IAAInD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGwK,MAAM,CAACvH,YAAY,CAAChD,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC5D,IAAI,CAACkD,YAAY,CAAClD,CAAC,CAAC,GAAGyK,MAAM,CAACvH,YAAY,CAAClD,CAAC,CAAC,CAACmD,KAAK,EAAE;IACvD;IAEA,OAAO,IAAI;EACb;AAEF;AAEA,SAASC,KAAK,EAAEjF,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}