{"ast":null,"code":"import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\n\nvar VolumeSlice = function (volume, index, axis) {\n  var slice = this;\n  /**\n   * @member {Volume} volume The associated volume\n   */\n\n  this.volume = volume;\n  /**\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n   */\n\n  index = index || 0;\n  Object.defineProperty(this, 'index', {\n    get: function () {\n      return index;\n    },\n    set: function (value) {\n      index = value;\n      slice.geometryNeedsUpdate = true;\n      return index;\n    }\n  });\n  /**\n   * @member {String} axis The normal axis\n   */\n\n  this.axis = axis || 'z';\n  /**\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\n   */\n\n  this.canvas = document.createElement('canvas');\n  /**\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n   */\n\n  this.canvasBuffer = document.createElement('canvas');\n  this.updateGeometry();\n  var canvasMap = new Texture(this.canvas);\n  canvasMap.minFilter = LinearFilter;\n  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n  var material = new MeshBasicMaterial({\n    map: canvasMap,\n    side: DoubleSide,\n    transparent: true\n  });\n  /**\n   * @member {Mesh} mesh The mesh ready to get used in the scene\n   */\n\n  this.mesh = new Mesh(this.geometry, material);\n  this.mesh.matrixAutoUpdate = false;\n  /**\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n   */\n\n  this.geometryNeedsUpdate = true;\n  this.repaint();\n  /**\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n   */\n\n  /**\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n   */\n\n  /**\n   * @member {Function} sliceAccess Function that allow the slice to access right data\n   * @see Volume.extractPerpendicularPlane\n   * @param {Number} i The first coordinate\n   * @param {Number} j The second coordinate\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n   */\n};\n\nVolumeSlice.prototype = {\n  constructor: VolumeSlice,\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint: function () {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n    var iLength = this.iLength,\n      jLength = this.jLength,\n      sliceAccess = this.sliceAccess,\n      volume = this.volume,\n      canvas = this.canvasBuffer,\n      ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\n\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\n    var data = imgData.data;\n    var volumeData = volume.data;\n    var upperThreshold = volume.upperThreshold;\n    var lowerThreshold = volume.lowerThreshold;\n    var windowLow = volume.windowLow;\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\n\n    var pixelCount = 0;\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          var label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          var color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 0xff;\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\n          data[4 * pixelCount + 3] = color & 0xff;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          var value = volumeData[sliceAccess(i, j)];\n          var alpha = 0xff; //apply threshold\n\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\n\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  },\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry: function () {\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry; //reset mesh matrix\n\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n    this.geometryNeedsUpdate = false;\n  }\n};\nexport { VolumeSlice };","map":{"version":3,"names":["Texture","LinearFilter","ClampToEdgeWrapping","MeshBasicMaterial","DoubleSide","Mesh","PlaneGeometry","VolumeSlice","volume","index","axis","slice","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","minFilter","wrapS","wrapT","material","map","side","transparent","mesh","geometry","matrixAutoUpdate","repaint","prototype","constructor","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","identity","applyMatrix4"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/misc/VolumeSlice.js"],"sourcesContent":["import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\n\nvar VolumeSlice = function (volume, index, axis) {\n  var slice = this;\n  /**\n   * @member {Volume} volume The associated volume\n   */\n\n  this.volume = volume;\n  /**\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n   */\n\n  index = index || 0;\n  Object.defineProperty(this, 'index', {\n    get: function () {\n      return index;\n    },\n    set: function (value) {\n      index = value;\n      slice.geometryNeedsUpdate = true;\n      return index;\n    }\n  });\n  /**\n   * @member {String} axis The normal axis\n   */\n\n  this.axis = axis || 'z';\n  /**\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\n   */\n\n  this.canvas = document.createElement('canvas');\n  /**\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n   */\n\n  this.canvasBuffer = document.createElement('canvas');\n  this.updateGeometry();\n  var canvasMap = new Texture(this.canvas);\n  canvasMap.minFilter = LinearFilter;\n  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n  var material = new MeshBasicMaterial({\n    map: canvasMap,\n    side: DoubleSide,\n    transparent: true\n  });\n  /**\n   * @member {Mesh} mesh The mesh ready to get used in the scene\n   */\n\n  this.mesh = new Mesh(this.geometry, material);\n  this.mesh.matrixAutoUpdate = false;\n  /**\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n   */\n\n  this.geometryNeedsUpdate = true;\n  this.repaint();\n  /**\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n   */\n\n  /**\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n   */\n\n  /**\n   * @member {Function} sliceAccess Function that allow the slice to access right data\n   * @see Volume.extractPerpendicularPlane\n   * @param {Number} i The first coordinate\n   * @param {Number} j The second coordinate\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n   */\n};\n\nVolumeSlice.prototype = {\n  constructor: VolumeSlice,\n\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint: function () {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n\n    var iLength = this.iLength,\n        jLength = this.jLength,\n        sliceAccess = this.sliceAccess,\n        volume = this.volume,\n        canvas = this.canvasBuffer,\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\n\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\n    var data = imgData.data;\n    var volumeData = volume.data;\n    var upperThreshold = volume.upperThreshold;\n    var lowerThreshold = volume.lowerThreshold;\n    var windowLow = volume.windowLow;\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\n\n    var pixelCount = 0;\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          var label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          var color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 0xff;\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\n          data[4 * pixelCount + 3] = color & 0xff;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          var value = volumeData[sliceAccess(i, j)];\n          var alpha = 0xff; //apply threshold\n\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\n\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  },\n\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry: function () {\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry; //reset mesh matrix\n\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n\n    this.geometryNeedsUpdate = false;\n  }\n};\n\nexport { VolumeSlice };\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,iBAAiB,EAAEC,UAAU,EAAEC,IAAI,EAAEC,aAAa,QAAQ,OAAO;;AAEtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,WAAW,GAAG,UAAUC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAE;EAC/C,IAAIC,KAAK,GAAG,IAAI;EAChB;AACF;AACA;;EAEE,IAAI,CAACH,MAAM,GAAGA,MAAM;EACpB;AACF;AACA;;EAEEC,KAAK,GAAGA,KAAK,IAAI,CAAC;EAClBG,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;IACnCC,GAAG,EAAE,YAAY;MACf,OAAOL,KAAK;IACd,CAAC;IACDM,GAAG,EAAE,UAAUC,KAAK,EAAE;MACpBP,KAAK,GAAGO,KAAK;MACbL,KAAK,CAACM,mBAAmB,GAAG,IAAI;MAChC,OAAOR,KAAK;IACd;EACF,CAAC,CAAC;EACF;AACF;AACA;;EAEE,IAAI,CAACC,IAAI,GAAGA,IAAI,IAAI,GAAG;EACvB;AACF;AACA;;EAEE;AACF;AACA;;EAEE,IAAI,CAACQ,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EAC9C;AACF;AACA;;EAEE;AACF;AACA;;EAEE,IAAI,CAACC,YAAY,GAAGF,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EACpD,IAAI,CAACE,cAAc,EAAE;EACrB,IAAIC,SAAS,GAAG,IAAIvB,OAAO,CAAC,IAAI,CAACkB,MAAM,CAAC;EACxCK,SAAS,CAACC,SAAS,GAAGvB,YAAY;EAClCsB,SAAS,CAACE,KAAK,GAAGF,SAAS,CAACG,KAAK,GAAGxB,mBAAmB;EACvD,IAAIyB,QAAQ,GAAG,IAAIxB,iBAAiB,CAAC;IACnCyB,GAAG,EAAEL,SAAS;IACdM,IAAI,EAAEzB,UAAU;IAChB0B,WAAW,EAAE;EACf,CAAC,CAAC;EACF;AACF;AACA;;EAEE,IAAI,CAACC,IAAI,GAAG,IAAI1B,IAAI,CAAC,IAAI,CAAC2B,QAAQ,EAAEL,QAAQ,CAAC;EAC7C,IAAI,CAACI,IAAI,CAACE,gBAAgB,GAAG,KAAK;EAClC;AACF;AACA;;EAEE,IAAI,CAAChB,mBAAmB,GAAG,IAAI;EAC/B,IAAI,CAACiB,OAAO,EAAE;EACd;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED3B,WAAW,CAAC4B,SAAS,GAAG;EACtBC,WAAW,EAAE7B,WAAW;EAExB;AACF;AACA;AACA;EACE2B,OAAO,EAAE,YAAY;IACnB,IAAI,IAAI,CAACjB,mBAAmB,EAAE;MAC5B,IAAI,CAACK,cAAc,EAAE;IACvB;IAEA,IAAIe,OAAO,GAAG,IAAI,CAACA,OAAO;MACtBC,OAAO,GAAG,IAAI,CAACA,OAAO;MACtBC,WAAW,GAAG,IAAI,CAACA,WAAW;MAC9B/B,MAAM,GAAG,IAAI,CAACA,MAAM;MACpBU,MAAM,GAAG,IAAI,CAACG,YAAY;MAC1BmB,GAAG,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;;IAE1B,IAAIC,OAAO,GAAGF,GAAG,CAACG,YAAY,CAAC,CAAC,EAAE,CAAC,EAAEN,OAAO,EAAEC,OAAO,CAAC;IACtD,IAAIM,IAAI,GAAGF,OAAO,CAACE,IAAI;IACvB,IAAIC,UAAU,GAAGrC,MAAM,CAACoC,IAAI;IAC5B,IAAIE,cAAc,GAAGtC,MAAM,CAACsC,cAAc;IAC1C,IAAIC,cAAc,GAAGvC,MAAM,CAACuC,cAAc;IAC1C,IAAIC,SAAS,GAAGxC,MAAM,CAACwC,SAAS;IAChC,IAAIC,UAAU,GAAGzC,MAAM,CAACyC,UAAU,CAAC,CAAC;;IAEpC,IAAIC,UAAU,GAAG,CAAC;IAElB,IAAI1C,MAAM,CAAC2C,QAAQ,KAAK,OAAO,EAAE;MAC/B;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,OAAO,EAAEc,CAAC,EAAE,EAAE;QAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,OAAO,EAAEgB,CAAC,EAAE,EAAE;UAChC,IAAIC,KAAK,GAAGT,UAAU,CAACN,WAAW,CAACc,CAAC,EAAED,CAAC,CAAC,CAAC;UACzCE,KAAK,GAAGA,KAAK,IAAI,IAAI,CAACC,QAAQ,CAACC,MAAM,GAAGF,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACC,MAAM,GAAG,CAAC,GAAGF,KAAK;UAChF,IAAIG,KAAK,GAAG,IAAI,CAACF,QAAQ,CAACD,KAAK,CAAC;UAChCV,IAAI,CAAC,CAAC,GAAGM,UAAU,CAAC,GAAGO,KAAK,IAAI,EAAE,GAAG,IAAI;UACzCb,IAAI,CAAC,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAC,GAAGO,KAAK,IAAI,EAAE,GAAG,IAAI;UAC7Cb,IAAI,CAAC,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAC,GAAGO,KAAK,IAAI,CAAC,GAAG,IAAI;UAC5Cb,IAAI,CAAC,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAC,GAAGO,KAAK,GAAG,IAAI;UACvCP,UAAU,EAAE;QACd;MACF;IACF,CAAC,MAAM;MACL,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,OAAO,EAAEc,CAAC,EAAE,EAAE;QAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,OAAO,EAAEgB,CAAC,EAAE,EAAE;UAChC,IAAIrC,KAAK,GAAG6B,UAAU,CAACN,WAAW,CAACc,CAAC,EAAED,CAAC,CAAC,CAAC;UACzC,IAAIM,KAAK,GAAG,IAAI,CAAC,CAAC;;UAElBA,KAAK,GAAGZ,cAAc,IAAI9B,KAAK,GAAG+B,cAAc,IAAI/B,KAAK,GAAG0C,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;UAE3E1C,KAAK,GAAG2C,IAAI,CAACC,KAAK,CAAC,GAAG,IAAI5C,KAAK,GAAGgC,SAAS,CAAC,IAAIC,UAAU,GAAGD,SAAS,CAAC,CAAC;UACxEhC,KAAK,GAAGA,KAAK,GAAG,GAAG,GAAG,GAAG,GAAGA,KAAK,GAAG,CAAC,GAAG,CAAC,GAAGA,KAAK,GAAG,CAAC;UACrD4B,IAAI,CAAC,CAAC,GAAGM,UAAU,CAAC,GAAGlC,KAAK;UAC5B4B,IAAI,CAAC,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAC,GAAGlC,KAAK;UAChC4B,IAAI,CAAC,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAC,GAAGlC,KAAK;UAChC4B,IAAI,CAAC,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAC,GAAGQ,KAAK;UAChCR,UAAU,EAAE;QACd;MACF;IACF;IAEAV,GAAG,CAACqB,YAAY,CAACnB,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/B,IAAI,CAACF,GAAG,CAACsB,SAAS,CAAC5C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAEmB,OAAO,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACpB,MAAM,CAAC6C,KAAK,EAAE,IAAI,CAAC7C,MAAM,CAAC8C,MAAM,CAAC;IAC/F,IAAI,CAACjC,IAAI,CAACJ,QAAQ,CAACC,GAAG,CAACqC,WAAW,GAAG,IAAI;EAC3C,CAAC;EAED;AACF;AACA;AACA;AACA;EACE3C,cAAc,EAAE,YAAY;IAC1B,IAAI4C,SAAS,GAAG,IAAI,CAAC1D,MAAM,CAAC2D,yBAAyB,CAAC,IAAI,CAACzD,IAAI,EAAE,IAAI,CAACD,KAAK,CAAC;IAC5E,IAAI,CAAC8B,WAAW,GAAG2B,SAAS,CAAC3B,WAAW;IACxC,IAAI,CAACD,OAAO,GAAG4B,SAAS,CAAC5B,OAAO;IAChC,IAAI,CAACD,OAAO,GAAG6B,SAAS,CAAC7B,OAAO;IAChC,IAAI,CAAC+B,MAAM,GAAGF,SAAS,CAACE,MAAM;IAC9B,IAAI,CAAClD,MAAM,CAAC6C,KAAK,GAAGG,SAAS,CAACG,UAAU;IACxC,IAAI,CAACnD,MAAM,CAAC8C,MAAM,GAAGE,SAAS,CAACI,WAAW;IAC1C,IAAI,CAACjD,YAAY,CAAC0C,KAAK,GAAG,IAAI,CAAC1B,OAAO;IACtC,IAAI,CAAChB,YAAY,CAAC2C,MAAM,GAAG,IAAI,CAAC1B,OAAO;IACvC,IAAI,CAACE,GAAG,GAAG,IAAI,CAACtB,MAAM,CAACqD,UAAU,CAAC,IAAI,CAAC;IACvC,IAAI,CAAC9B,SAAS,GAAG,IAAI,CAACpB,YAAY,CAACkD,UAAU,CAAC,IAAI,CAAC;IACnD,IAAI,IAAI,CAACvC,QAAQ,EAAE,IAAI,CAACA,QAAQ,CAACwC,OAAO,EAAE,CAAC,CAAC;;IAE5C,IAAI,CAACxC,QAAQ,GAAG,IAAI1B,aAAa,CAAC4D,SAAS,CAACG,UAAU,EAAEH,SAAS,CAACI,WAAW,CAAC;IAE9E,IAAI,IAAI,CAACvC,IAAI,EAAE;MACb,IAAI,CAACA,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;;MAEpC,IAAI,CAACD,IAAI,CAACqC,MAAM,CAACK,QAAQ,EAAE;MAC3B,IAAI,CAAC1C,IAAI,CAAC2C,YAAY,CAAC,IAAI,CAACN,MAAM,CAAC;IACrC;IAEA,IAAI,CAACnD,mBAAmB,GAAG,KAAK;EAClC;AACF,CAAC;AAED,SAASV,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}