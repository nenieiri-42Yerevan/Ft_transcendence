{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const getConst = value => this.getConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    return type;\n  }\n  generateMethod(method) {\n    return method;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node\n  /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n  getTextureEncodingFromMap(map) {\n    let encoding;\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n    return encoding;\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  getDataFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    let nodeData = this.nodesData.get(node);\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n    return nodeVary;\n  }\n  getCodeFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n  flowChildNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node) {\n    let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n    return snippet;\n  }\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n}\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","addStack","push","removeStack","lastStack","pop","Error","setHashNode","hash","addNode","indexOf","updateType","getUpdateType","None","getHash","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","getTexture","console","warn","getTextureBias","getCubeTexture","getCubeTextureBias","getConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","generateMethod","getAttribute","name","attribute","getPropertyName","isVector","test","isMatrix","isReference","isShaderStage","getTextureEncodingFromMap","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","vecType","vecNum","getVectorFromMatrix","replace","getDataFromNode","nodeData","get","undefined","set","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","length","getVaryFromNode","nodeVary","vary","getCodeFromNode","nodeCode","addFlowCode","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributes","getVarys","getVars","snippet","getUniforms","getCodes","getShaderStage","buildCode","analyze","isNode","format","fromType","toType","fromTypeLength","toTypeLength","vectorType","slice","getSignature"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}