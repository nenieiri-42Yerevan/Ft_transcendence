{"ast":null,"code":"import { WebGLRenderTarget } from 'three';\nimport { SSAARenderPass } from './SSAARenderPass.js';\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  if (SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n      this.accumulateIndex = -1;\n      return;\n    }\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n    if (this.accumulate && this.accumulateIndex === -1) {\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n      this.accumulateIndex = 0;\n    }\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n      for (let i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625,\n          // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n    renderer.autoClear = autoClear;\n  }\n});\nexport { TAARenderPass };","map":{"version":3,"names":["WebGLRenderTarget","SSAARenderPass","TAARenderPass","scene","camera","clearColor","clearAlpha","undefined","console","error","call","sampleLevel","accumulate","JitterVectors","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","accumulateIndex","jitterOffsets","sampleRenderTarget","width","height","params","texture","name","holdRenderTarget","autoClear","sampleWeight","length","copyUniforms","value","numSamplesPerFrame","Math","pow","i","j","jitterOffset","setViewOffset","setRenderTarget","clear","fsQuad","clearViewOffset","accumulationWeight"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/postprocessing/TAARenderPass.js"],"sourcesContent":["import { WebGLRenderTarget } from 'three';\nimport { SSAARenderPass } from './SSAARenderPass.js';\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  if (SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n      this.accumulateIndex = -1;\n      return;\n    }\n\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n\n    if (this.accumulate && this.accumulateIndex === -1) {\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n      this.accumulateIndex = 0;\n    }\n\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\n      for (let i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n});\n\nexport { TAARenderPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}