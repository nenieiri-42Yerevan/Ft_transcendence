{"ast":null,"code":"import { Line3, Plane, Vector3, Mesh } from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nvar ConvexObjectBreaker = function (minSizeForBreak, smallDelta) {\n  this.minSizeForBreak = minSizeForBreak || 1.4;\n  this.smallDelta = smallDelta || 0.0001;\n  this.tempLine1 = new Line3();\n  this.tempPlane1 = new Plane();\n  this.tempPlane2 = new Plane();\n  this.tempPlane_Cut = new Plane();\n  this.tempCM1 = new Vector3();\n  this.tempCM2 = new Vector3();\n  this.tempVector3 = new Vector3();\n  this.tempVector3_2 = new Vector3();\n  this.tempVector3_3 = new Vector3();\n  this.tempVector3_P0 = new Vector3();\n  this.tempVector3_P1 = new Vector3();\n  this.tempVector3_P2 = new Vector3();\n  this.tempVector3_N0 = new Vector3();\n  this.tempVector3_N1 = new Vector3();\n  this.tempVector3_AB = new Vector3();\n  this.tempVector3_CB = new Vector3();\n  this.tempResultObjects = {\n    object1: null,\n    object2: null\n  };\n  this.segments = [];\n  var n = 30 * 30;\n  for (let i = 0; i < n; i++) this.segments[i] = false;\n};\nConvexObjectBreaker.prototype = {\n  constructor: ConvexObjectBreaker,\n  prepareBreakableObject: function (object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n    if (!object.geometry.isBufferGeometry) {\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\n    }\n    var userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  },\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact: function (object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    var debris = [];\n    var tempPlane1 = this.tempPlane1;\n    var tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    var scope = this;\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n      var angle = Math.PI;\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\n\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\n\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      } // Perform the cut\n\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      var obj1 = scope.tempResultObjects.object1;\n      var obj2 = scope.tempResultObjects.object2;\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  },\n  cutByPlane: function (object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n    var geometry = object.geometry;\n    var coords = geometry.attributes.position.array;\n    var normals = geometry.attributes.normal.array;\n    var numPoints = coords.length / 3;\n    var numFaces = numPoints / 3;\n    var indices = geometry.getIndex();\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n      var idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n    var points1 = [];\n    var points2 = [];\n    var delta = this.smallDelta; // Reset segments mark\n\n    var numPointPairs = numPoints * numPoints;\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\n    var p0 = this.tempVector3_P0;\n    var p1 = this.tempVector3_P1;\n    var n0 = this.tempVector3_N0;\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\n\n    for (let i = 0; i < numFaces - 1; i++) {\n      var a1 = getVertexIndex(i, 0);\n      var b1 = getVertexIndex(i, 1);\n      var c1 = getVertexIndex(i, 2); // Assuming all 3 vertices have the same normal\n\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n      for (let j = i + 1; j < numFaces; j++) {\n        var a2 = getVertexIndex(j, 0);\n        var b2 = getVertexIndex(j, 1);\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\n\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        var coplanar = 1 - n0.dot(n1) < delta;\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    } // Transform the plane to object local space\n\n    var localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\n\n    for (let i = 0; i < numFaces; i++) {\n      var va = getVertexIndex(i, 0);\n      var vb = getVertexIndex(i, 1);\n      var vc = getVertexIndex(i, 2);\n      for (let segment = 0; segment < 3; segment++) {\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        var segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue; // The segment already has been processed in another face\n        // Mark segment as processed (also inverted segment)\n\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n        var mark0 = 0;\n        var d = localPlane.distanceToPoint(p0);\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n        var mark1 = 0;\n        var d = localPlane.distanceToPoint(p1);\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          // Intersection of segment with the plane\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          var intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n          if (intersection === undefined) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.');\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    } // Calculate debris mass (very fast and imprecise):\n\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\n\n    this.tempCM1.set(0, 0, 0);\n    var radius1 = 0;\n    var numPoints1 = points1.length;\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\n      this.tempCM1.divideScalar(numPoints1);\n      for (let i = 0; i < numPoints1; i++) {\n        var p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n      this.tempCM1.add(object.position);\n    }\n    this.tempCM2.set(0, 0, 0);\n    var radius2 = 0;\n    var numPoints2 = points2.length;\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\n      this.tempCM2.divideScalar(numPoints2);\n      for (let i = 0; i < numPoints2; i++) {\n        var p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n      this.tempCM2.add(object.position);\n    }\n    var object1 = null;\n    var object2 = null;\n    var numObjects = 0;\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n};\nConvexObjectBreaker.transformFreeVector = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n    y = v.y,\n    z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[4] * y + e[8] * z;\n  v.y = e[1] * x + e[5] * y + e[9] * z;\n  v.z = e[2] * x + e[6] * y + e[10] * z;\n  return v;\n};\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n    y = v.y,\n    z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z;\n  v.y = e[4] * x + e[5] * y + e[6] * z;\n  v.z = e[8] * x + e[9] * y + e[10] * z;\n  return v;\n};\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a tied (ordinary) vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n    y = v.y,\n    z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n  return v;\n};\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\n  var v1 = new Vector3();\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\n\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  };\n}();\nexport { ConvexObjectBreaker };","map":{"version":3,"names":["Line3","Plane","Vector3","Mesh","ConvexGeometry","ConvexObjectBreaker","minSizeForBreak","smallDelta","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","n","i","prototype","constructor","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","geometry","isBufferGeometry","console","error","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","coords","attributes","array","normals","numPoints","length","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","coplanar","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","segmentState","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","undefined","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","v1","resultPlane","referencePoint","coplanarPoint"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/misc/ConvexObjectBreaker.js"],"sourcesContent":["import { Line3, Plane, Vector3, Mesh } from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nvar ConvexObjectBreaker = function (minSizeForBreak, smallDelta) {\n  this.minSizeForBreak = minSizeForBreak || 1.4;\n  this.smallDelta = smallDelta || 0.0001;\n  this.tempLine1 = new Line3();\n  this.tempPlane1 = new Plane();\n  this.tempPlane2 = new Plane();\n  this.tempPlane_Cut = new Plane();\n  this.tempCM1 = new Vector3();\n  this.tempCM2 = new Vector3();\n  this.tempVector3 = new Vector3();\n  this.tempVector3_2 = new Vector3();\n  this.tempVector3_3 = new Vector3();\n  this.tempVector3_P0 = new Vector3();\n  this.tempVector3_P1 = new Vector3();\n  this.tempVector3_P2 = new Vector3();\n  this.tempVector3_N0 = new Vector3();\n  this.tempVector3_N1 = new Vector3();\n  this.tempVector3_AB = new Vector3();\n  this.tempVector3_CB = new Vector3();\n  this.tempResultObjects = {\n    object1: null,\n    object2: null\n  };\n  this.segments = [];\n  var n = 30 * 30;\n\n  for (let i = 0; i < n; i++) this.segments[i] = false;\n};\n\nConvexObjectBreaker.prototype = {\n  constructor: ConvexObjectBreaker,\n  prepareBreakableObject: function (object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n    if (!object.geometry.isBufferGeometry) {\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\n    }\n\n    var userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  },\n\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact: function (object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    var debris = [];\n    var tempPlane1 = this.tempPlane1;\n    var tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    var scope = this;\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n\n      var angle = Math.PI;\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\n\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\n\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      } // Perform the cut\n\n\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      var obj1 = scope.tempResultObjects.object1;\n      var obj2 = scope.tempResultObjects.object2;\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  },\n  cutByPlane: function (object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n    var geometry = object.geometry;\n    var coords = geometry.attributes.position.array;\n    var normals = geometry.attributes.normal.array;\n    var numPoints = coords.length / 3;\n    var numFaces = numPoints / 3;\n    var indices = geometry.getIndex();\n\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n      var idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n\n    var points1 = [];\n    var points2 = [];\n    var delta = this.smallDelta; // Reset segments mark\n\n    var numPointPairs = numPoints * numPoints;\n\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\n\n    var p0 = this.tempVector3_P0;\n    var p1 = this.tempVector3_P1;\n    var n0 = this.tempVector3_N0;\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\n\n    for (let i = 0; i < numFaces - 1; i++) {\n      var a1 = getVertexIndex(i, 0);\n      var b1 = getVertexIndex(i, 1);\n      var c1 = getVertexIndex(i, 2); // Assuming all 3 vertices have the same normal\n\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n\n      for (let j = i + 1; j < numFaces; j++) {\n        var a2 = getVertexIndex(j, 0);\n        var b2 = getVertexIndex(j, 1);\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\n\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        var coplanar = 1 - n0.dot(n1) < delta;\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    } // Transform the plane to object local space\n\n\n    var localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\n\n    for (let i = 0; i < numFaces; i++) {\n      var va = getVertexIndex(i, 0);\n      var vb = getVertexIndex(i, 1);\n      var vc = getVertexIndex(i, 2);\n\n      for (let segment = 0; segment < 3; segment++) {\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        var segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue; // The segment already has been processed in another face\n        // Mark segment as processed (also inverted segment)\n\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n        var mark0 = 0;\n        var d = localPlane.distanceToPoint(p0);\n\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n\n        var mark1 = 0;\n        var d = localPlane.distanceToPoint(p1);\n\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          // Intersection of segment with the plane\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          var intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n\n          if (intersection === undefined) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.');\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    } // Calculate debris mass (very fast and imprecise):\n\n\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\n\n    this.tempCM1.set(0, 0, 0);\n    var radius1 = 0;\n    var numPoints1 = points1.length;\n\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\n\n      this.tempCM1.divideScalar(numPoints1);\n\n      for (let i = 0; i < numPoints1; i++) {\n        var p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n\n      this.tempCM1.add(object.position);\n    }\n\n    this.tempCM2.set(0, 0, 0);\n    var radius2 = 0;\n    var numPoints2 = points2.length;\n\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\n\n      this.tempCM2.divideScalar(numPoints2);\n\n      for (let i = 0; i < numPoints2; i++) {\n        var p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n\n      this.tempCM2.add(object.position);\n    }\n\n    var object1 = null;\n    var object2 = null;\n    var numObjects = 0;\n\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n};\n\nConvexObjectBreaker.transformFreeVector = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[4] * y + e[8] * z;\n  v.y = e[1] * x + e[5] * y + e[9] * z;\n  v.z = e[2] * x + e[6] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z;\n  v.y = e[4] * x + e[5] * y + e[6] * z;\n  v.z = e[8] * x + e[9] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a tied (ordinary) vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n  return v;\n};\n\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\n  var v1 = new Vector3();\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\n\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  };\n}();\n\nexport { ConvexObjectBreaker };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}