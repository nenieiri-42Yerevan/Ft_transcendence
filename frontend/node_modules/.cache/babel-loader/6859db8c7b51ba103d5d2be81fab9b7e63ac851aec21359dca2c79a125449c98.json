{"ast":null,"code":"import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\nconst F_Schlick = new ShaderNode(inputs => {\n  const {\n    f0,\n    f90,\n    dotVH\n  } = inputs; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nconst BRDF_Lambert = new ShaderNode(inputs => {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nconst getDistanceAttenuation = new ShaderNode(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNL,\n    dotNV\n  } = inputs;\n  const a2 = pow2(alpha);\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\n\nconst D_GGX = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNH\n  } = inputs;\n  const a2 = pow2(alpha);\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nconst BRDF_GGX = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness\n  } = inputs;\n  const alpha = pow2(roughness); // UE4's roughness\n\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\n  const F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  const V = V_GGX_SmithCorrelated({\n    alpha,\n    dotNL,\n    dotNV\n  });\n  const D = D_GGX({\n    alpha,\n    dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nconst RE_Direct_Physical = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    lightColor,\n    directDiffuse,\n    directSpecular\n  } = inputs;\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  let irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness\n  })));\n});\nconst PhysicalLightingModel = new ShaderNode((inputs\n/*, builder*/) => {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };","map":{"version":3,"names":["ShaderNode","exp2","mul","sub","add","cond","pow","saturate","div","negate","and","greaterThan","pow2","sqrt","max","EPSILON","normalize","positionViewDirection","dot","transformedNormalView","addTo","diffuseColor","specularColor","roughness","F_Schlick","inputs","f0","f90","dotVH","fresnel","BRDF_Lambert","Math","PI","getDistanceAttenuation","lightDistance","cutoffDistance","decayExponent","V_GGX_SmithCorrelated","alpha","dotNL","dotNV","a2","gv","gl","D_GGX","dotNH","denom","BRDF_GGX","lightDirection","halfDir","F","V","D","RE_Direct_Physical","lightColor","directDiffuse","directSpecular","irradiance","rgb","PhysicalLightingModel"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/nodes/functions/BSDFs.js"],"sourcesContent":["import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\n\nconst F_Schlick = new ShaderNode(inputs => {\n  const {\n    f0,\n    f90,\n    dotVH\n  } = inputs; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nconst BRDF_Lambert = new ShaderNode(inputs => {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nconst getDistanceAttenuation = new ShaderNode(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNL,\n    dotNV\n  } = inputs;\n  const a2 = pow2(alpha);\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\n\nconst D_GGX = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNH\n  } = inputs;\n  const a2 = pow2(alpha);\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nconst BRDF_GGX = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness\n  } = inputs;\n  const alpha = pow2(roughness); // UE4's roughness\n\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\n  const F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  const V = V_GGX_SmithCorrelated({\n    alpha,\n    dotNL,\n    dotNV\n  });\n  const D = D_GGX({\n    alpha,\n    dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nconst RE_Direct_Physical = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    lightColor,\n    directDiffuse,\n    directSpecular\n  } = inputs;\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  let irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness\n  })));\n});\nconst PhysicalLightingModel = new ShaderNode((inputs\n/*, builder*/\n) => {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\n\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}