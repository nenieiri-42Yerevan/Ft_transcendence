{"ast":null,"code":"import { OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\nconst ParallaxBarrierEffect = function (renderer) {\n  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  const _scene = new Scene();\n  const _stereo = new StereoCamera();\n  const _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n  const _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n  const _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n  const _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'void main() {', '\tvec2 uv = vUv;', '\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {', '\t\tgl_FragColor = texture2D( mapLeft, uv );', '\t} else {', '\t\tgl_FragColor = texture2D( mapRight, uv );', '\t}', '}'].join('\\n')\n  });\n  const mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n  _scene.add(mesh);\n  this.setSize = (width, height) => {\n    renderer.setSize(width, height);\n    const pixelRatio = renderer.getPixelRatio();\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n  this.render = (scene, camera) => {\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n    _stereo.update(camera);\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n};\nexport { ParallaxBarrierEffect };","map":{"version":3,"names":["OrthographicCamera","Scene","StereoCamera","WebGLRenderTarget","ShaderMaterial","Mesh","PlaneGeometry","LinearFilter","NearestFilter","RGBAFormat","ParallaxBarrierEffect","renderer","_camera","_scene","_stereo","_params","minFilter","magFilter","format","_renderTargetL","_renderTargetR","_material","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","mesh","add","setSize","width","height","pixelRatio","getPixelRatio","render","scene","camera","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/effects/ParallaxBarrierEffect.js"],"sourcesContent":["import { OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\n\nconst ParallaxBarrierEffect = function (renderer) {\n  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  const _scene = new Scene();\n\n  const _stereo = new StereoCamera();\n\n  const _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n\n  const _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n\n  const _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n\n  const _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'void main() {', '\tvec2 uv = vUv;', '\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {', '\t\tgl_FragColor = texture2D( mapLeft, uv );', '\t} else {', '\t\tgl_FragColor = texture2D( mapRight, uv );', '\t}', '}'].join('\\n')\n  });\n\n  const mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n\n  _scene.add(mesh);\n\n  this.setSize = (width, height) => {\n    renderer.setSize(width, height);\n    const pixelRatio = renderer.getPixelRatio();\n\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n\n  this.render = (scene, camera) => {\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    _stereo.update(camera);\n\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n};\n\nexport { ParallaxBarrierEffect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}