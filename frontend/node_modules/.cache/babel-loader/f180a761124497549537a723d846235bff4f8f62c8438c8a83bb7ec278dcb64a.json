{"ast":null,"code":"import { Color, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from 'three';\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * var effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * var effect = new OutlineEffect( renderer );\n * var renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ]\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nconst OutlineEffect = function (renderer, parameters) {\n  parameters = parameters || {};\n  this.enabled = true;\n  const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n  const defaultColor = new Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0]);\n  const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n  const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false; // object.material.uuid -> outlineMaterial or\n  // object.material[ n ].uuid -> outlineMaterial\n  // save at the outline material creation and release\n  // if it's unused removeThresholdCount frames\n  // unless keepAlive is true.\n\n  const cache = {};\n  const removeThresholdCount = 60; // outlineMaterial.uuid -> object.material or\n  // outlineMaterial.uuid -> object.material[ n ]\n  // save before render and release after render.\n\n  const originalMaterials = {}; // object.uuid -> originalOnBeforeRender\n  // save before render and release after render.\n\n  const originalOnBeforeRenders = {}; //this.cache = cache;  // for debug\n\n  const uniformsOutline = {\n    outlineThickness: {\n      value: defaultThickness\n    },\n    outlineColor: {\n      value: defaultColor\n    },\n    outlineAlpha: {\n      value: defaultAlpha\n    }\n  };\n  const vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {', '\tfloat thickness = outlineThickness;', '\tconst float ratio = 1.0;',\n  // TODO: support outline thickness ratio for each vertex\n  '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n  // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n  '\tvec4 norm = normalize( pos - pos2 );', '\treturn pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '\t#include <uv_vertex>', '\t#include <beginnormal_vertex>', '\t#include <morphnormal_vertex>', '\t#include <skinbase_vertex>', '\t#include <skinnormal_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <displacementmap_vertex>', '\t#include <project_vertex>', '\tvec3 outlineNormal = - objectNormal;',\n  // the outline material is always rendered with BackSide\n  '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\t#include <fog_vertex>', '}'].join('\\n');\n  const fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '\t#include <clipping_planes_fragment>', '\t#include <logdepthbuf_fragment>', '\tgl_FragColor = vec4( outlineColor, outlineAlpha );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '\t#include <premultiplied_alpha_fragment>', '}'].join('\\n');\n  function createMaterial() {\n    return new ShaderMaterial({\n      type: 'OutlineEffect',\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], uniformsOutline]),\n      vertexShader,\n      fragmentShader,\n      side: BackSide\n    });\n  }\n  function getOutlineMaterialFromCache(originalMaterial) {\n    let data = cache[originalMaterial.uuid];\n    if (data === undefined) {\n      data = {\n        material: createMaterial(),\n        used: true,\n        keepAlive: defaultKeepAlive,\n        count: 0\n      };\n      cache[originalMaterial.uuid] = data;\n    }\n    data.used = true;\n    return data.material;\n  }\n  function getOutlineMaterial(originalMaterial) {\n    const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n    originalMaterials[outlineMaterial.uuid] = originalMaterial;\n    updateOutlineMaterial(outlineMaterial, originalMaterial);\n    return outlineMaterial;\n  }\n  function isCompatible(object) {\n    const geometry = object.geometry;\n    let hasNormals = false;\n    if (object.geometry !== undefined) {\n      if (geometry.isBufferGeometry) {\n        hasNormals = geometry.attributes.normal !== undefined;\n      } else {\n        hasNormals = true; // the renderer always produces a normal attribute for Geometry\n      }\n    }\n\n    return object.isMesh === true && object.material !== undefined && hasNormals === true;\n  }\n  function setOutlineMaterial(object) {\n    if (isCompatible(object) === false) return;\n    if (Array.isArray(object.material)) {\n      for (let i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = getOutlineMaterial(object.material[i]);\n      }\n    } else {\n      object.material = getOutlineMaterial(object.material);\n    }\n    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n    object.onBeforeRender = onBeforeRender;\n  }\n  function restoreOriginalMaterial(object) {\n    if (isCompatible(object) === false) return;\n    if (Array.isArray(object.material)) {\n      for (let i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = originalMaterials[object.material[i].uuid];\n      }\n    } else {\n      object.material = originalMaterials[object.material.uuid];\n    }\n    object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n  }\n  function onBeforeRender(renderer, scene, camera, geometry, material) {\n    const originalMaterial = originalMaterials[material.uuid]; // just in case\n\n    if (originalMaterial === undefined) return;\n    updateUniforms(material, originalMaterial);\n  }\n  function updateUniforms(material, originalMaterial) {\n    const outlineParameters = originalMaterial.userData.outlineParameters;\n    material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n    if (outlineParameters !== undefined) {\n      if (outlineParameters.thickness !== undefined) {\n        material.uniforms.outlineThickness.value = outlineParameters.thickness;\n      }\n      if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n      if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n    }\n    if (originalMaterial.displacementMap) {\n      material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n      material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n      material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n    }\n  }\n  function updateOutlineMaterial(material, originalMaterial) {\n    if (material.name === 'invisible') return;\n    const outlineParameters = originalMaterial.userData.outlineParameters;\n    material.skinning = originalMaterial.skinning;\n    material.morphTargets = originalMaterial.morphTargets;\n    material.morphNormals = originalMaterial.morphNormals;\n    material.fog = originalMaterial.fog;\n    material.toneMapped = originalMaterial.toneMapped;\n    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n    material.displacementMap = originalMaterial.displacementMap;\n    if (outlineParameters !== undefined) {\n      if (originalMaterial.visible === false) {\n        material.visible = false;\n      } else {\n        material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\n      }\n      material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;\n      if (outlineParameters.keepAlive !== undefined) {\n        cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      }\n    } else {\n      material.transparent = originalMaterial.transparent;\n      material.visible = originalMaterial.visible;\n    }\n    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n    if (originalMaterial.clippingPlanes) {\n      material.clipping = true;\n      material.clippingPlanes = originalMaterial.clippingPlanes;\n      material.clipIntersection = originalMaterial.clipIntersection;\n      material.clipShadows = originalMaterial.clipShadows;\n    }\n    material.version = originalMaterial.version; // update outline material if necessary\n  }\n\n  function cleanupCache() {\n    let keys; // clear originialMaterials\n\n    keys = Object.keys(originalMaterials);\n    for (let i = 0, il = keys.length; i < il; i++) {\n      originalMaterials[keys[i]] = undefined;\n    } // clear originalOnBeforeRenders\n\n    keys = Object.keys(originalOnBeforeRenders);\n    for (let i = 0, il = keys.length; i < il; i++) {\n      originalOnBeforeRenders[keys[i]] = undefined;\n    } // remove unused outlineMaterial from cache\n\n    keys = Object.keys(cache);\n    for (let i = 0, il = keys.length; i < il; i++) {\n      const key = keys[i];\n      if (cache[key].used === false) {\n        cache[key].count++;\n        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n          delete cache[key];\n        }\n      } else {\n        cache[key].used = false;\n        cache[key].count = 0;\n      }\n    }\n  }\n  this.render = function (scene, camera) {\n    let renderTarget;\n    let forceClear = false;\n    if (arguments[2] !== undefined) {\n      console.warn('THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');\n      renderTarget = arguments[2];\n    }\n    if (arguments[3] !== undefined) {\n      console.warn('THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.');\n      forceClear = arguments[3];\n    }\n    if (renderTarget !== undefined) renderer.setRenderTarget(renderTarget);\n    if (forceClear) renderer.clear();\n    if (this.enabled === false) {\n      renderer.render(scene, camera);\n      return;\n    }\n    const currentAutoClear = renderer.autoClear;\n    renderer.autoClear = this.autoClear;\n    renderer.render(scene, camera);\n    renderer.autoClear = currentAutoClear;\n    this.renderOutline(scene, camera);\n  };\n  this.renderOutline = (scene, camera) => {\n    const currentAutoClear = renderer.autoClear;\n    const currentSceneAutoUpdate = scene.autoUpdate;\n    const currentSceneBackground = scene.background;\n    const currentShadowMapEnabled = renderer.shadowMap.enabled;\n    scene.autoUpdate = false;\n    scene.background = null;\n    renderer.autoClear = false;\n    renderer.shadowMap.enabled = false;\n    scene.traverse(setOutlineMaterial);\n    renderer.render(scene, camera);\n    scene.traverse(restoreOriginalMaterial);\n    cleanupCache();\n    scene.autoUpdate = currentSceneAutoUpdate;\n    scene.background = currentSceneBackground;\n    renderer.autoClear = currentAutoClear;\n    renderer.shadowMap.enabled = currentShadowMapEnabled;\n  };\n  /*\n   * See #9918\n   *\n   * The following property copies and wrapper methods enable\n   * OutlineEffect to be called from other *Effect, like\n   *\n   * effect = new StereoEffect( new OutlineEffect( renderer ) );\n   *\n   * function render () {\n   *\n   * \teffect.render( scene, camera );\n   *\n   * }\n   */\n\n  this.autoClear = renderer.autoClear;\n  this.domElement = renderer.domElement;\n  this.shadowMap = renderer.shadowMap;\n  this.clear = (color, depth, stencil) => {\n    renderer.clear(color, depth, stencil);\n  };\n  this.getPixelRatio = () => renderer.getPixelRatio();\n  this.setPixelRatio = value => {\n    renderer.setPixelRatio(value);\n  };\n  this.getSize = target => renderer.getSize(target);\n  this.setSize = (width, height, updateStyle) => {\n    renderer.setSize(width, height, updateStyle);\n  };\n  this.setViewport = (x, y, width, height) => {\n    renderer.setViewport(x, y, width, height);\n  };\n  this.setScissor = (x, y, width, height) => {\n    renderer.setScissor(x, y, width, height);\n  };\n  this.setScissorTest = boolean => {\n    renderer.setScissorTest(boolean);\n  };\n  this.setRenderTarget = renderTarget => {\n    renderer.setRenderTarget(renderTarget);\n  };\n};\nexport { OutlineEffect };","map":{"version":3,"names":["Color","ShaderMaterial","UniformsUtils","UniformsLib","BackSide","OutlineEffect","renderer","parameters","enabled","defaultThickness","undefined","defaultColor","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","createMaterial","type","uniforms","merge","side","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","used","keepAlive","count","getOutlineMaterial","outlineMaterial","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","isBufferGeometry","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","length","onBeforeRender","restoreOriginalMaterial","scene","camera","updateUniforms","outlineParameters","userData","opacity","thickness","color","alpha","displacementMap","displacementScale","displacementBias","name","skinning","morphTargets","morphNormals","fog","toneMapped","premultipliedAlpha","visible","transparent","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","cleanupCache","keys","Object","key","render","renderTarget","forceClear","arguments","console","warn","setRenderTarget","clear","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","autoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","domElement","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/effects/OutlineEffect.js"],"sourcesContent":["import { Color, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from 'three';\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * var effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * var effect = new OutlineEffect( renderer );\n * var renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ]\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nconst OutlineEffect = function (renderer, parameters) {\n  parameters = parameters || {};\n  this.enabled = true;\n  const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n  const defaultColor = new Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0]);\n  const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n  const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false; // object.material.uuid -> outlineMaterial or\n  // object.material[ n ].uuid -> outlineMaterial\n  // save at the outline material creation and release\n  // if it's unused removeThresholdCount frames\n  // unless keepAlive is true.\n\n  const cache = {};\n  const removeThresholdCount = 60; // outlineMaterial.uuid -> object.material or\n  // outlineMaterial.uuid -> object.material[ n ]\n  // save before render and release after render.\n\n  const originalMaterials = {}; // object.uuid -> originalOnBeforeRender\n  // save before render and release after render.\n\n  const originalOnBeforeRenders = {}; //this.cache = cache;  // for debug\n\n  const uniformsOutline = {\n    outlineThickness: {\n      value: defaultThickness\n    },\n    outlineColor: {\n      value: defaultColor\n    },\n    outlineAlpha: {\n      value: defaultAlpha\n    }\n  };\n  const vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {', '\tfloat thickness = outlineThickness;', '\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n  '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );', // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n  '\tvec4 norm = normalize( pos - pos2 );', '\treturn pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '\t#include <uv_vertex>', '\t#include <beginnormal_vertex>', '\t#include <morphnormal_vertex>', '\t#include <skinbase_vertex>', '\t#include <skinnormal_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <displacementmap_vertex>', '\t#include <project_vertex>', '\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n  '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\t#include <fog_vertex>', '}'].join('\\n');\n  const fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '\t#include <clipping_planes_fragment>', '\t#include <logdepthbuf_fragment>', '\tgl_FragColor = vec4( outlineColor, outlineAlpha );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '\t#include <premultiplied_alpha_fragment>', '}'].join('\\n');\n\n  function createMaterial() {\n    return new ShaderMaterial({\n      type: 'OutlineEffect',\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], uniformsOutline]),\n      vertexShader,\n      fragmentShader,\n      side: BackSide\n    });\n  }\n\n  function getOutlineMaterialFromCache(originalMaterial) {\n    let data = cache[originalMaterial.uuid];\n\n    if (data === undefined) {\n      data = {\n        material: createMaterial(),\n        used: true,\n        keepAlive: defaultKeepAlive,\n        count: 0\n      };\n      cache[originalMaterial.uuid] = data;\n    }\n\n    data.used = true;\n    return data.material;\n  }\n\n  function getOutlineMaterial(originalMaterial) {\n    const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n    originalMaterials[outlineMaterial.uuid] = originalMaterial;\n    updateOutlineMaterial(outlineMaterial, originalMaterial);\n    return outlineMaterial;\n  }\n\n  function isCompatible(object) {\n    const geometry = object.geometry;\n    let hasNormals = false;\n\n    if (object.geometry !== undefined) {\n      if (geometry.isBufferGeometry) {\n        hasNormals = geometry.attributes.normal !== undefined;\n      } else {\n        hasNormals = true; // the renderer always produces a normal attribute for Geometry\n      }\n    }\n\n    return object.isMesh === true && object.material !== undefined && hasNormals === true;\n  }\n\n  function setOutlineMaterial(object) {\n    if (isCompatible(object) === false) return;\n\n    if (Array.isArray(object.material)) {\n      for (let i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = getOutlineMaterial(object.material[i]);\n      }\n    } else {\n      object.material = getOutlineMaterial(object.material);\n    }\n\n    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n    object.onBeforeRender = onBeforeRender;\n  }\n\n  function restoreOriginalMaterial(object) {\n    if (isCompatible(object) === false) return;\n\n    if (Array.isArray(object.material)) {\n      for (let i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = originalMaterials[object.material[i].uuid];\n      }\n    } else {\n      object.material = originalMaterials[object.material.uuid];\n    }\n\n    object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n  }\n\n  function onBeforeRender(renderer, scene, camera, geometry, material) {\n    const originalMaterial = originalMaterials[material.uuid]; // just in case\n\n    if (originalMaterial === undefined) return;\n    updateUniforms(material, originalMaterial);\n  }\n\n  function updateUniforms(material, originalMaterial) {\n    const outlineParameters = originalMaterial.userData.outlineParameters;\n    material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n    if (outlineParameters !== undefined) {\n      if (outlineParameters.thickness !== undefined) {\n        material.uniforms.outlineThickness.value = outlineParameters.thickness;\n      }\n\n      if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n      if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n    }\n\n    if (originalMaterial.displacementMap) {\n      material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n      material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n      material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n    }\n  }\n\n  function updateOutlineMaterial(material, originalMaterial) {\n    if (material.name === 'invisible') return;\n    const outlineParameters = originalMaterial.userData.outlineParameters;\n    material.skinning = originalMaterial.skinning;\n    material.morphTargets = originalMaterial.morphTargets;\n    material.morphNormals = originalMaterial.morphNormals;\n    material.fog = originalMaterial.fog;\n    material.toneMapped = originalMaterial.toneMapped;\n    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n    material.displacementMap = originalMaterial.displacementMap;\n\n    if (outlineParameters !== undefined) {\n      if (originalMaterial.visible === false) {\n        material.visible = false;\n      } else {\n        material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\n      }\n\n      material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;\n\n      if (outlineParameters.keepAlive !== undefined) {\n        cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      }\n    } else {\n      material.transparent = originalMaterial.transparent;\n      material.visible = originalMaterial.visible;\n    }\n\n    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n\n    if (originalMaterial.clippingPlanes) {\n      material.clipping = true;\n      material.clippingPlanes = originalMaterial.clippingPlanes;\n      material.clipIntersection = originalMaterial.clipIntersection;\n      material.clipShadows = originalMaterial.clipShadows;\n    }\n\n    material.version = originalMaterial.version; // update outline material if necessary\n  }\n\n  function cleanupCache() {\n    let keys; // clear originialMaterials\n\n    keys = Object.keys(originalMaterials);\n\n    for (let i = 0, il = keys.length; i < il; i++) {\n      originalMaterials[keys[i]] = undefined;\n    } // clear originalOnBeforeRenders\n\n\n    keys = Object.keys(originalOnBeforeRenders);\n\n    for (let i = 0, il = keys.length; i < il; i++) {\n      originalOnBeforeRenders[keys[i]] = undefined;\n    } // remove unused outlineMaterial from cache\n\n\n    keys = Object.keys(cache);\n\n    for (let i = 0, il = keys.length; i < il; i++) {\n      const key = keys[i];\n\n      if (cache[key].used === false) {\n        cache[key].count++;\n\n        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n          delete cache[key];\n        }\n      } else {\n        cache[key].used = false;\n        cache[key].count = 0;\n      }\n    }\n  }\n\n  this.render = function (scene, camera) {\n    let renderTarget;\n    let forceClear = false;\n\n    if (arguments[2] !== undefined) {\n      console.warn('THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');\n      renderTarget = arguments[2];\n    }\n\n    if (arguments[3] !== undefined) {\n      console.warn('THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.');\n      forceClear = arguments[3];\n    }\n\n    if (renderTarget !== undefined) renderer.setRenderTarget(renderTarget);\n    if (forceClear) renderer.clear();\n\n    if (this.enabled === false) {\n      renderer.render(scene, camera);\n      return;\n    }\n\n    const currentAutoClear = renderer.autoClear;\n    renderer.autoClear = this.autoClear;\n    renderer.render(scene, camera);\n    renderer.autoClear = currentAutoClear;\n    this.renderOutline(scene, camera);\n  };\n\n  this.renderOutline = (scene, camera) => {\n    const currentAutoClear = renderer.autoClear;\n    const currentSceneAutoUpdate = scene.autoUpdate;\n    const currentSceneBackground = scene.background;\n    const currentShadowMapEnabled = renderer.shadowMap.enabled;\n    scene.autoUpdate = false;\n    scene.background = null;\n    renderer.autoClear = false;\n    renderer.shadowMap.enabled = false;\n    scene.traverse(setOutlineMaterial);\n    renderer.render(scene, camera);\n    scene.traverse(restoreOriginalMaterial);\n    cleanupCache();\n    scene.autoUpdate = currentSceneAutoUpdate;\n    scene.background = currentSceneBackground;\n    renderer.autoClear = currentAutoClear;\n    renderer.shadowMap.enabled = currentShadowMapEnabled;\n  };\n  /*\n   * See #9918\n   *\n   * The following property copies and wrapper methods enable\n   * OutlineEffect to be called from other *Effect, like\n   *\n   * effect = new StereoEffect( new OutlineEffect( renderer ) );\n   *\n   * function render () {\n   *\n   * \teffect.render( scene, camera );\n   *\n   * }\n   */\n\n\n  this.autoClear = renderer.autoClear;\n  this.domElement = renderer.domElement;\n  this.shadowMap = renderer.shadowMap;\n\n  this.clear = (color, depth, stencil) => {\n    renderer.clear(color, depth, stencil);\n  };\n\n  this.getPixelRatio = () => renderer.getPixelRatio();\n\n  this.setPixelRatio = value => {\n    renderer.setPixelRatio(value);\n  };\n\n  this.getSize = target => renderer.getSize(target);\n\n  this.setSize = (width, height, updateStyle) => {\n    renderer.setSize(width, height, updateStyle);\n  };\n\n  this.setViewport = (x, y, width, height) => {\n    renderer.setViewport(x, y, width, height);\n  };\n\n  this.setScissor = (x, y, width, height) => {\n    renderer.setScissor(x, y, width, height);\n  };\n\n  this.setScissorTest = boolean => {\n    renderer.setScissorTest(boolean);\n  };\n\n  this.setRenderTarget = renderTarget => {\n    renderer.setRenderTarget(renderTarget);\n  };\n};\n\nexport { OutlineEffect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}