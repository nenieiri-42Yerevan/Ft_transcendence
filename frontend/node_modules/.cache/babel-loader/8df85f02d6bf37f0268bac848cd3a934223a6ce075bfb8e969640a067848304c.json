{"ast":null,"code":"import { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping, Data3DTexture } from 'three';\n\n// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\nclass LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('text');\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str.replace(/^#.*?(\\n|\\r)/gm, '').replace(/^\\s*?(\\n|\\r)/gm, '').trim();\n    const lines = str.split(/[\\n\\r]+/g); // first line is the positions on the grid that are provided by the LUT\n\n    const gridLines = lines[0].trim().split(/\\s+/g).map(e => parseFloat(e));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.');\n      }\n    }\n    const dataArray = new Array(size * size * size * 4);\n    let index = 0;\n    let maxOutputValue = 0.0;\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      const r = parseFloat(split[0]);\n      const g = parseFloat(split[1]);\n      const b = parseFloat(split[2]);\n      maxOutputValue = Math.max(maxOutputValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / (size * size)) % size; // b grows first, then g, then r\n\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n      dataArray[4 * pixelIndex + 0] = r;\n      dataArray[4 * pixelIndex + 1] = g;\n      dataArray[4 * pixelIndex + 2] = b;\n      dataArray[4 * pixelIndex + 3] = 1.0;\n      index += 1;\n    } // Find the apparent bit depth of the stored RGB values and map the\n    // values to [ 0, 255 ].\n\n    const bits = Math.ceil(Math.log2(maxOutputValue));\n    const maxBitValue = Math.pow(2.0, bits);\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0];\n      const g = dataArray[i + 1];\n      const b = dataArray[i + 2];\n      dataArray[i + 0] = 255 * r / maxBitValue; // r\n\n      dataArray[i + 1] = 255 * g / maxBitValue; // g\n\n      dataArray[i + 2] = 255 * b / maxBitValue; // b\n    }\n\n    const data = new Uint8Array(dataArray);\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.format = RGBAFormat;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.format = RGBAFormat;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      size,\n      texture,\n      texture3D\n    };\n  }\n}\nexport { LUT3dlLoader };","map":{"version":3,"names":["Loader","FileLoader","DataTexture","RGBAFormat","UnsignedByteType","LinearFilter","ClampToEdgeWrapping","Data3DTexture","LUT3dlLoader","load","url","onLoad","onProgress","onError","loader","manager","setPath","path","setResponseType","text","parse","e","console","error","itemError","str","replace","trim","lines","split","gridLines","map","parseFloat","gridStep","size","length","i","l","Error","dataArray","Array","index","maxOutputValue","line","r","g","b","Math","max","bLayer","gLayer","floor","rLayer","pixelIndex","bits","ceil","log2","maxBitValue","pow","data","Uint8Array","texture","image","width","height","format","type","magFilter","minFilter","wrapS","wrapT","generateMipmaps","needsUpdate","texture3D","depth","wrapR"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/LUT3dlLoader.js"],"sourcesContent":["import { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping, Data3DTexture } from 'three';\n\n// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\nclass LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('text');\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str.replace(/^#.*?(\\n|\\r)/gm, '').replace(/^\\s*?(\\n|\\r)/gm, '').trim();\n    const lines = str.split(/[\\n\\r]+/g); // first line is the positions on the grid that are provided by the LUT\n\n    const gridLines = lines[0].trim().split(/\\s+/g).map(e => parseFloat(e));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.');\n      }\n    }\n\n    const dataArray = new Array(size * size * size * 4);\n    let index = 0;\n    let maxOutputValue = 0.0;\n\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      const r = parseFloat(split[0]);\n      const g = parseFloat(split[1]);\n      const b = parseFloat(split[2]);\n      maxOutputValue = Math.max(maxOutputValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / (size * size)) % size; // b grows first, then g, then r\n\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n      dataArray[4 * pixelIndex + 0] = r;\n      dataArray[4 * pixelIndex + 1] = g;\n      dataArray[4 * pixelIndex + 2] = b;\n      dataArray[4 * pixelIndex + 3] = 1.0;\n      index += 1;\n    } // Find the apparent bit depth of the stored RGB values and map the\n    // values to [ 0, 255 ].\n\n\n    const bits = Math.ceil(Math.log2(maxOutputValue));\n    const maxBitValue = Math.pow(2.0, bits);\n\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0];\n      const g = dataArray[i + 1];\n      const b = dataArray[i + 2];\n      dataArray[i + 0] = 255 * r / maxBitValue; // r\n\n      dataArray[i + 1] = 255 * g / maxBitValue; // g\n\n      dataArray[i + 2] = 255 * b / maxBitValue; // b\n    }\n\n    const data = new Uint8Array(dataArray);\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.format = RGBAFormat;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.format = RGBAFormat;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      size,\n      texture,\n      texture3D\n    };\n  }\n\n}\n\nexport { LUT3dlLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}