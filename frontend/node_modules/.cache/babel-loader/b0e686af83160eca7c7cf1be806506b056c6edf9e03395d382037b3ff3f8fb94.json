{"ast":null,"code":"import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function (adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );',\n    //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;',\n    // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));',\n    // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function () {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n\n  setAdaptive: function (adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function (rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function (minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function (maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function (avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function (middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function () {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\nexport { AdaptiveToneMappingPass };","map":{"version":3,"names":["UniformsUtils","ShaderMaterial","NoBlending","WebGLRenderTarget","LinearMipmapLinearFilter","MeshBasicMaterial","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","adaptive","resolution","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","console","error","copyShader","copyUniforms","clone","uniforms","materialCopy","vertexShader","fragmentShader","blending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","join","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","prototype","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","pars","minFilter","magFilter","format","name","generateMipmaps","luminanceMap","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js"],"sourcesContent":["import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function (adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function () {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function (adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function (rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function (minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function (maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function (avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function (middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function () {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\n\nexport { AdaptiveToneMappingPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}