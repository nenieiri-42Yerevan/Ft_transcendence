{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass } from './Pass.js';\nclass MaskPass extends Pass {\n  constructor(scene, camera) {\n    super();\n    _defineProperty(this, \"scene\", void 0);\n    _defineProperty(this, \"camera\", void 0);\n    _defineProperty(this, \"inverse\", void 0);\n    this.scene = scene;\n    this.camera = camera;\n    this.clear = true;\n    this.needsSwap = false;\n    this.inverse = false;\n  }\n  render(renderer, writeBuffer, readBuffer) {\n    const context = renderer.getContext();\n    const state = renderer.state; // don't update color or depth\n\n    state.buffers.color.setMask(false);\n    state.buffers.depth.setMask(false); // lock buffers\n\n    state.buffers.color.setLocked(true);\n    state.buffers.depth.setLocked(true); // set up stencil\n\n    let writeValue, clearValue;\n    if (this.inverse) {\n      writeValue = 0;\n      clearValue = 1;\n    } else {\n      writeValue = 1;\n      clearValue = 0;\n    }\n    state.buffers.stencil.setTest(true);\n    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n    state.buffers.stencil.setClear(clearValue);\n    state.buffers.stencil.setLocked(true); // draw into the stencil buffer\n\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(writeBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering\n\n    state.buffers.color.setLocked(false);\n    state.buffers.depth.setLocked(false); // only render where stencil is set to 1\n\n    state.buffers.stencil.setLocked(false);\n    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n\n    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n    state.buffers.stencil.setLocked(true);\n  }\n}\nclass ClearMaskPass extends Pass {\n  constructor() {\n    super();\n    this.needsSwap = false;\n  }\n  render(renderer) {\n    renderer.state.buffers.stencil.setLocked(false);\n    renderer.state.buffers.stencil.setTest(false);\n  }\n}\nexport { ClearMaskPass, MaskPass };","map":{"version":3,"names":["_defineProperty","Pass","MaskPass","constructor","scene","camera","clear","needsSwap","inverse","render","renderer","writeBuffer","readBuffer","context","getContext","state","buffers","color","setMask","depth","setLocked","writeValue","clearValue","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","setRenderTarget","EQUAL","KEEP","ClearMaskPass"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/postprocessing/MaskPass.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass } from './Pass.js';\n\nclass MaskPass extends Pass {\n  constructor(scene, camera) {\n    super();\n\n    _defineProperty(this, \"scene\", void 0);\n\n    _defineProperty(this, \"camera\", void 0);\n\n    _defineProperty(this, \"inverse\", void 0);\n\n    this.scene = scene;\n    this.camera = camera;\n    this.clear = true;\n    this.needsSwap = false;\n    this.inverse = false;\n  }\n\n  render(renderer, writeBuffer, readBuffer) {\n    const context = renderer.getContext();\n    const state = renderer.state; // don't update color or depth\n\n    state.buffers.color.setMask(false);\n    state.buffers.depth.setMask(false); // lock buffers\n\n    state.buffers.color.setLocked(true);\n    state.buffers.depth.setLocked(true); // set up stencil\n\n    let writeValue, clearValue;\n\n    if (this.inverse) {\n      writeValue = 0;\n      clearValue = 1;\n    } else {\n      writeValue = 1;\n      clearValue = 0;\n    }\n\n    state.buffers.stencil.setTest(true);\n    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n    state.buffers.stencil.setClear(clearValue);\n    state.buffers.stencil.setLocked(true); // draw into the stencil buffer\n\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(writeBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering\n\n    state.buffers.color.setLocked(false);\n    state.buffers.depth.setLocked(false); // only render where stencil is set to 1\n\n    state.buffers.stencil.setLocked(false);\n    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n\n    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n    state.buffers.stencil.setLocked(true);\n  }\n\n}\n\nclass ClearMaskPass extends Pass {\n  constructor() {\n    super();\n    this.needsSwap = false;\n  }\n\n  render(renderer) {\n    renderer.state.buffers.stencil.setLocked(false);\n    renderer.state.buffers.stencil.setTest(false);\n  }\n\n}\n\nexport { ClearMaskPass, MaskPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}