{"ast":null,"code":"import { Loader, FileLoader, Vector3, DataTexture, UnsignedByteType, LinearFilter, ClampToEdgeWrapping, Data3DTexture } from 'three';\n\n// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf\nclass LUTCubeLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('text');\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(str) {\n    // Remove empty lines and comments\n    str = str.replace(/^#.*?(\\n|\\r)/gm, '').replace(/^\\s*?(\\n|\\r)/gm, '').trim();\n    let title = null;\n    let size = null;\n    const domainMin = new Vector3(0, 0, 0);\n    const domainMax = new Vector3(1, 1, 1);\n    const lines = str.split(/[\\n\\r]+/g);\n    let data = null;\n    let currIndex = 0;\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      switch (split[0]) {\n        case 'TITLE':\n          title = line.substring(7, line.length - 1);\n          break;\n        case 'LUT_3D_SIZE':\n          // TODO: A .CUBE LUT file specifies floating point values and could be represented with\n          // more precision than can be captured with Uint8Array.\n          const sizeToken = split[1];\n          size = parseFloat(sizeToken);\n          data = new Uint8Array(size * size * size * 4);\n          break;\n        case 'DOMAIN_MIN':\n          domainMin.x = parseFloat(split[1]);\n          domainMin.y = parseFloat(split[2]);\n          domainMin.z = parseFloat(split[3]);\n          break;\n        case 'DOMAIN_MAX':\n          domainMax.x = parseFloat(split[1]);\n          domainMax.y = parseFloat(split[2]);\n          domainMax.z = parseFloat(split[3]);\n          break;\n        default:\n          const r = parseFloat(split[0]);\n          const g = parseFloat(split[1]);\n          const b = parseFloat(split[2]);\n          if (r > 1.0 || r < 0.0 || g > 1.0 || g < 0.0 || b > 1.0 || b < 0.0) {\n            throw new Error('LUTCubeLoader : Non normalized values not supported.');\n          }\n          data[currIndex + 0] = r * 255;\n          data[currIndex + 1] = g * 255;\n          data[currIndex + 2] = b * 255;\n          data[currIndex + 3] = 255;\n          currIndex += 4;\n      }\n    }\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      title,\n      size,\n      domainMin,\n      domainMax,\n      texture,\n      texture3D\n    };\n  }\n}\nexport { LUTCubeLoader };","map":{"version":3,"names":["Loader","FileLoader","Vector3","DataTexture","UnsignedByteType","LinearFilter","ClampToEdgeWrapping","Data3DTexture","LUTCubeLoader","load","url","onLoad","onProgress","onError","loader","manager","setPath","path","setResponseType","text","parse","e","console","error","itemError","str","replace","trim","title","size","domainMin","domainMax","lines","split","data","currIndex","i","l","length","line","substring","sizeToken","parseFloat","Uint8Array","x","y","z","r","g","b","Error","texture","image","width","height","type","magFilter","minFilter","wrapS","wrapT","generateMipmaps","needsUpdate","texture3D","depth","wrapR"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/LUTCubeLoader.js"],"sourcesContent":["import { Loader, FileLoader, Vector3, DataTexture, UnsignedByteType, LinearFilter, ClampToEdgeWrapping, Data3DTexture } from 'three';\n\n// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf\nclass LUTCubeLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('text');\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(str) {\n    // Remove empty lines and comments\n    str = str.replace(/^#.*?(\\n|\\r)/gm, '').replace(/^\\s*?(\\n|\\r)/gm, '').trim();\n    let title = null;\n    let size = null;\n    const domainMin = new Vector3(0, 0, 0);\n    const domainMax = new Vector3(1, 1, 1);\n    const lines = str.split(/[\\n\\r]+/g);\n    let data = null;\n    let currIndex = 0;\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n\n      switch (split[0]) {\n        case 'TITLE':\n          title = line.substring(7, line.length - 1);\n          break;\n\n        case 'LUT_3D_SIZE':\n          // TODO: A .CUBE LUT file specifies floating point values and could be represented with\n          // more precision than can be captured with Uint8Array.\n          const sizeToken = split[1];\n          size = parseFloat(sizeToken);\n          data = new Uint8Array(size * size * size * 4);\n          break;\n\n        case 'DOMAIN_MIN':\n          domainMin.x = parseFloat(split[1]);\n          domainMin.y = parseFloat(split[2]);\n          domainMin.z = parseFloat(split[3]);\n          break;\n\n        case 'DOMAIN_MAX':\n          domainMax.x = parseFloat(split[1]);\n          domainMax.y = parseFloat(split[2]);\n          domainMax.z = parseFloat(split[3]);\n          break;\n\n        default:\n          const r = parseFloat(split[0]);\n          const g = parseFloat(split[1]);\n          const b = parseFloat(split[2]);\n\n          if (r > 1.0 || r < 0.0 || g > 1.0 || g < 0.0 || b > 1.0 || b < 0.0) {\n            throw new Error('LUTCubeLoader : Non normalized values not supported.');\n          }\n\n          data[currIndex + 0] = r * 255;\n          data[currIndex + 1] = g * 255;\n          data[currIndex + 2] = b * 255;\n          data[currIndex + 3] = 255;\n          currIndex += 4;\n      }\n    }\n\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      title,\n      size,\n      domainMin,\n      domainMax,\n      texture,\n      texture3D\n    };\n  }\n\n}\n\nexport { LUTCubeLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}