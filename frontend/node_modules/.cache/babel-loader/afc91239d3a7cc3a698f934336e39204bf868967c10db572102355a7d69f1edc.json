{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { createToken, Lexer, CstParser } from 'chevrotain';\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data, path) {\n    const nodeMap = {};\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n      const lexingResult = lexer.lex(data);\n      parser.input = lexingResult.tokens; // parsing\n\n      const cstOutput = parser.vrml();\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error('THREE.VRMLLoader: Parsing errors detected.');\n      } // actions\n\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform',\n      // grouping nodes\n      'Inline', 'LOD', 'Switch',\n      // special groups\n      'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo',\n      // common nodes\n      'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor',\n      // sensors\n      'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere',\n      // geometries\n      'Color', 'Coordinate', 'Normal', 'TextureCoordinate',\n      // geometric properties\n      'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform',\n      // appearance\n      'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator',\n      // interpolators\n      'Background', 'Fog', 'NavigationInfo', 'Viewpoint',\n      // bindable nodes\n      'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]; //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier\n      }); //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({\n        name: 'HexLiteral',\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: 'NumberLiteral',\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: 'TrueLiteral',\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: 'FalseLiteral',\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: 'NullLiteral',\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: 'LSquare',\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: 'RSquare',\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: 'LCurly',\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: 'RCurly',\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n      }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n      });\n\n      const tokens = [WhiteSpace,\n      // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n      // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n      return {\n        tokens: tokens,\n        tokenVocabulary: tokenVocabulary\n      };\n    }\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data.nodes.push(this.visit(node));\n          }\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data.routes.push(this.visit(route));\n            }\n          }\n          return data;\n        },\n        version: function (ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data.fields.push(this.visit(field));\n            }\n          } // DEF\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0]);\n          }\n          return data;\n        },\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result; // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          } // MFValue\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n          data.type = result.type;\n          data.values = result.values;\n          return data;\n        },\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function (ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        },\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data;\n        }\n      });\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n        if (ctx.node) {\n          field.type = 'node';\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n        if (ctx.use) {\n          field.type = 'use';\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n        if (ctx.StringLiteral) {\n          field.type = 'string';\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n          }\n        }\n        if (ctx.NumberLiteral) {\n          field.type = 'number';\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n        if (ctx.HexLiteral) {\n          field.type = 'hex';\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean';\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === 'TRUE') field.values.push(true);\n          }\n        }\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean';\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === 'FALSE') field.values.push(false);\n          }\n        }\n        if (ctx.NullLiteral) {\n          field.type = 'null';\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n        return field;\n      }\n      return new VRMLToASTVisitor();\n    }\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n      const nodes = tree.nodes;\n      const scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      } // second iteration: build nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene.add(object);\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n      }\n      return scene;\n    }\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        if (field.type === 'node') {\n          const fieldValues = field.values;\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n    function getNode(node) {\n      // handle case where a node refers to a different one\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n      if (node.build !== undefined) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    } // node builder\n\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node);\n          break;\n        case 'Background':\n          build = buildBackgroundNode(node);\n          break;\n        case 'Shape':\n          build = buildShapeNode(node);\n          break;\n        case 'Appearance':\n          build = buildAppearanceNode(node);\n          break;\n        case 'Material':\n          build = buildMaterialNode(node);\n          break;\n        case 'ImageTexture':\n          build = buildImageTextureNode(node);\n          break;\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node);\n          break;\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node);\n          break;\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node);\n          break;\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node);\n          break;\n        case 'PointSet':\n          build = buildPointSetNode(node);\n          break;\n        case 'Box':\n          build = buildBoxNode(node);\n          break;\n        case 'Cone':\n          build = buildConeNode(node);\n          break;\n        case 'Cylinder':\n          build = buildCylinderNode(node);\n          break;\n        case 'Sphere':\n          build = buildSphereNode(node);\n          break;\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node);\n          break;\n        case 'Extrusion':\n          build = buildExtrusionNode(node);\n          break;\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node);\n          break;\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node);\n          break;\n        case 'Anchor':\n        case 'Billboard':\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n        case 'Text':\n        case 'FontStyle':\n        case 'MovieTexture':\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break;\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n          break;\n      }\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF;\n      }\n      return build;\n    }\n    function buildGroupingNode(node) {\n      const object = new Group(); //\n\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break;\n          case 'bboxSize':\n            // field not supported\n            break;\n          case 'center':\n            // field not supported\n            break;\n          case 'children':\n            parseFieldChildren(fieldValues, object);\n            break;\n          case 'collide':\n            // field not supported\n            break;\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'scaleOrientation':\n            // field not supported\n            break;\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'proxy':\n            // field not supported\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return object;\n    }\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues;\n            break;\n          case 'groundColor':\n            groundColor = fieldValues;\n            break;\n          case 'backUrl':\n            // field not supported\n            break;\n          case 'bottomUrl':\n            // field not supported\n            break;\n          case 'frontUrl':\n            // field not supported\n            break;\n          case 'leftUrl':\n            // field not supported\n            break;\n          case 'rightUrl':\n            // field not supported\n            break;\n          case 'topUrl':\n            // field not supported\n            break;\n          case 'skyAngle':\n            skyAngle = fieldValues;\n            break;\n          case 'skyColor':\n            skyColor = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const radius = 10000; // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      } // ground\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      } // render background group first\n\n      group.renderOrder = -Infinity;\n      return group;\n    }\n    function buildShapeNode(node) {\n      const fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({\n        color: 0x000000\n      });\n      let geometry;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n            break;\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build 3D object\n\n      let object;\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n        if (type === 'points') {\n          // points\n          const pointsMaterial = new PointsMaterial({\n            color: 0xffffff\n          });\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === 'line') {\n          // lines\n          const lineMaterial = new LineBasicMaterial({\n            color: 0xffffff\n          });\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          // consider meshes\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          } // check for vertex colors\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true;\n          }\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false;\n      }\n      return object;\n    }\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n              material = new MeshBasicMaterial({\n                color: 0x000000\n              });\n            }\n            break;\n          case 'texture':\n            const textureNode = fieldValues[0];\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode);\n              }\n            }\n            break;\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // only apply texture transform data if a texture was defined\n\n      if (material.map) {\n        // respect VRML lighting model\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1; // ignore transparency\n\n              break;\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff); // ignore material color\n\n              break;\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff); // ignore material color\n\n              material.opacity = 1; // ignore transparency\n\n              break;\n          }\n          delete material.map.__type;\n        } // apply texture transform\n\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n      return material;\n    }\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break;\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'shininess':\n            materialData.shininess = fieldValues[0];\n            break;\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'transparency':\n            materialData.transparency = fieldValues[0];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return materialData;\n    }\n    function parseHexColor(hex, textureType, color) {\n      let value;\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt('0x' + hex.substring(4, 6));\n          break;\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = parseInt('0x' + hex.substring(8, 10));\n          break;\n      }\n    }\n    function getTextureType(num_components) {\n      let type;\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n      }\n      return type;\n    }\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data = new Uint8Array(4 * width * height);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data[stride + 0] = color.r;\n              data[stride + 1] = color.g;\n              data[stride + 2] = color.b;\n              data[stride + 3] = color.a;\n            }\n            texture = new DataTexture(data, width, height);\n            texture.needsUpdate = true;\n            texture.__type = textureType; // needed for material modifications\n\n            break;\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n          case 'rotation':\n            transformData.rotation = fieldValues[0];\n            break;\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return transformData;\n    }\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0];\n            break;\n          case 'info':\n            worldInfo.info = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return worldInfo;\n    }\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n        normalPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'coord':\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case 'normal':\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n          case 'convex':\n            // field not supported\n            break;\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n          case 'normalIndex':\n            normalIndex = fieldValues;\n            break;\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.');\n        return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          // consider face normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'coord':\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build lines\n\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n            const expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n            const flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            const expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          }\n        }\n      } //\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      geometry._type = 'line';\n      return geometry;\n    }\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'coord':\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n      geometry._type = 'points';\n      return geometry;\n    }\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0];\n            break;\n          case 'bottomRadius':\n            radius = fieldValues[0];\n            break;\n          case 'height':\n            height = fieldValues[0];\n            break;\n          case 'side':\n            // field not supported\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break;\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n          case 'height':\n            height = fieldValues[0];\n            break;\n          case 'side':\n            // field not supported\n            break;\n          case 'top':\n            // field not supported\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'normal':\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case 'height':\n            height = fieldValues;\n            break;\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n          case 'xDimension':\n            xDimension = fieldValues[0];\n            break;\n          case 'xSpacing':\n            xSpacing = fieldValues[0];\n            break;\n          case 'zDimension':\n            zDimension = fieldValues[0];\n            break;\n          case 'zSpacing':\n            zSpacing = fieldValues[0];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // vertex data\n\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n          const index = i * xDimension + j; // vertices\n\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z); // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          } // normals\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          } // uvs\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      } // indices\n\n      const indices = [];\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension; // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      } //\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute; // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2]; // one color per quad\n\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      } // normal attribute\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2]; // one normal per quad\n\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      } // build geometry\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n      geometry.setAttribute('uv', uvAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0];\n            break;\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n          case 'convex':\n            // field not supported\n            break;\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n          case 'crossSection':\n            crossSection = fieldValues;\n            break;\n          case 'endCap':\n            endCap = fieldValues[0];\n            break;\n          case 'orientation':\n            orientation = fieldValues;\n            break;\n          case 'scale':\n            scale = fieldValues;\n            break;\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n          case 'spine':\n            spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1]; // scale\n\n          vertex.multiply(scaling); // rotate\n\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion); // translate\n\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      } // indices\n\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      } // triangulate cap\n\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        } // begin cap\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        } // end cap\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // no uvs yet\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    } // helper functions\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []; // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n      return indices;\n    }\n    function triangulateFaceData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    function flattenData(data, index) {\n      const flattenData = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        flattenData.push(x, y, z);\n      }\n      return flattenData;\n    }\n    function expandLineIndex(index) {\n      const indices = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n      return indices;\n    }\n    function expandLineData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize);\n          uvB.fromArray(data, b * itemSize);\n          uvC.fromArray(data, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data, a * itemSize);\n          vB.fromArray(data, b * itemSize);\n          vC.fromArray(data, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n      return new Float32BufferAttribute(array, itemSize);\n    }\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n    const ab = new Vector3();\n    const cb = new Vector3();\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {}; // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n        if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n        if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      } // compute vertex normals and build final geometry\n\n      const normals = [];\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n      return new Float32BufferAttribute(normals, 3);\n    }\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n      return normal.normalize();\n    }\n    function toColorArray(colors) {\n      const array = [];\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n      return array;\n    }\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      } // generate vertex colors\n\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n          if (topDown === true) {\n            // interpolation for sky color\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            // interpolation for ground color\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n      geometry.setAttribute('color', colorAttribute);\n    } //\n\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n    } // create JSON representing the tree structure of the VRML asset\n\n    const tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree);\n    return scene;\n  }\n}\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error('THREE.VRMLLexer: Lexing errors detected.');\n    }\n    return lexingResult;\n  }\n}\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary['Version'];\n    const LCurly = tokenVocabulary['LCurly'];\n    const RCurly = tokenVocabulary['RCurly'];\n    const LSquare = tokenVocabulary['LSquare'];\n    const RSquare = tokenVocabulary['RSquare'];\n    const Identifier = tokenVocabulary['Identifier'];\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    const StringLiteral = tokenVocabulary['StringLiteral'];\n    const HexLiteral = tokenVocabulary['HexLiteral'];\n    const NumberLiteral = tokenVocabulary['NumberLiteral'];\n    const TrueLiteral = tokenVocabulary['TrueLiteral'];\n    const FalseLiteral = tokenVocabulary['FalseLiteral'];\n    const NullLiteral = tokenVocabulary['NullLiteral'];\n    const DEF = tokenVocabulary['DEF'];\n    const USE = tokenVocabulary['USE'];\n    const ROUTE = tokenVocabulary['ROUTE'];\n    const TO = tokenVocabulary['TO'];\n    const NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n}\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n}\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","Vector3","Vector2","TextureLoader","Scene","Object3D","Group","SphereGeometry","MeshBasicMaterial","BackSide","Mesh","PointsMaterial","Points","LineBasicMaterial","LineSegments","FrontSide","DoubleSide","MeshPhongMaterial","Color","DataTexture","BufferGeometry","Float32BufferAttribute","BoxGeometry","ConeGeometry","CylinderGeometry","Quaternion","ShapeUtils","BufferAttribute","RepeatWrapping","ClampToEdgeWrapping","createToken","Lexer","CstParser","VRMLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","call","validateVisitor","prototype","Object","assign","create","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree","scene","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","undefined","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","value","INTENSITY","parseInt","r","g","b","a","substring","getTextureType","num_components","texture","wrapS","wrapT","width","height","Uint8Array","k","stride","needsUpdate","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","positionAttribute","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","size","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","resourcePath","setCrossOrigin","crossOrigin","indexOf","inputText","tokenize","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/VRMLLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { createToken, Lexer, CstParser } from 'chevrotain';\n\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data, path) {\n    const nodeMap = {};\n\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n      const lexingResult = lexer.lex(data);\n      parser.input = lexingResult.tokens; // parsing\n\n      const cstOutput = parser.vrml();\n\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error('THREE.VRMLLoader: Parsing errors detected.');\n      } // actions\n\n\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n      'Inline', 'LOD', 'Switch', // special groups\n      'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n      'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n      'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n      'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n      'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n      'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n      'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n      'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]; //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier\n      }); //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({\n        name: 'HexLiteral',\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: 'NumberLiteral',\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: 'TrueLiteral',\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: 'FalseLiteral',\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: 'NullLiteral',\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: 'LSquare',\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: 'RSquare',\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: 'LCurly',\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: 'RCurly',\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n      }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n      });\n      const tokens = [WhiteSpace, // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n\n      return {\n        tokens: tokens,\n        tokenVocabulary: tokenVocabulary\n      };\n    }\n\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data.nodes.push(this.visit(node));\n          }\n\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data.routes.push(this.visit(route));\n            }\n          }\n\n          return data;\n        },\n        version: function (ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data.fields.push(this.visit(field));\n            }\n          } // DEF\n\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0]);\n          }\n\n          return data;\n        },\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result; // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          } // MFValue\n\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n\n          data.type = result.type;\n          data.values = result.values;\n          return data;\n        },\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function (ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        },\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data;\n        }\n      });\n\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n\n        if (ctx.node) {\n          field.type = 'node';\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n\n        if (ctx.use) {\n          field.type = 'use';\n\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n\n        if (ctx.StringLiteral) {\n          field.type = 'string';\n\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n          }\n        }\n\n        if (ctx.NumberLiteral) {\n          field.type = 'number';\n\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n\n        if (ctx.HexLiteral) {\n          field.type = 'hex';\n\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean';\n\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === 'TRUE') field.values.push(true);\n          }\n        }\n\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean';\n\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === 'FALSE') field.values.push(false);\n          }\n        }\n\n        if (ctx.NullLiteral) {\n          field.type = 'null';\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n\n        return field;\n      }\n\n      return new VRMLToASTVisitor();\n    }\n\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n      const nodes = tree.nodes;\n      const scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      } // second iteration: build nodes\n\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene.add(object);\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n      }\n\n      return scene;\n    }\n\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n\n        if (field.type === 'node') {\n          const fieldValues = field.values;\n\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n\n    function getNode(node) {\n      // handle case where a node refers to a different one\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n\n      if (node.build !== undefined) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    } // node builder\n\n\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node);\n          break;\n\n        case 'Background':\n          build = buildBackgroundNode(node);\n          break;\n\n        case 'Shape':\n          build = buildShapeNode(node);\n          break;\n\n        case 'Appearance':\n          build = buildAppearanceNode(node);\n          break;\n\n        case 'Material':\n          build = buildMaterialNode(node);\n          break;\n\n        case 'ImageTexture':\n          build = buildImageTextureNode(node);\n          break;\n\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node);\n          break;\n\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node);\n          break;\n\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node);\n          break;\n\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node);\n          break;\n\n        case 'PointSet':\n          build = buildPointSetNode(node);\n          break;\n\n        case 'Box':\n          build = buildBoxNode(node);\n          break;\n\n        case 'Cone':\n          build = buildConeNode(node);\n          break;\n\n        case 'Cylinder':\n          build = buildCylinderNode(node);\n          break;\n\n        case 'Sphere':\n          build = buildSphereNode(node);\n          break;\n\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node);\n          break;\n\n        case 'Extrusion':\n          build = buildExtrusionNode(node);\n          break;\n\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node);\n          break;\n\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node);\n          break;\n\n        case 'Anchor':\n        case 'Billboard':\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n        case 'Text':\n        case 'FontStyle':\n        case 'MovieTexture':\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break;\n\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n          break;\n      }\n\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF;\n      }\n\n      return build;\n    }\n\n    function buildGroupingNode(node) {\n      const object = new Group(); //\n\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break;\n\n          case 'bboxSize':\n            // field not supported\n            break;\n\n          case 'center':\n            // field not supported\n            break;\n\n          case 'children':\n            parseFieldChildren(fieldValues, object);\n            break;\n\n          case 'collide':\n            // field not supported\n            break;\n\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'scaleOrientation':\n            // field not supported\n            break;\n\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'proxy':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return object;\n    }\n\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues;\n            break;\n\n          case 'groundColor':\n            groundColor = fieldValues;\n            break;\n\n          case 'backUrl':\n            // field not supported\n            break;\n\n          case 'bottomUrl':\n            // field not supported\n            break;\n\n          case 'frontUrl':\n            // field not supported\n            break;\n\n          case 'leftUrl':\n            // field not supported\n            break;\n\n          case 'rightUrl':\n            // field not supported\n            break;\n\n          case 'topUrl':\n            // field not supported\n            break;\n\n          case 'skyAngle':\n            skyAngle = fieldValues;\n            break;\n\n          case 'skyColor':\n            skyColor = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const radius = 10000; // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      } // ground\n\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      } // render background group first\n\n\n      group.renderOrder = -Infinity;\n      return group;\n    }\n\n    function buildShapeNode(node) {\n      const fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({\n        color: 0x000000\n      });\n      let geometry;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build 3D object\n\n\n      let object;\n\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n\n        if (type === 'points') {\n          // points\n          const pointsMaterial = new PointsMaterial({\n            color: 0xffffff\n          });\n\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === 'line') {\n          // lines\n          const lineMaterial = new LineBasicMaterial({\n            color: 0xffffff\n          });\n\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          // consider meshes\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          } // check for vertex colors\n\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true;\n          }\n\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false;\n      }\n\n      return object;\n    }\n\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n              material = new MeshBasicMaterial({\n                color: 0x000000\n              });\n            }\n\n            break;\n\n          case 'texture':\n            const textureNode = fieldValues[0];\n\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode);\n              }\n            }\n\n            break;\n\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // only apply texture transform data if a texture was defined\n\n\n      if (material.map) {\n        // respect VRML lighting model\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1; // ignore transparency\n\n              break;\n\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff); // ignore material color\n\n              break;\n\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff); // ignore material color\n\n              material.opacity = 1; // ignore transparency\n\n              break;\n          }\n\n          delete material.map.__type;\n        } // apply texture transform\n\n\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n\n      return material;\n    }\n\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break;\n\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'shininess':\n            materialData.shininess = fieldValues[0];\n            break;\n\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'transparency':\n            materialData.transparency = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return materialData;\n    }\n\n    function parseHexColor(hex, textureType, color) {\n      let value;\n\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt('0x' + hex.substring(4, 6));\n          break;\n\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = 1;\n          break;\n\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = parseInt('0x' + hex.substring(8, 10));\n          break;\n      }\n    }\n\n    function getTextureType(num_components) {\n      let type;\n\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n      }\n\n      return type;\n    }\n\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data = new Uint8Array(4 * width * height);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data[stride + 0] = color.r;\n              data[stride + 1] = color.g;\n              data[stride + 2] = color.b;\n              data[stride + 3] = color.a;\n            }\n\n            texture = new DataTexture(data, width, height);\n            texture.needsUpdate = true;\n            texture.__type = textureType; // needed for material modifications\n\n            break;\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n\n      return texture;\n    }\n\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n\n      return texture;\n    }\n\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          case 'rotation':\n            transformData.rotation = fieldValues[0];\n            break;\n\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return transformData;\n    }\n\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0];\n            break;\n\n          case 'info':\n            worldInfo.info = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return worldInfo;\n    }\n\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n          solid = true,\n          creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n          normalPerVertex = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          case 'normal':\n            const normalNode = fieldValues[0];\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n\n            break;\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'convex':\n            // field not supported\n            break;\n\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'normalIndex':\n            normalIndex = fieldValues;\n            break;\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.');\n        return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          // consider face normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build lines\n\n\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n            const expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n            const flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            const expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          }\n        }\n      } //\n\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      geometry._type = 'line';\n      return geometry;\n    }\n\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n      geometry._type = 'points';\n      return geometry;\n    }\n\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n\n    function buildConeNode(node) {\n      let radius = 1,\n          height = 2,\n          openEnded = false;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0];\n            break;\n\n          case 'bottomRadius':\n            radius = fieldValues[0];\n            break;\n\n          case 'height':\n            height = fieldValues[0];\n            break;\n\n          case 'side':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n\n    function buildCylinderNode(node) {\n      let radius = 1,\n          height = 2;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break;\n\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n\n          case 'height':\n            height = fieldValues[0];\n            break;\n\n          case 'side':\n            // field not supported\n            break;\n\n          case 'top':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'normal':\n            const normalNode = fieldValues[0];\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n\n            break;\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n\n            break;\n\n          case 'height':\n            height = fieldValues;\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'xDimension':\n            xDimension = fieldValues[0];\n            break;\n\n          case 'xSpacing':\n            xSpacing = fieldValues[0];\n            break;\n\n          case 'zDimension':\n            zDimension = fieldValues[0];\n            break;\n\n          case 'zSpacing':\n            zSpacing = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // vertex data\n\n\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n          const index = i * xDimension + j; // vertices\n\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z); // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          } // normals\n\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          } // uvs\n\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      } // indices\n\n\n      const indices = [];\n\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension; // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      } //\n\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute; // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2]; // one color per quad\n\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      } // normal attribute\n\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2]; // one normal per quad\n\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      } // build geometry\n\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n      geometry.setAttribute('uv', uvAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0];\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'convex':\n            // field not supported\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'crossSection':\n            crossSection = fieldValues;\n            break;\n\n          case 'endCap':\n            endCap = fieldValues[0];\n            break;\n\n          case 'orientation':\n            orientation = fieldValues;\n            break;\n\n          case 'scale':\n            scale = fieldValues;\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'spine':\n            spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1]; // scale\n\n          vertex.multiply(scaling); // rotate\n\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion); // translate\n\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      } // indices\n\n\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      } // triangulate cap\n\n\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        } // begin cap\n\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        } // end cap\n\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // no uvs yet\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    } // helper functions\n\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []; // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n\n      return indices;\n    }\n\n    function triangulateFaceData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n\n      return triangulatedData;\n    }\n\n    function flattenData(data, index) {\n      const flattenData = [];\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        flattenData.push(x, y, z);\n      }\n\n      return flattenData;\n    }\n\n    function expandLineIndex(index) {\n      const indices = [];\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n\n      return indices;\n    }\n\n    function expandLineData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n\n      return triangulatedData;\n    }\n\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize);\n          uvB.fromArray(data, b * itemSize);\n          uvC.fromArray(data, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data, a * itemSize);\n          vB.fromArray(data, b * itemSize);\n          vC.fromArray(data, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n\n      return new Float32BufferAttribute(array, itemSize);\n    }\n\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n\n      return new Float32BufferAttribute(array, 3);\n    }\n\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n\n      return new Float32BufferAttribute(array, 3);\n    }\n\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n          index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n\n    const ab = new Vector3();\n    const cb = new Vector3();\n\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {}; // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n        if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n        if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      } // compute vertex normals and build final geometry\n\n\n      const normals = [];\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n\n      return new Float32BufferAttribute(normals, 3);\n    }\n\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n\n      return normal.normalize();\n    }\n\n    function toColorArray(colors) {\n      const array = [];\n\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n\n      return array;\n    }\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n\n\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      } // generate vertex colors\n\n\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n\n          if (topDown === true) {\n            // interpolation for sky color\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            // interpolation for ground color\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n\n      geometry.setAttribute('color', colorAttribute);\n    } //\n\n\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n    } // create JSON representing the tree structure of the VRML asset\n\n\n    const tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree);\n    return scene;\n  }\n\n}\n\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error('THREE.VRMLLexer: Lexing errors detected.');\n    }\n\n    return lexingResult;\n  }\n\n}\n\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary['Version'];\n    const LCurly = tokenVocabulary['LCurly'];\n    const RCurly = tokenVocabulary['RCurly'];\n    const LSquare = tokenVocabulary['LSquare'];\n    const RSquare = tokenVocabulary['RSquare'];\n    const Identifier = tokenVocabulary['Identifier'];\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    const StringLiteral = tokenVocabulary['StringLiteral'];\n    const HexLiteral = tokenVocabulary['HexLiteral'];\n    const NumberLiteral = tokenVocabulary['NumberLiteral'];\n    const TrueLiteral = tokenVocabulary['TrueLiteral'];\n    const FalseLiteral = tokenVocabulary['FalseLiteral'];\n    const NullLiteral = tokenVocabulary['NullLiteral'];\n    const DEF = tokenVocabulary['DEF'];\n    const USE = tokenVocabulary['USE'];\n    const ROUTE = tokenVocabulary['ROUTE'];\n    const TO = tokenVocabulary['TO'];\n    const NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n\n}\n\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n\n}\n\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\n\nexport { VRMLLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}