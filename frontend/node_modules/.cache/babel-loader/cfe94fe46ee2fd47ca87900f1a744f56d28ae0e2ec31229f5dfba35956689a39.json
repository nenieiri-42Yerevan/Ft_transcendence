{"ast":null,"code":"import { Line, BufferGeometry, BufferAttribute, LineBasicMaterial, MathUtils } from 'three';\nclass PositionalAudioHelper extends Line {\n  constructor(audio) {\n    let range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let divisionsInnerAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n    let divisionsOuterAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    const geometry = new BufferGeometry();\n    const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;\n    const positions = new Float32Array((divisions * 3 + 3) * 3);\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n    const materialInnerAngle = new LineBasicMaterial({\n      color: 0x00ff00\n    });\n    const materialOuterAngle = new LineBasicMaterial({\n      color: 0xffff00\n    });\n    super(geometry, [materialOuterAngle, materialInnerAngle]);\n    this.type = 'PositionalAudioHelper';\n    this.audio = audio;\n    this.range = range;\n    this.divisionsInnerAngle = divisionsInnerAngle;\n    this.divisionsOuterAngle = divisionsOuterAngle;\n    this.update();\n  }\n  update() {\n    const audio = this.audio;\n    const range = this.range;\n    const divisionsInnerAngle = this.divisionsInnerAngle;\n    const divisionsOuterAngle = this.divisionsOuterAngle;\n    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);\n    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);\n    const halfConeInnerAngle = coneInnerAngle / 2;\n    const halfConeOuterAngle = coneOuterAngle / 2;\n    let start = 0;\n    let count = 0;\n    let i, stride;\n    const geometry = this.geometry;\n    const positionAttribute = geometry.attributes.position;\n    geometry.clearGroups(); //\n\n    function generateSegment(from, to, divisions, materialIndex) {\n      const step = (to - from) / divisions;\n      positionAttribute.setXYZ(start, 0, 0, 0);\n      count++;\n      for (i = from; i < to; i += step) {\n        stride = start + count;\n        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);\n        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);\n        positionAttribute.setXYZ(stride + 2, 0, 0, 0);\n        count += 3;\n      }\n      geometry.addGroup(start, count, materialIndex);\n      start += count;\n      count = 0;\n    } //\n\n    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);\n    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);\n    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0); //\n\n    positionAttribute.needsUpdate = true;\n    if (coneInnerAngle === coneOuterAngle) this.material[0].visible = false;\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material[0].dispose();\n    this.material[1].dispose();\n  }\n}\nexport { PositionalAudioHelper };","map":{"version":3,"names":["Line","BufferGeometry","BufferAttribute","LineBasicMaterial","MathUtils","PositionalAudioHelper","constructor","audio","range","divisionsInnerAngle","divisionsOuterAngle","geometry","divisions","positions","Float32Array","setAttribute","materialInnerAngle","color","materialOuterAngle","type","update","coneInnerAngle","degToRad","panner","coneOuterAngle","halfConeInnerAngle","halfConeOuterAngle","start","count","i","stride","positionAttribute","attributes","position","clearGroups","generateSegment","from","to","materialIndex","step","setXYZ","Math","sin","cos","min","addGroup","needsUpdate","material","visible","dispose"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/helpers/PositionalAudioHelper.js"],"sourcesContent":["import { Line, BufferGeometry, BufferAttribute, LineBasicMaterial, MathUtils } from 'three';\n\nclass PositionalAudioHelper extends Line {\n  constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2) {\n    const geometry = new BufferGeometry();\n    const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;\n    const positions = new Float32Array((divisions * 3 + 3) * 3);\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n    const materialInnerAngle = new LineBasicMaterial({\n      color: 0x00ff00\n    });\n    const materialOuterAngle = new LineBasicMaterial({\n      color: 0xffff00\n    });\n    super(geometry, [materialOuterAngle, materialInnerAngle]);\n    this.type = 'PositionalAudioHelper';\n    this.audio = audio;\n    this.range = range;\n    this.divisionsInnerAngle = divisionsInnerAngle;\n    this.divisionsOuterAngle = divisionsOuterAngle;\n    this.update();\n  }\n\n  update() {\n    const audio = this.audio;\n    const range = this.range;\n    const divisionsInnerAngle = this.divisionsInnerAngle;\n    const divisionsOuterAngle = this.divisionsOuterAngle;\n    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);\n    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);\n    const halfConeInnerAngle = coneInnerAngle / 2;\n    const halfConeOuterAngle = coneOuterAngle / 2;\n    let start = 0;\n    let count = 0;\n    let i, stride;\n    const geometry = this.geometry;\n    const positionAttribute = geometry.attributes.position;\n    geometry.clearGroups(); //\n\n    function generateSegment(from, to, divisions, materialIndex) {\n      const step = (to - from) / divisions;\n      positionAttribute.setXYZ(start, 0, 0, 0);\n      count++;\n\n      for (i = from; i < to; i += step) {\n        stride = start + count;\n        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);\n        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);\n        positionAttribute.setXYZ(stride + 2, 0, 0, 0);\n        count += 3;\n      }\n\n      geometry.addGroup(start, count, materialIndex);\n      start += count;\n      count = 0;\n    } //\n\n\n    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);\n    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);\n    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0); //\n\n    positionAttribute.needsUpdate = true;\n    if (coneInnerAngle === coneOuterAngle) this.material[0].visible = false;\n  }\n\n  dispose() {\n    this.geometry.dispose();\n    this.material[0].dispose();\n    this.material[1].dispose();\n  }\n\n}\n\nexport { PositionalAudioHelper };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}