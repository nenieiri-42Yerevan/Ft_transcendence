{"ast":null,"code":"import { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\nimport { SimplexNoise } from '../math/SimplexNoise.js';\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  constructor(rayParameters) {\n    super();\n    this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\n\n    rayParameters = rayParameters || {};\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\n\n    this.createMesh();\n  }\n  update(time) {\n    if (this.isStatic) return;\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = LightningStrike.RAY_STEADY;\n      }\n      this.visible = true;\n    } else {\n      this.visible = false;\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n  init(rayParameters) {\n    // Init all the state from the parameters\n    this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs; // Random generator\n\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    } // Ray creation callbacks\n\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    } // Internal state\n\n    this.state = LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n    this.raySegments = [];\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\n\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    } // Populate the mesh\n\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute('position', this.positionAttribute);\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute('uv', this.uvsAttribute);\n    }\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    } // Store buffers for later modification\n\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n          scope.createPrism(segment);\n        }\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n  addNewSubray() /*rayParameters*/\n  {\n    return this.subrays[this.numSubrays++];\n  }\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0; // Add the top level subray\n\n    this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\n\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    } // Interpolation\n\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos; // Noise\n\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos); // Recursion\n\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n  createPrismFaces(vertex\n  /*, index*/) {\n    const indices = this.indices;\n    var vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n    this.onDecideSubrayCreation = (segment, lightningStrike) => {\n      // Decide subrays creation at parent (sub)ray segment\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n      if (isActive) {\n        probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\n      // Sets childSubray pos0 and pos1 in a cone\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\n      // Sets childSubray pos0 and pos1 in a cylinder\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n  copy(source) {\n    super.copy(source);\n    this.init(LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\n  }\n}\nLightningStrike.prototype.isLightningStrike = true; // Ray states\n\nLightningStrike.RAY_INITIALIZED = 0;\nLightningStrike.RAY_UNBORN = 1;\nLightningStrike.RAY_PROPAGATING = 2;\nLightningStrike.RAY_STEADY = 3;\nLightningStrike.RAY_VANISHING = 4;\nLightningStrike.RAY_EXTINGUISHED = 5;\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\nLightningStrike.createRandomGenerator = () => {\n  const numSeeds = 2053;\n  const seeds = [];\n  for (let i = 0; i < numSeeds; i++) {\n    seeds.push(Math.random());\n  }\n  const generator = {\n    currentSeed: 0,\n    random: function () {\n      const value = seeds[generator.currentSeed];\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n      return value;\n    },\n    getSeed: function () {\n      return generator.currentSeed / numSeeds;\n    },\n    setSeed: function (seed) {\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n    }\n  };\n  return generator;\n};\nLightningStrike.copyParameters = (dest, source) => {\n  source = source || {};\n  dest = dest || {};\n  const vecCopy = v => {\n    if (source === dest) {\n      return v;\n    } else {\n      return v.clone();\n    }\n  };\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2,\n  // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\n\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n  return dest;\n};\nexport { LightningStrike };","map":{"version":3,"names":["BufferGeometry","Vector3","Uint32BufferAttribute","Float32BufferAttribute","DynamicDrawUsage","MathUtils","SimplexNoise","LightningStrike","constructor","rayParameters","type","init","copyParameters","createMesh","update","time","isStatic","isEternal","birthTime","deathTime","updateMesh","subrays","endPropagationTime","state","RAY_PROPAGATING","beginVanishingTime","RAY_VANISHING","RAY_STEADY","visible","RAY_UNBORN","RAY_EXTINGUISHED","maxIterations","undefined","Math","floor","ramification","maxSubrayRecursion","recursionProbability","generateUVs","randomGenerator","seedGenerator","noiseSeed","setSeed","createRandomGenerator","onDecideSubrayCreation","createDefaultSubrayCreationCallbacks","onSubrayCreation","RAY_INITIALIZED","maxSubrays","ceil","pow","max","maxRaySegments","i","push","createSubray","raySegments","createSegment","timeFraction","currentSegmentCallback","currentCreateTriangleVertices","createTriangleVerticesWithUVs","createTriangleVerticesWithoutUVs","numSubrays","currentSubray","currentSegmentIndex","isInitialSegment","subrayProbability","currentVertex","currentIndex","currentCoordinate","currentUVCoordinate","vertices","uvs","indices","positionAttribute","uvsAttribute","simplexX","simplexY","simplexZ","forwards","forwardsFill","side","down","middlePos","middleLinPos","newPos","vPos","cross1","maxDrawableSegmentsPerSubRay","maxVerts","maxIndices","Float32Array","Uint32Array","fillMesh","setIndex","setAttribute","index","usage","array","drawRange","count","needsUpdate","scope","fractalRay","fillVertices","segment","subray","recursion","createPrism","fraction0","propagationTimeFactor","vanishingTimeFactor","fraction1","addNewSubray","initSubray","pos0","copy","sourceOffset","pos1","destOffset","up0","up1","radius0","radius1","timeScale","roughness","straightness","seed","segmentCallback","subrayIndex","lerp","random1","random","linPos0","set","multiplyScalar","linPos1","getNewSegment","iteration","positionVariationFactor","fractalRayRecursive","subVectors","lForwards","length","middleRadius","middleFraction","timeDimension","lerpVectors","p","noise4d","x","y","z","add","newSegment1","newSegment2","crossVectors","normalize","createPrismFaces","pos","up","radius","COS30DEG","SIN30DEG","v","sub","u","uv","vertex","lightningStrike","period","subrayPeriod","dutyCycle","subrayDutyCycle","phase0","phase","currentCycle","childSubraySeed","isActive","probability","childSubray","parentSeed","getSeed","radius0Factor","min","minRadius","radius1Factor","vec1Pos","vec2Forward","vec3Side","vec4Up","parentSubray","subrayCylinderPosition","subrayConePosition","heightFactor","sideWidthFactor","minSideWidthFactor","angle","PI","cos","sin","source","clone","prototype","isLightningStrike","numSeeds","seeds","generator","currentSeed","value","dest","vecCopy"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/geometries/LightningStrike.js"],"sourcesContent":["import { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\nimport { SimplexNoise } from '../math/SimplexNoise.js';\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  constructor(rayParameters) {\n    super();\n    this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\n\n    rayParameters = rayParameters || {};\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\n\n    this.createMesh();\n  }\n\n  update(time) {\n    if (this.isStatic) return;\n\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = LightningStrike.RAY_STEADY;\n      }\n\n      this.visible = true;\n    } else {\n      this.visible = false;\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n\n  init(rayParameters) {\n    // Init all the state from the parameters\n    this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs; // Random generator\n\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    } // Ray creation callbacks\n\n\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    } // Internal state\n\n\n    this.state = LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n\n    this.raySegments = [];\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\n\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    } // Populate the mesh\n\n\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute('position', this.positionAttribute);\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute('uv', this.uvsAttribute);\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    } // Store buffers for later modification\n\n\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n          scope.createPrism(segment);\n        }\n\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n\n  addNewSubray()\n  /*rayParameters*/\n  {\n    return this.subrays[this.numSubrays++];\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0; // Add the top level subray\n\n    this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\n\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    } // Interpolation\n\n\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos; // Noise\n\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos); // Recursion\n\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n\n  createPrismFaces(vertex\n  /*, index*/\n  ) {\n    const indices = this.indices;\n    var vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n\n    this.onDecideSubrayCreation = (segment, lightningStrike) => {\n      // Decide subrays creation at parent (sub)ray segment\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n\n    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n\n    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\n      // Sets childSubray pos0 and pos1 in a cone\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n\n    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\n      // Sets childSubray pos0 and pos1 in a cylinder\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.init(LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\n  }\n\n}\n\nLightningStrike.prototype.isLightningStrike = true; // Ray states\n\nLightningStrike.RAY_INITIALIZED = 0;\nLightningStrike.RAY_UNBORN = 1;\nLightningStrike.RAY_PROPAGATING = 2;\nLightningStrike.RAY_STEADY = 3;\nLightningStrike.RAY_VANISHING = 4;\nLightningStrike.RAY_EXTINGUISHED = 5;\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\n\nLightningStrike.createRandomGenerator = () => {\n  const numSeeds = 2053;\n  const seeds = [];\n\n  for (let i = 0; i < numSeeds; i++) {\n    seeds.push(Math.random());\n  }\n\n  const generator = {\n    currentSeed: 0,\n    random: function () {\n      const value = seeds[generator.currentSeed];\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n      return value;\n    },\n    getSeed: function () {\n      return generator.currentSeed / numSeeds;\n    },\n    setSeed: function (seed) {\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n    }\n  };\n  return generator;\n};\n\nLightningStrike.copyParameters = (dest, source) => {\n  source = source || {};\n  dest = dest || {};\n\n  const vecCopy = v => {\n    if (source === dest) {\n      return v;\n    } else {\n      return v.clone();\n    }\n  };\n\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\n\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n  return dest;\n};\n\nexport { LightningStrike };\n"],"mappings":"AAAA,SAASA,cAAc,EAAEC,OAAO,EAAEC,qBAAqB,EAAEC,sBAAsB,EAAEC,gBAAgB,EAAEC,SAAS,QAAQ,OAAO;AAC3H,SAASC,YAAY,QAAQ,yBAAyB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,eAAe,SAASP,cAAc,CAAC;EAC3CQ,WAAW,CAACC,aAAa,EAAE;IACzB,KAAK,EAAE;IACP,IAAI,CAACC,IAAI,GAAG,iBAAiB,CAAC,CAAC;;IAE/BD,aAAa,GAAGA,aAAa,IAAI,CAAC,CAAC;IACnC,IAAI,CAACE,IAAI,CAACJ,eAAe,CAACK,cAAc,CAACH,aAAa,EAAEA,aAAa,CAAC,CAAC,CAAC,CAAC;;IAEzE,IAAI,CAACI,UAAU,EAAE;EACnB;EAEAC,MAAM,CAACC,IAAI,EAAE;IACX,IAAI,IAAI,CAACC,QAAQ,EAAE;IAEnB,IAAI,IAAI,CAACP,aAAa,CAACQ,SAAS,IAAI,IAAI,CAACR,aAAa,CAACS,SAAS,IAAIH,IAAI,IAAIA,IAAI,IAAI,IAAI,CAACN,aAAa,CAACU,SAAS,EAAE;MAChH,IAAI,CAACC,UAAU,CAACL,IAAI,CAAC;MAErB,IAAIA,IAAI,GAAG,IAAI,CAACM,OAAO,CAAC,CAAC,CAAC,CAACC,kBAAkB,EAAE;QAC7C,I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"},"metadata":{},"sourceType":"module","externalDependencies":[]}