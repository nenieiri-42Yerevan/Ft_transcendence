{"ast":null,"code":"import { Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBAFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute } from 'three';\nclass Lensflare extends Mesh {\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.type = 'Lensflare';\n    this.frustumCulled = false;\n    this.renderOrder = Infinity; //\n\n    const positionScreen = new Vector3();\n    const positionView = new Vector3(); // textures\n\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping; // material\n\n    const geometry = Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader: /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader: /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    }); // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a); //\n\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(0xffffff)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry, material2);\n    this.addElement = function (element) {\n      elements.push(element);\n    }; //\n\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2.0;\n      const halfViewportHeight = viewport.w / 2.0;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return; // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad\n\n        let uniforms = material1a.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics\n\n        uniforms = material1b.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements\n\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms = material2.uniforms;\n          uniforms['color'].value.copy(element.color);\n          uniforms['map'].value = element.texture;\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect = viewport.w / viewport.z;\n          uniforms['scale'].value.set(size * invAspect, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n        }\n      }\n    };\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n}\nLensflare.prototype.isLensflare = true; //\n\nclass LensflareElement {\n  constructor(texture) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Color(0xffffff);\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n}\nLensflareElement.Shader = {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n};\nLensflare.Geometry = function () {\n  const geometry = new BufferGeometry();\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  return geometry;\n}();\nexport { Lensflare, LensflareElement };","map":{"version":3,"names":["Mesh","MeshBasicMaterial","Vector3","DataTexture","RGBAFormat","NearestFilter","ClampToEdgeWrapping","RawShaderMaterial","Color","Vector2","AdditiveBlending","Box2","Vector4","BufferGeometry","InterleavedBuffer","InterleavedBufferAttribute","Lensflare","constructor","Geometry","opacity","transparent","type","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","Uint8Array","minFilter","magFilter","wrapS","wrapT","occlusionMap","geometry","material1a","uniforms","scale","value","screenPosition","vertexShader","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","LensflareElement","Shader","material2","color","blending","mesh2","addElement","element","push","screenPositionPixels","validArea","viewport","onBeforeRender","renderer","scene","camera","getCurrentViewport","invAspect","w","z","halfViewportWidth","halfViewportHeight","size","set","min","x","y","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","texture","distance","uniformsNeedUpdate","dispose","prototype","isLensflare","float32Array","Float32Array","interleavedBuffer","setIndex","setAttribute"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/objects/Lensflare.js"],"sourcesContent":["import { Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBAFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute } from 'three';\n\nclass Lensflare extends Mesh {\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.type = 'Lensflare';\n    this.frustumCulled = false;\n    this.renderOrder = Infinity; //\n\n    const positionScreen = new Vector3();\n    const positionView = new Vector3(); // textures\n\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping; // material\n\n    const geometry = Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    }); // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a); //\n\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(0xffffff)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry, material2);\n\n    this.addElement = function (element) {\n      elements.push(element);\n    }; //\n\n\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2.0;\n      const halfViewportHeight = viewport.w / 2.0;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return; // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad\n\n        let uniforms = material1a.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics\n\n        uniforms = material1b.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements\n\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms = material2.uniforms;\n          uniforms['color'].value.copy(element.color);\n          uniforms['map'].value = element.texture;\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect = viewport.w / viewport.z;\n          uniforms['scale'].value.set(size * invAspect, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n        }\n      }\n    };\n\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n\n}\n\nLensflare.prototype.isLensflare = true; //\n\nclass LensflareElement {\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n\n}\n\nLensflareElement.Shader = {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n};\n\nLensflare.Geometry = function () {\n  const geometry = new BufferGeometry();\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  return geometry;\n}();\n\nexport { Lensflare, LensflareElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}