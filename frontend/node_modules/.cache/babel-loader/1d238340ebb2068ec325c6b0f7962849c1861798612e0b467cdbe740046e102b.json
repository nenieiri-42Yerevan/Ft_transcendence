{"ast":null,"code":"import { Loader, FileLoader, AnimationClip, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack } from 'three';\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.animateBonePositions = true;\n    this.animateBoneRotations = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text) {\n    /*\n    reads a string array (lines) from a BVH file\n    and outputs a skeleton structure including motion data\n    returns thee root node:\n    { name: '', channels: [], children: [] }\n    */\n    function readBvh(lines) {\n      // read model structure\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.');\n      }\n      const list = []; // collects flat array of all bones\n\n      const root = readNode(lines, nextLine(lines), list); // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.');\n      } // number of frames\n\n      let tokens = nextLine(lines).split(/[\\s]+/);\n      const numFrames = parseInt(tokens[1]);\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.');\n      } // frame time\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      const frameTime = parseFloat(tokens[2]);\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.');\n      } // read frame data line by line\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        readFrameData(tokens, i * frameTime, root);\n      }\n      return list;\n    }\n    /*\n    Recursively reads data from a single frame into the bone hierarchy.\n    The passed bone hierarchy has to be structured in the same order as the BVH file.\n    keyframe data is stored in bone.frames.\n    - data: splitted string array (frame values), values are shift()ed so\n    this should be empty after parsing the whole hierarchy.\n    - frameTime: playback time for this keyframe.\n    - bone: the bone to read frame data from.\n    */\n\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n      if (bone.type === 'ENDSITE') return; // add keyframe\n\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion()\n      };\n      bone.frames.push(keyframe);\n      const quat = new Quaternion();\n      const vx = new Vector3(1, 0, 0);\n      const vy = new Vector3(0, 1, 0);\n      const vz = new Vector3(0, 0, 1); // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim());\n            break;\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim());\n            break;\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim());\n            break;\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.');\n        }\n      } // parse child nodes\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i]);\n      }\n    }\n    /*\n    Recursively parses the HIERACHY section of the BVH file\n    - lines: all lines of the file. lines are consumed as we go along.\n    - firstline: line containing the node type and name e.g. 'JOINT hip'\n    - list: collects a flat list of nodes\n    returns: a BVH node including children\n    */\n\n    function readNode(lines, firstline, list) {\n      const node = {\n        name: '',\n        type: '',\n        frames: []\n      };\n      list.push(node); // parse node type and name\n\n      let tokens = firstline.split(/[\\s]+/);\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE';\n        node.name = 'ENDSITE'; // bvh end sites have no name\n      } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n      }\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name');\n      } // parse OFFSET\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n      }\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n      }\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.');\n      }\n      node.offset = offset; // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.');\n        }\n        const numChannels = parseInt(tokens[1]);\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n      } // read children\n\n      while (true) {\n        const line = nextLine(lines);\n        if (line === '}') {\n          return node;\n        } else {\n          node.children.push(readNode(lines, line, list));\n        }\n      }\n    }\n    /*\n    recursively converts the internal bvh node structure to a Bone hierarchy\n    source: the bvh root node\n    list: pass an empty array, collects a flat list of all converted THREE.Bones\n    returns the root Bone\n    */\n\n    function toTHREEBone(source, list) {\n      const bone = new Bone();\n      list.push(bone);\n      bone.position.add(source.offset);\n      bone.name = source.name;\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list));\n        }\n      }\n      return bone;\n    }\n    /*\n    builds a AnimationClip from the keyframe data saved in each bone.\n    bone: bvh root node\n    returns: a AnimationClip containing position and quaternion tracks\n    */\n\n    function toTHREEAnimation(bones) {\n      const tracks = []; // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i];\n        if (bone.type === 'ENDSITE') continue; // track data\n\n        const times = [];\n        const positions = [];\n        const rotations = [];\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j];\n          times.push(frame.time); // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x);\n          positions.push(frame.position.y + bone.offset.y);\n          positions.push(frame.position.z + bone.offset.z);\n          rotations.push(frame.rotation.x);\n          rotations.push(frame.rotation.y);\n          rotations.push(frame.rotation.z);\n          rotations.push(frame.rotation.w);\n        }\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n        }\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n        }\n      }\n      return new AnimationClip('animation', -1, tracks);\n    }\n    /*\n    returns the next non-empty line in lines\n    */\n\n    function nextLine(lines) {\n      let line; // skip empty lines\n\n      while ((line = lines.shift().trim()).length === 0) {}\n      return line;\n    }\n    const scope = this;\n    const lines = text.split(/[\\r\\n]+/g);\n    const bones = readBvh(lines);\n    const threeBones = [];\n    toTHREEBone(bones[0], threeBones);\n    const threeClip = toTHREEAnimation(bones);\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip\n    };\n  }\n}\nexport { BVHLoader };","map":{"version":3,"names":["Loader","FileLoader","AnimationClip","Skeleton","Vector3","Quaternion","Bone","VectorKeyframeTrack","QuaternionKeyframeTrack","BVHLoader","constructor","manager","animateBonePositions","animateBoneRotations","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","readBvh","lines","nextLine","list","root","readNode","tokens","split","numFrames","parseInt","isNaN","frameTime","parseFloat","i","readFrameData","data","bone","type","keyframe","time","position","rotation","frames","push","quat","vx","vy","vz","channels","length","x","shift","trim","y","z","setFromAxisAngle","Math","PI","multiply","warn","children","firstline","node","name","toUpperCase","offset","numChannels","splice","line","toTHREEBone","source","add","toTHREEAnimation","bones","tracks","times","positions","rotations","j","frame","w","threeBones","threeClip","skeleton","clip"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/BVHLoader.js"],"sourcesContent":["import { Loader, FileLoader, AnimationClip, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack } from 'three';\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.animateBonePositions = true;\n    this.animateBoneRotations = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text) {\n    /*\n    reads a string array (lines) from a BVH file\n    and outputs a skeleton structure including motion data\n    returns thee root node:\n    { name: '', channels: [], children: [] }\n    */\n    function readBvh(lines) {\n      // read model structure\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.');\n      }\n\n      const list = []; // collects flat array of all bones\n\n      const root = readNode(lines, nextLine(lines), list); // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.');\n      } // number of frames\n\n\n      let tokens = nextLine(lines).split(/[\\s]+/);\n      const numFrames = parseInt(tokens[1]);\n\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.');\n      } // frame time\n\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      const frameTime = parseFloat(tokens[2]);\n\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.');\n      } // read frame data line by line\n\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        readFrameData(tokens, i * frameTime, root);\n      }\n\n      return list;\n    }\n    /*\n    Recursively reads data from a single frame into the bone hierarchy.\n    The passed bone hierarchy has to be structured in the same order as the BVH file.\n    keyframe data is stored in bone.frames.\n    - data: splitted string array (frame values), values are shift()ed so\n    this should be empty after parsing the whole hierarchy.\n    - frameTime: playback time for this keyframe.\n    - bone: the bone to read frame data from.\n    */\n\n\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n      if (bone.type === 'ENDSITE') return; // add keyframe\n\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion()\n      };\n      bone.frames.push(keyframe);\n      const quat = new Quaternion();\n      const vx = new Vector3(1, 0, 0);\n      const vy = new Vector3(0, 1, 0);\n      const vz = new Vector3(0, 0, 1); // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim());\n            break;\n\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim());\n            break;\n\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim());\n            break;\n\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.');\n        }\n      } // parse child nodes\n\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i]);\n      }\n    }\n    /*\n    Recursively parses the HIERACHY section of the BVH file\n    - lines: all lines of the file. lines are consumed as we go along.\n    - firstline: line containing the node type and name e.g. 'JOINT hip'\n    - list: collects a flat list of nodes\n    returns: a BVH node including children\n    */\n\n\n    function readNode(lines, firstline, list) {\n      const node = {\n        name: '',\n        type: '',\n        frames: []\n      };\n      list.push(node); // parse node type and name\n\n      let tokens = firstline.split(/[\\s]+/);\n\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE';\n        node.name = 'ENDSITE'; // bvh end sites have no name\n      } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n      }\n\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name');\n      } // parse OFFSET\n\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n      }\n\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n      }\n\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.');\n      }\n\n      node.offset = offset; // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/);\n\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.');\n        }\n\n        const numChannels = parseInt(tokens[1]);\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n      } // read children\n\n\n      while (true) {\n        const line = nextLine(lines);\n\n        if (line === '}') {\n          return node;\n        } else {\n          node.children.push(readNode(lines, line, list));\n        }\n      }\n    }\n    /*\n    recursively converts the internal bvh node structure to a Bone hierarchy\n    source: the bvh root node\n    list: pass an empty array, collects a flat list of all converted THREE.Bones\n    returns the root Bone\n    */\n\n\n    function toTHREEBone(source, list) {\n      const bone = new Bone();\n      list.push(bone);\n      bone.position.add(source.offset);\n      bone.name = source.name;\n\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list));\n        }\n      }\n\n      return bone;\n    }\n    /*\n    builds a AnimationClip from the keyframe data saved in each bone.\n    bone: bvh root node\n    returns: a AnimationClip containing position and quaternion tracks\n    */\n\n\n    function toTHREEAnimation(bones) {\n      const tracks = []; // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i];\n        if (bone.type === 'ENDSITE') continue; // track data\n\n        const times = [];\n        const positions = [];\n        const rotations = [];\n\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j];\n          times.push(frame.time); // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x);\n          positions.push(frame.position.y + bone.offset.y);\n          positions.push(frame.position.z + bone.offset.z);\n          rotations.push(frame.rotation.x);\n          rotations.push(frame.rotation.y);\n          rotations.push(frame.rotation.z);\n          rotations.push(frame.rotation.w);\n        }\n\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n        }\n\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n        }\n      }\n\n      return new AnimationClip('animation', -1, tracks);\n    }\n    /*\n    returns the next non-empty line in lines\n    */\n\n\n    function nextLine(lines) {\n      let line; // skip empty lines\n\n      while ((line = lines.shift().trim()).length === 0) {}\n\n      return line;\n    }\n\n    const scope = this;\n    const lines = text.split(/[\\r\\n]+/g);\n    const bones = readBvh(lines);\n    const threeBones = [];\n    toTHREEBone(bones[0], threeBones);\n    const threeClip = toTHREEAnimation(bones);\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip\n    };\n  }\n\n}\n\nexport { BVHLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}