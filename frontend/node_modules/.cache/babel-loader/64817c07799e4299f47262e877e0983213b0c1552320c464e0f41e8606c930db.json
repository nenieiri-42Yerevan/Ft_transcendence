{"ast":null,"code":"import { BufferAttribute, Matrix4, Vector3, Matrix3, MeshPhongMaterial, UniformsUtils, ShaderLib, ShaderChunk } from 'three';\n\n/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\nvar GeometryCompressionUtils = {\n  /**\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n   *\n   */\n  compressNormals: function (mesh, encodeMethod) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n    const normal = mesh.geometry.attributes.normal;\n    if (!normal) {\n      console.error('Geometry must contain normal attribute. ');\n    }\n    if (normal.isPacked) return;\n    if (normal.itemSize != 3) {\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\n    }\n    const array = normal.array;\n    const count = normal.count;\n    let result;\n    if (encodeMethod == 'DEFAULT') {\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n      result = new Uint8Array(count * 3);\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx + 0] = encoded[0];\n        result[idx + 1] = encoded[1];\n        result[idx + 2] = encoded[2];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 3, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT1Byte') {\n      /**\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n       */\n      result = new Int8Array(count * 2);\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT2Byte') {\n      result = new Int16Array(count * 2);\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else if (encodeMethod == 'ANGLES') {\n      result = new Uint16Array(count * 2);\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else {\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n    }\n    mesh.geometry.attributes.normal.needsUpdate = true;\n    mesh.geometry.attributes.normal.isPacked = true;\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n    if (encodeMethod == 'ANGLES') {\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\n    }\n    if (encodeMethod == 'OCT1Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n    if (encodeMethod == 'OCT2Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n    if (encodeMethod == 'DEFAULT') {\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\n    }\n  },\n  /**\n   * Make the input mesh.geometry's position attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressPositions: function (mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n    const position = mesh.geometry.attributes.position;\n    if (!position) {\n      console.error('Geometry must contain position attribute. ');\n    }\n    if (position.isPacked) return;\n    if (position.itemSize != 3) {\n      console.error('position.itemSize is not 3, which cannot be packed. ');\n    }\n    const array = position.array;\n    const encodingBytes = 2;\n    const result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n    const quantized = result.quantized;\n    const decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n    mesh.geometry.setAttribute('position', new BufferAttribute(quantized, 3));\n    mesh.geometry.attributes.position.isPacked = true;\n    mesh.geometry.attributes.position.needsUpdate = true;\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n    mesh.material.defines.USE_PACKED_POSITION = 0;\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n  },\n  /**\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressUvs: function (mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry property. ');\n    }\n    const uvs = mesh.geometry.attributes.uv;\n    if (!uvs) {\n      console.error('Geometry must contain uv attribute. ');\n    }\n    if (uvs.isPacked) return;\n    const range = {\n      min: Infinity,\n      max: -Infinity\n    };\n    const array = uvs.array;\n    for (let i = 0; i < array.length; i++) {\n      range.min = Math.min(range.min, array[i]);\n      range.max = Math.max(range.max, array[i]);\n    }\n    let result;\n    if (range.min >= -1.0 && range.max <= 1.0) {\n      // use default encoding method\n      result = new Uint16Array(array.length);\n      for (let i = 0; i < array.length; i += 2) {\n        const encoded = this.EncodingFuncs.defaultEncode(array[i], array[i + 1], 0, 2);\n        result[i] = encoded[0];\n        result[i + 1] = encoded[1];\n      }\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n      mesh.material.defines.USE_PACKED_UV = 0;\n    } else {\n      // use quantized encoding method\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result.quantized, 2));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n      mesh.material.defines.USE_PACKED_UV = 1;\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n    }\n  },\n  EncodingFuncs: {\n    defaultEncode: function (x, y, z, bytes) {\n      if (bytes == 1) {\n        const tmpx = Math.round((x + 1) * 0.5 * 255);\n        const tmpy = Math.round((y + 1) * 0.5 * 255);\n        const tmpz = Math.round((z + 1) * 0.5 * 255);\n        return new Uint8Array([tmpx, tmpy, tmpz]);\n      } else if (bytes == 2) {\n        const tmpx = Math.round((x + 1) * 0.5 * 65535);\n        const tmpy = Math.round((y + 1) * 0.5 * 65535);\n        const tmpz = Math.round((z + 1) * 0.5 * 65535);\n        return new Uint16Array([tmpx, tmpy, tmpz]);\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    defaultDecode: function (array, bytes) {\n      if (bytes == 1) {\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\n      } else if (bytes == 2) {\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    // for `Angles` encoding\n    anglesEncode: function (x, y, z) {\n      const normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n      const normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n      return new Uint16Array([normal0, normal1]);\n    },\n    // for `Octahedron` encoding\n    octEncodeBest: function (x, y, z, bytes) {\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\n      // to minimize rounding errors\n\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n      dec = octDecodeVec2(oct);\n      bestCos = dot(x, y, z, dec);\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n      if (currentCos > bestCos) {\n        best = oct;\n      }\n      return best;\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        if (z < 0) {\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n          x = tempx;\n          y = tempy;\n          var diff = 1 - Math.abs(x) - Math.abs(y);\n          if (diff > 0) {\n            diff += 0.001;\n            x += x > 0 ? diff / 2 : -diff / 2;\n            y += y > 0 ? diff / 2 : -diff / 2;\n          }\n        }\n        if (bytes == 1) {\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n        }\n        if (bytes == 2) {\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n        }\n      }\n      function octDecodeVec2(oct) {\n        var x = oct[0];\n        var y = oct[1];\n        if (bytes == 1) {\n          x /= x < 0 ? 127 : 128;\n          y /= y < 0 ? 127 : 128;\n        } else if (bytes == 2) {\n          x /= x < 0 ? 32767 : 32768;\n          y /= y < 0 ? 32767 : 32768;\n        }\n        var z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n          var tmpx = x;\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n        }\n        var length = Math.sqrt(x * x + y * y + z * z);\n        return [x / length, y / length, z / length];\n      }\n      function dot(x, y, z, vec3) {\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\n      }\n    },\n    quantizedEncode: function (array, bytes) {\n      let quantized, segments;\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n      const decodeMat = new Matrix4();\n      const min = new Float32Array(3);\n      const max = new Float32Array(3);\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n      for (let i = 0; i < array.length; i += 3) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        min[2] = Math.min(min[2], array[i + 2]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n        max[2] = Math.max(max[2], array[i + 2]);\n      }\n      decodeMat.scale(new Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n      decodeMat.elements[12] = min[0];\n      decodeMat.elements[13] = min[1];\n      decodeMat.elements[14] = min[2];\n      decodeMat.transpose();\n      const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n      for (let i = 0; i < array.length; i += 3) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n      }\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    },\n    quantizedEncodeUV: function (array, bytes) {\n      let quantized, segments;\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n      const decodeMat = new Matrix3();\n      const min = new Float32Array(2);\n      const max = new Float32Array(2);\n      min[0] = min[1] = Number.MAX_VALUE;\n      max[0] = max[1] = -Number.MAX_VALUE;\n      for (let i = 0; i < array.length; i += 2) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n      }\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n      decodeMat.elements[6] = min[0];\n      decodeMat.elements[7] = min[1];\n      decodeMat.transpose();\n      const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n      for (let i = 0; i < array.length; i += 2) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n      }\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    }\n  }\n};\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\n\nclass PackedPhongMaterial extends MeshPhongMaterial {\n  constructor(parameters) {\n    super();\n    this.defines = {};\n    this.type = 'PackedPhongMaterial';\n    this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.uv2_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, 'void main() {', ShaderChunk.uv_vertex, `#ifdef USE_UV\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.uv2_vertex, ShaderChunk.color_vertex, ShaderChunk.beginnormal_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`, ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\tvNormal = normalize( transformedNormal );', '#endif', ShaderChunk.begin_vertex, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, '}'].join('\\n'); // Use the original MeshPhongMaterial's fragmentShader.\n\n    this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', ShaderChunk.common, ShaderChunk.packing, ShaderChunk.dithering_pars_fragment, ShaderChunk.color_pars_fragment, ShaderChunk.uv_pars_fragment, ShaderChunk.uv2_pars_fragment, ShaderChunk.map_pars_fragment, ShaderChunk.alphamap_pars_fragment, ShaderChunk.aomap_pars_fragment, ShaderChunk.lightmap_pars_fragment, ShaderChunk.emissivemap_pars_fragment, ShaderChunk.envmap_common_pars_fragment, ShaderChunk.envmap_pars_fragment, ShaderChunk.cube_uv_reflection_fragment, ShaderChunk.fog_pars_fragment, ShaderChunk.bsdfs, ShaderChunk.lights_pars_begin, ShaderChunk.lights_phong_pars_fragment, ShaderChunk.shadowmap_pars_fragment, ShaderChunk.bumpmap_pars_fragment, ShaderChunk.normalmap_pars_fragment, ShaderChunk.specularmap_pars_fragment, ShaderChunk.logdepthbuf_pars_fragment, ShaderChunk.clipping_planes_pars_fragment, 'void main() {', ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', ShaderChunk.logdepthbuf_fragment, ShaderChunk.map_fragment, ShaderChunk.color_fragment, ShaderChunk.alphamap_fragment, ShaderChunk.alphatest_fragment, ShaderChunk.specularmap_fragment, ShaderChunk.normal_fragment_begin, ShaderChunk.normal_fragment_maps, ShaderChunk.emissivemap_fragment,\n    // accumulation\n    ShaderChunk.lights_phong_fragment, ShaderChunk.lights_fragment_begin, ShaderChunk.lights_fragment_maps, ShaderChunk.lights_fragment_end,\n    // modulation\n    ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', ShaderChunk.tonemapping_fragment, ShaderChunk.encodings_fragment, ShaderChunk.fog_fragment, ShaderChunk.premultiplied_alpha_fragment, ShaderChunk.dithering_fragment, '}'].join('\\n');\n    this.setValues(parameters);\n  }\n}\nexport { GeometryCompressionUtils, PackedPhongMaterial };","map":{"version":3,"names":["BufferAttribute","Matrix4","Vector3","Matrix3","MeshPhongMaterial","UniformsUtils","ShaderLib","ShaderChunk","GeometryCompressionUtils","compressNormals","mesh","encodeMethod","geometry","console","error","normal","attributes","isPacked","itemSize","array","count","result","Uint8Array","idx","length","encoded","EncodingFuncs","defaultEncode","setAttribute","bytes","Int8Array","octEncodeBest","Int16Array","Uint16Array","anglesEncode","needsUpdate","packingMethod","material","PackedPhongMaterial","copy","defines","USE_PACKED_NORMAL","compressPositions","position","encodingBytes","quantizedEncode","quantized","decodeMat","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","USE_PACKED_POSITION","uniforms","quantizeMatPos","value","compressUvs","uvs","uv","range","min","Infinity","max","i","Math","USE_PACKED_UV","quantizedEncodeUV","quantizeMatUV","x","y","z","tmpx","round","tmpy","tmpz","defaultDecode","normal0","parseInt","atan2","PI","normal1","oct","dec","best","currentCos","bestCos","octEncodeVec3","octDecodeVec2","dot","x0","y0","z0","xfunc","yfunc","abs","tempx","tempy","diff","sqrt","vec3","segments","Float32Array","Number","MAX_VALUE","scale","elements","transpose","multiplier","floor","constructor","parameters","type","merge","phong","vertexShader","common","uv_pars_vertex","uv2_pars_vertex","displacementmap_pars_vertex","envmap_pars_vertex","color_pars_vertex","fog_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","uv2_vertex","color_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","envmap_vertex","shadowmap_vertex","fog_vertex","join","fragmentShader","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","uv2_pars_fragment","map_pars_fragment","alphamap_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","envmap_common_pars_fragment","envmap_pars_fragment","cube_uv_reflection_fragment","fog_pars_fragment","bsdfs","lights_pars_begin","lights_phong_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","specularmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","specularmap_fragment","normal_fragment_begin","normal_fragment_maps","emissivemap_fragment","lights_phong_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","envmap_fragment","tonemapping_fragment","encodings_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment","setValues"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/utils/GeometryCompressionUtils.js"],"sourcesContent":["import { BufferAttribute, Matrix4, Vector3, Matrix3, MeshPhongMaterial, UniformsUtils, ShaderLib, ShaderChunk } from 'three';\n\n/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\nvar GeometryCompressionUtils = {\n  /**\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n   *\n   */\n  compressNormals: function (mesh, encodeMethod) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    const normal = mesh.geometry.attributes.normal;\n\n    if (!normal) {\n      console.error('Geometry must contain normal attribute. ');\n    }\n\n    if (normal.isPacked) return;\n\n    if (normal.itemSize != 3) {\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\n    }\n\n    const array = normal.array;\n    const count = normal.count;\n    let result;\n\n    if (encodeMethod == 'DEFAULT') {\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n      result = new Uint8Array(count * 3);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx + 0] = encoded[0];\n        result[idx + 1] = encoded[1];\n        result[idx + 2] = encoded[2];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 3, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT1Byte') {\n      /**\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n       */\n      result = new Int8Array(count * 2);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT2Byte') {\n      result = new Int16Array(count * 2);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else if (encodeMethod == 'ANGLES') {\n      result = new Uint16Array(count * 2);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else {\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n    }\n\n    mesh.geometry.attributes.normal.needsUpdate = true;\n    mesh.geometry.attributes.normal.isPacked = true;\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    if (encodeMethod == 'ANGLES') {\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\n    }\n\n    if (encodeMethod == 'OCT1Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'OCT2Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'DEFAULT') {\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\n    }\n  },\n\n  /**\n   * Make the input mesh.geometry's position attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressPositions: function (mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    const position = mesh.geometry.attributes.position;\n\n    if (!position) {\n      console.error('Geometry must contain position attribute. ');\n    }\n\n    if (position.isPacked) return;\n\n    if (position.itemSize != 3) {\n      console.error('position.itemSize is not 3, which cannot be packed. ');\n    }\n\n    const array = position.array;\n    const encodingBytes = 2;\n    const result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n    const quantized = result.quantized;\n    const decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n    mesh.geometry.setAttribute('position', new BufferAttribute(quantized, 3));\n    mesh.geometry.attributes.position.isPacked = true;\n    mesh.geometry.attributes.position.needsUpdate = true;\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    mesh.material.defines.USE_PACKED_POSITION = 0;\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n  },\n\n  /**\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressUvs: function (mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry property. ');\n    }\n\n    const uvs = mesh.geometry.attributes.uv;\n\n    if (!uvs) {\n      console.error('Geometry must contain uv attribute. ');\n    }\n\n    if (uvs.isPacked) return;\n    const range = {\n      min: Infinity,\n      max: -Infinity\n    };\n    const array = uvs.array;\n\n    for (let i = 0; i < array.length; i++) {\n      range.min = Math.min(range.min, array[i]);\n      range.max = Math.max(range.max, array[i]);\n    }\n\n    let result;\n\n    if (range.min >= -1.0 && range.max <= 1.0) {\n      // use default encoding method\n      result = new Uint16Array(array.length);\n\n      for (let i = 0; i < array.length; i += 2) {\n        const encoded = this.EncodingFuncs.defaultEncode(array[i], array[i + 1], 0, 2);\n        result[i] = encoded[0];\n        result[i + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 0;\n    } else {\n      // use quantized encoding method\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result.quantized, 2));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 1;\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n    }\n  },\n  EncodingFuncs: {\n    defaultEncode: function (x, y, z, bytes) {\n      if (bytes == 1) {\n        const tmpx = Math.round((x + 1) * 0.5 * 255);\n        const tmpy = Math.round((y + 1) * 0.5 * 255);\n        const tmpz = Math.round((z + 1) * 0.5 * 255);\n        return new Uint8Array([tmpx, tmpy, tmpz]);\n      } else if (bytes == 2) {\n        const tmpx = Math.round((x + 1) * 0.5 * 65535);\n        const tmpy = Math.round((y + 1) * 0.5 * 65535);\n        const tmpz = Math.round((z + 1) * 0.5 * 65535);\n        return new Uint16Array([tmpx, tmpy, tmpz]);\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    defaultDecode: function (array, bytes) {\n      if (bytes == 1) {\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\n      } else if (bytes == 2) {\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    // for `Angles` encoding\n    anglesEncode: function (x, y, z) {\n      const normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n      const normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n      return new Uint16Array([normal0, normal1]);\n    },\n    // for `Octahedron` encoding\n    octEncodeBest: function (x, y, z, bytes) {\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\n      // to minimize rounding errors\n\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n      dec = octDecodeVec2(oct);\n      bestCos = dot(x, y, z, dec);\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n      }\n\n      return best;\n\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n\n        if (z < 0) {\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n          x = tempx;\n          y = tempy;\n          var diff = 1 - Math.abs(x) - Math.abs(y);\n\n          if (diff > 0) {\n            diff += 0.001;\n            x += x > 0 ? diff / 2 : -diff / 2;\n            y += y > 0 ? diff / 2 : -diff / 2;\n          }\n        }\n\n        if (bytes == 1) {\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n        }\n\n        if (bytes == 2) {\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n        }\n      }\n\n      function octDecodeVec2(oct) {\n        var x = oct[0];\n        var y = oct[1];\n\n        if (bytes == 1) {\n          x /= x < 0 ? 127 : 128;\n          y /= y < 0 ? 127 : 128;\n        } else if (bytes == 2) {\n          x /= x < 0 ? 32767 : 32768;\n          y /= y < 0 ? 32767 : 32768;\n        }\n\n        var z = 1 - Math.abs(x) - Math.abs(y);\n\n        if (z < 0) {\n          var tmpx = x;\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n        }\n\n        var length = Math.sqrt(x * x + y * y + z * z);\n        return [x / length, y / length, z / length];\n      }\n\n      function dot(x, y, z, vec3) {\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\n      }\n    },\n    quantizedEncode: function (array, bytes) {\n      let quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      const decodeMat = new Matrix4();\n      const min = new Float32Array(3);\n      const max = new Float32Array(3);\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n\n      for (let i = 0; i < array.length; i += 3) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        min[2] = Math.min(min[2], array[i + 2]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n        max[2] = Math.max(max[2], array[i + 2]);\n      }\n\n      decodeMat.scale(new Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n      decodeMat.elements[12] = min[0];\n      decodeMat.elements[13] = min[1];\n      decodeMat.elements[14] = min[2];\n      decodeMat.transpose();\n      const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n\n      for (let i = 0; i < array.length; i += 3) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    },\n    quantizedEncodeUV: function (array, bytes) {\n      let quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      const decodeMat = new Matrix3();\n      const min = new Float32Array(2);\n      const max = new Float32Array(2);\n      min[0] = min[1] = Number.MAX_VALUE;\n      max[0] = max[1] = -Number.MAX_VALUE;\n\n      for (let i = 0; i < array.length; i += 2) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n      }\n\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n      decodeMat.elements[6] = min[0];\n      decodeMat.elements[7] = min[1];\n      decodeMat.transpose();\n      const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n\n      for (let i = 0; i < array.length; i += 2) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    }\n  }\n};\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\n\nclass PackedPhongMaterial extends MeshPhongMaterial {\n  constructor(parameters) {\n    super();\n    this.defines = {};\n    this.type = 'PackedPhongMaterial';\n    this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.uv2_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, 'void main() {', ShaderChunk.uv_vertex, `#ifdef USE_UV\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.uv2_vertex, ShaderChunk.color_vertex, ShaderChunk.beginnormal_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`, ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\tvNormal = normalize( transformedNormal );', '#endif', ShaderChunk.begin_vertex, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, '}'].join('\\n'); // Use the original MeshPhongMaterial's fragmentShader.\n\n    this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', ShaderChunk.common, ShaderChunk.packing, ShaderChunk.dithering_pars_fragment, ShaderChunk.color_pars_fragment, ShaderChunk.uv_pars_fragment, ShaderChunk.uv2_pars_fragment, ShaderChunk.map_pars_fragment, ShaderChunk.alphamap_pars_fragment, ShaderChunk.aomap_pars_fragment, ShaderChunk.lightmap_pars_fragment, ShaderChunk.emissivemap_pars_fragment, ShaderChunk.envmap_common_pars_fragment, ShaderChunk.envmap_pars_fragment, ShaderChunk.cube_uv_reflection_fragment, ShaderChunk.fog_pars_fragment, ShaderChunk.bsdfs, ShaderChunk.lights_pars_begin, ShaderChunk.lights_phong_pars_fragment, ShaderChunk.shadowmap_pars_fragment, ShaderChunk.bumpmap_pars_fragment, ShaderChunk.normalmap_pars_fragment, ShaderChunk.specularmap_pars_fragment, ShaderChunk.logdepthbuf_pars_fragment, ShaderChunk.clipping_planes_pars_fragment, 'void main() {', ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', ShaderChunk.logdepthbuf_fragment, ShaderChunk.map_fragment, ShaderChunk.color_fragment, ShaderChunk.alphamap_fragment, ShaderChunk.alphatest_fragment, ShaderChunk.specularmap_fragment, ShaderChunk.normal_fragment_begin, ShaderChunk.normal_fragment_maps, ShaderChunk.emissivemap_fragment, // accumulation\n    ShaderChunk.lights_phong_fragment, ShaderChunk.lights_fragment_begin, ShaderChunk.lights_fragment_maps, ShaderChunk.lights_fragment_end, // modulation\n    ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', ShaderChunk.tonemapping_fragment, ShaderChunk.encodings_fragment, ShaderChunk.fog_fragment, ShaderChunk.premultiplied_alpha_fragment, ShaderChunk.dithering_fragment, '}'].join('\\n');\n    this.setValues(parameters);\n  }\n\n}\n\nexport { GeometryCompressionUtils, PackedPhongMaterial };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}