{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from 'three';\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, url));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n      do {\n        ctrl = inData[inPtr++];\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n      return outData;\n    }\n    function parseHeader(data) {\n      const PCDheader = {};\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.substr(0, PCDheader.headerLen); // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, ''); // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str); // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n      PCDheader.offset = {};\n      let sizeSum = 0;\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i;\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum;\n          sizeSum += PCDheader.size[i] * PCDheader.count[i];\n        }\n      } // for binary only\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n    const textData = LoaderUtils.decodeText(new Uint8Array(data)); // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData); // parse data\n\n    const position = [];\n    const normal = [];\n    const color = []; // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset;\n      const pcdData = textData.substr(PCDheader.headerLen);\n      const lines = pcdData.split('\\n');\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        const line = lines[i].split(' ');\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n        if (offset.rgb !== undefined) {\n          const rgb = parseFloat(line[offset.rgb]);\n          const r = rgb >> 16 & 0x0000ff;\n          const g = rgb >> 8 & 0x0000ff;\n          const b = rgb >> 0 & 0x0000ff;\n          color.push(r / 255, g / 255, b / 255);\n        }\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    } // binary-compressed\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0);\n        }\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian));\n        }\n      }\n    } // binary\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n        }\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    } // build geometry\n\n    const geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere(); // build material\n\n    const material = new PointsMaterial({\n      size: 0.005\n    });\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 0xffffff);\n    } // build point cloud\n\n    const mesh = new Points(geometry, material);\n    let name = url.split('').reverse().join('');\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split('').reverse().join('');\n    mesh.name = name;\n    return mesh;\n  }\n}\nexport { PCDLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","PointsMaterial","Points","PCDLoader","constructor","manager","littleEndian","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","PCDheader","result1","search","result2","exec","substr","headerLen","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","textData","decodeText","position","normal","color","pcdData","lines","line","undefined","y","z","rgb","r","g","b","normal_x","normal_y","normal_z","sizes","Uint32Array","slice","compressedSize","decompressedSize","decompressed","dataview","DataView","buffer","getFloat32","getUint8","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors","setHex","Math","random","mesh","name","reverse","join"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/PCDLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from 'three';\n\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, url));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n\n      do {\n        ctrl = inData[inPtr++];\n\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n\n      return outData;\n    }\n\n    function parseHeader(data) {\n      const PCDheader = {};\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.substr(0, PCDheader.headerLen); // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, ''); // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str); // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n\n      PCDheader.offset = {};\n      let sizeSum = 0;\n\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i;\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum;\n          sizeSum += PCDheader.size[i] * PCDheader.count[i];\n        }\n      } // for binary only\n\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n\n    const textData = LoaderUtils.decodeText(new Uint8Array(data)); // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData); // parse data\n\n    const position = [];\n    const normal = [];\n    const color = []; // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset;\n      const pcdData = textData.substr(PCDheader.headerLen);\n      const lines = pcdData.split('\\n');\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        const line = lines[i].split(' ');\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n\n        if (offset.rgb !== undefined) {\n          const rgb = parseFloat(line[offset.rgb]);\n          const r = rgb >> 16 & 0x0000ff;\n          const g = rgb >> 8 & 0x0000ff;\n          const b = rgb >> 0 & 0x0000ff;\n          color.push(r / 255, g / 255, b / 255);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    } // binary-compressed\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian));\n        }\n      }\n    } // binary\n\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    } // build geometry\n\n\n    const geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere(); // build material\n\n    const material = new PointsMaterial({\n      size: 0.005\n    });\n\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 0xffffff);\n    } // build point cloud\n\n\n    const mesh = new Points(geometry, material);\n    let name = url.split('').reverse().join('');\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split('').reverse().join('');\n    mesh.name = name;\n    return mesh;\n  }\n\n}\n\nexport { PCDLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}