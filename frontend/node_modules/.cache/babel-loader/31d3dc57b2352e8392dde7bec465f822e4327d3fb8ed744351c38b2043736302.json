{"ast":null,"code":"import { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from 'three';\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n}\nclass XREstimatedLight extends Group {\n  constructor(renderer) {\n    let environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n}\nexport { XREstimatedLight };","map":{"version":3,"names":["Group","LightProbe","DirectionalLight","WebGLCubeRenderTarget","SessionLightProbe","constructor","xrLight","renderer","lightProbe","environmentEstimation","estimationStartCallback","xrWebGLBinding","frameCallback","onXRFrame","bind","session","xr","getSession","window","cubeRenderTarget","environment","texture","gl","getContext","preferredReflectionFormat","getExtension","XRWebGLBinding","addEventListener","updateReflection","requestAnimationFrame","textureProperties","properties","get","cubeMap","getReflectionCubeMap","__webglTexture","needsPMREMUpdate","time","xrFrame","lightEstimate","getLightEstimate","sh","fromArray","sphericalHarmonicsCoefficients","intensity","intensityScalar","Math","max","primaryLightIntensity","x","y","z","directionalLight","color","setRGB","position","copy","primaryLightDirection","dispose","XREstimatedLight","add","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","then","probe","dispatchEvent","type","remove"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/webxr/XREstimatedLight.js"],"sourcesContent":["import { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from 'three';\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n\n}\n\nclass XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n\n}\n\nexport { XREstimatedLight };\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,qBAAqB,QAAQ,OAAO;AAElF,MAAMC,iBAAiB,CAAC;EACtBC,WAAW,CAACC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,qBAAqB,EAAEC,uBAAuB,EAAE;IACzF,IAAI,CAACJ,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACG,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACD,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACE,aAAa,GAAG,IAAI,CAACC,SAAS,CAACC,IAAI,CAAC,IAAI,CAAC;IAC9C,MAAMC,OAAO,GAAGR,QAAQ,CAACS,EAAE,CAACC,UAAU,EAAE,CAAC,CAAC;IAC1C;;IAEA,IAAIR,qBAAqB,IAAI,gBAAgB,IAAIS,MAAM,EAAE;MACvD;MACA,MAAMC,gBAAgB,GAAG,IAAIhB,qBAAqB,CAAC,EAAE,CAAC;MACtDG,OAAO,CAACc,WAAW,GAAGD,gBAAgB,CAACE,OAAO;MAC9C,MAAMC,EAAE,GAAGf,QAAQ,CAACgB,UAAU,EAAE,CAAC,CAAC;;MAElC,QAAQR,OAAO,CAACS,yBAAyB;QACvC,KAAK,QAAQ;UACXF,EAAE,CAACG,YAAY,CAAC,UAAU,CAAC;UAC3B;QAEF,KAAK,SAAS;UACZH,EAAE,CAACG,YAAY,CAAC,wBAAwB,CAAC;UACzC;MAAM;MAGV,IAAI,CAACd,cAAc,GAAG,IAAIe,cAAc,CAACX,OAAO,EAAEO,EAAE,CAAC;MACrD,IAAI,CAACd,UAAU,CAACmB,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;QACzD,IAAI,CAACC,gBAAgB,EAAE;MACzB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF;;IAGAb,OAAO,CAACc,qBAAqB,CAAC,IAAI,CAACjB,aAAa,CAAC;EACnD;EAEAgB,gBAAgB,GAAG;IACjB,MAAME,iBAAiB,GAAG,IAAI,CAACvB,QAAQ,CAACwB,UAAU,CAACC,GAAG,CAAC,IAAI,CAAC1B,OAAO,CAACc,WAAW,CAAC;IAEhF,IAAIU,iBAAiB,EAAE;MACrB,MAAMG,OAAO,GAAG,IAAI,CAACtB,cAAc,CAACuB,oBAAoB,CAAC,IAAI,CAAC1B,UAAU,CAAC;MAEzE,IAAIyB,OAAO,EAAE;QACXH,iBAAiB,CAACK,cAAc,GAAGF,OAAO;QAC1C,IAAI,CAAC3B,OAAO,CAACc,WAAW,CAACgB,gBAAgB,GAAG,IAAI;MAClD;IACF;EACF;EAEAvB,SAAS,CAACwB,IAAI,EAAEC,OAAO,EAAE;IACvB;IACA;IACA,IAAI,CAAC,IAAI,CAAChC,OAAO,EAAE;MACjB;IACF;IAEA,MAAMS,OAAO,GAAGuB,OAAO,CAACvB,OAAO;IAC/BA,OAAO,CAACc,qBAAqB,CAAC,IAAI,CAACjB,aAAa,CAAC;IACjD,MAAM2B,aAAa,GAAGD,OAAO,CAACE,gBAAgB,CAAC,IAAI,CAAChC,UAAU,CAAC;IAE/D,IAAI+B,aAAa,EAAE;MACjB;MACA,IAAI,CAACjC,OAAO,CAACE,UAAU,CAACiC,EAAE,CAACC,SAAS,CAACH,aAAa,CAACI,8BAA8B,CAAC;MAClF,IAAI,CAACrC,OAAO,CAACE,UAAU,CAACoC,SAAS,GAAG,GAAG,CAAC,CAAC;MACzC;;MAEA,MAAMC,eAAe,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAG,EAAED,IAAI,CAACC,GAAG,CAACR,aAAa,CAACS,qBAAqB,CAACC,CAAC,EAAEH,IAAI,CAACC,GAAG,CAACR,aAAa,CAACS,qBAAqB,CAACE,CAAC,EAAEX,aAAa,CAACS,qBAAqB,CAACG,CAAC,CAAC,CAAC,CAAC;MAC9K,IAAI,CAAC7C,OAAO,CAAC8C,gBAAgB,CAACC,KAAK,CAACC,MAAM,CAACf,aAAa,CAACS,qBAAqB,CAACC,CAAC,GAAGJ,eAAe,EAAEN,aAAa,CAACS,qBAAqB,CAACE,CAAC,GAAGL,eAAe,EAAEN,aAAa,CAACS,qBAAqB,CAACG,CAAC,GAAGN,eAAe,CAAC;MACrN,IAAI,CAACvC,OAAO,CAAC8C,gBAAgB,CAACR,SAAS,GAAGC,eAAe;MACzD,IAAI,CAACvC,OAAO,CAAC8C,gBAAgB,CAACG,QAAQ,CAACC,IAAI,CAACjB,aAAa,CAACkB,qBAAqB,CAAC;MAEhF,IAAI,IAAI,CAAC/C,uBAAuB,EAAE;QAChC,IAAI,CAACA,uBAAuB,EAAE;QAC9B,IAAI,CAACA,uBAAuB,GAAG,IAAI;MACrC;IACF;EACF;EAEAgD,OAAO,GAAG;IACR,IAAI,CAACpD,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACG,cAAc,GAAG,IAAI;EAC5B;AAEF;AAEA,MAAMgD,gBAAgB,SAAS3D,KAAK,CAAC;EACnCK,WAAW,CAACE,QAAQ,EAAgC;IAAA,IAA9BE,qBAAqB,uEAAG,IAAI;IAChD,KAAK,EAAE;IACP,IAAI,CAACD,UAAU,GAAG,IAAIP,UAAU,EAAE;IAClC,IAAI,CAACO,UAAU,CAACoC,SAAS,GAAG,CAAC;IAC7B,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACpD,UAAU,CAAC;IACzB,IAAI,CAAC4C,gBAAgB,GAAG,IAAIlD,gBAAgB,EAAE;IAC9C,IAAI,CAACkD,gBAAgB,CAACR,SAAS,GAAG,CAAC;IACnC,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACR,gBAAgB,CAAC,CAAC,CAAC;IACjC;;IAEA,IAAI,CAAChC,WAAW,GAAG,IAAI;IACvB,IAAIyC,iBAAiB,GAAG,IAAI;IAC5B,IAAIC,iBAAiB,GAAG,KAAK;IAC7BvD,QAAQ,CAACS,EAAE,CAACW,gBAAgB,CAAC,cAAc,EAAE,MAAM;MACjD,MAAMZ,OAAO,GAAGR,QAAQ,CAACS,EAAE,CAACC,UAAU,EAAE;MAExC,IAAI,mBAAmB,IAAIF,OAAO,EAAE;QAClCA,OAAO,CAACgD,iBAAiB,CAAC;UACxBC,gBAAgB,EAAEjD,OAAO,CAACS;QAC5B,CAAC,CAAC,CAACyC,IAAI,CAACC,KAAK,IAAI;UACfL,iBAAiB,GAAG,IAAIzD,iBAAiB,CAAC,IAAI,EAAEG,QAAQ,EAAE2D,KAAK,EAAEzD,qBAAqB,EAAE,MAAM;YAC5FqD,iBAAiB,GAAG,IAAI,CAAC,CAAC;;YAE1B,IAAI,CAACK,aAAa,CAAC;cACjBC,IAAI,EAAE;YACR,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IACF7D,QAAQ,CAACS,EAAE,CAACW,gBAAgB,CAAC,YAAY,EAAE,MAAM;MAC/C,IAAIkC,iBAAiB,EAAE;QACrBA,iBAAiB,CAACH,OAAO,EAAE;QAC3BG,iBAAiB,GAAG,IAAI;MAC1B;MAEA,IAAIC,iBAAiB,EAAE;QACrB;QACA,IAAI,CAACK,aAAa,CAAC;UACjBC,IAAI,EAAE;QACR,CAAC,CAAC;MACJ;IACF,CAAC,CAAC,CAAC,CAAC;;IAEJ,IAAI,CAACV,OAAO,GAAG,MAAM;MACnB,IAAIG,iBAAiB,EAAE;QACrBA,iBAAiB,CAACH,OAAO,EAAE;QAC3BG,iBAAiB,GAAG,IAAI;MAC1B;MAEA,IAAI,CAACQ,MAAM,CAAC,IAAI,CAAC7D,UAAU,CAAC;MAC5B,IAAI,CAACA,UAAU,GAAG,IAAI;MACtB,IAAI,CAAC6D,MAAM,CAAC,IAAI,CAACjB,gBAAgB,CAAC;MAClC,IAAI,CAACA,gBAAgB,GAAG,IAAI;MAC5B,IAAI,CAAChC,WAAW,GAAG,IAAI;IACzB,CAAC;EACH;AAEF;AAEA,SAASuC,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}