{"ast":null,"code":"import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n} //\n\nconst canvases = new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n        minY = -Infinity;\n      let maxX = Infinity,\n        maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element, style) {\n    let x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/);\n\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","sRGBEncoding","LinearFilter","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","Clipper","context","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","undefined","set","luminance","sqrt","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","value","property","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","right","bottom","offsetX","proportion","InputEvent","bubbles"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/interactive/HTMLMesh.js"],"sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n} //\n\n\nconst canvases = new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}