{"ast":null,"code":"import { Vector2 } from 'three';\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev) => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius;\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"names":["Vector2","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","shader","needsUpdate"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"sourcesContent":["import { Vector2 } from 'three';\n\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev) => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    const weights = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius;\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\n\nexport { BlurShaderUtils, DepthLimitedBlurShader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}