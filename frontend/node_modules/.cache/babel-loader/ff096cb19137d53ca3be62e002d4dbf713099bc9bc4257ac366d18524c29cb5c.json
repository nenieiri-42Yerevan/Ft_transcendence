{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n      quat = new Quaternion(),\n      scale = new Vector3(),\n      bindBoneMatrix = new Matrix4(),\n      relativeMatrix = new Matrix4(),\n      globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n        bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n        bindBones,\n        bone,\n        name,\n        boneTo,\n        bonesPosition,\n        i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n      if (options.preservePosition) {\n        bonesPosition = [];\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n      if (options.offsets) {\n        bindBones = [];\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n              wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n      delta = 1 / options.fps,\n      convertedTracks = [],\n      mixer = new AnimationMixer(source),\n      bones = this.getBones(target.skeleton),\n      boneDatas = [],\n      positionOffset,\n      bone,\n      boneTo,\n      boneData,\n      name,\n      i,\n      j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n              bone.position.sub(positionOffset);\n            }\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n      targetPos = new Vector3(),\n      sourceParentPos = new Vector3(),\n      sourcePos = new Vector3(),\n      targetDir = new Vector2(),\n      sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n      var nameKeys = Object.keys(options.names),\n        nameValues = Object.values(options.names),\n        sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n        bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n        offsets = [],\n        bone,\n        boneTo,\n        name,\n        i;\n      target.skeleton.pose();\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n            boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n    for (let i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n      result = {\n        name: name\n      };\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n      targetBones = this.getBones(targetSkeleton),\n      bones = [];\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nexport { SkeletonUtils };","map":{"version":3,"names":["Vector3","Quaternion","Matrix4","AnimationMixer","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","SkeletonHelper","Vector2","Euler","SkeletonUtils","retarget","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/utils/SkeletonUtils.js"],"sourcesContent":["import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (let i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}