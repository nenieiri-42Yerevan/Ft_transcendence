{"ast":null,"code":"import { Quaternion, Object3D, Vector3, AnimationMixer } from 'three';\nimport { CCDIKSolver } from './CCDIKSolver.js';\nimport { MMDPhysics } from './MMDPhysics.js';\n\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\n\nconst MMDAnimationHelper = (() => {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper(params) {\n    params = params || {};\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = 'target';\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = new WeakMap();\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n    this.onBeforePhysics = () => /* mesh */\n    {}; // experimental\n\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  MMDAnimationHelper.prototype = {\n    constructor: MMDAnimationHelper,\n    /**\n     * Adds an Three.js Object to helper and setups animation.\n     * The anmation durations of added objects are synched\n     * if this.configuration.sync is true.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @param {Object} params - (optional)\n     * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n     * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n     * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n     * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n     * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n     * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n     * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n     * @return {MMDAnimationHelper}\n     */\n    add: function (object, params) {\n      params = params || {};\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === 'Audio') {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.add: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n    remove: function (object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === 'Audio') {\n        this._clearAudio(object);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.remove: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n    update: function (delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n      for (let i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    },\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n    pose: function (mesh, vpd, params) {\n      params = params || {};\n      if (params.resetPose !== false) mesh.pose();\n      const bones = mesh.skeleton.bones;\n      const boneParams = vpd.bones;\n      const boneNameDictionary = {};\n      for (let i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n      const vector = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, il = boneParams.length; i < il; i++) {\n        const boneParam = boneParams[i];\n        const boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === undefined) continue;\n        const bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n      mesh.updateMatrixWorld(true);\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK); // this param is experimental\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n      return this;\n    },\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n    enable: function (key, enabled) {\n      if (this.enabled[key] === undefined) {\n        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);\n      }\n      this.enabled[key] = enabled;\n      if (key === 'physics') {\n        for (let i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n      return this;\n    },\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n    createGrantSolver: function (mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    },\n    // private methods\n    _addMesh: function (mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);\n      }\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n      this._setupMeshAnimation(mesh, params.animation);\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n      return this;\n    },\n    _setupCamera: function (camera, params) {\n      if (this.camera === camera) {\n        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);\n      }\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n      if (params.animation !== undefined) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n      return this;\n    },\n    _setupAudio: function (audio, params) {\n      if (this.audio === audio) {\n        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);\n      }\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    },\n    _removeMesh: function (mesh) {\n      let found = false;\n      let writeIndex = 0;\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n      if (!found) {\n        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);\n      }\n      this.meshes.length = writeIndex;\n      return this;\n    },\n    _clearCamera: function (camera) {\n      if (camera !== this.camera) {\n        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);\n      }\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    },\n    _clearAudio: function (audio) {\n      if (audio !== this.audio) {\n        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);\n      }\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    },\n    _setupMeshAnimation: function (mesh, animation) {\n      const objects = this.objects.get(mesh);\n      if (animation !== undefined) {\n        const animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n        for (let i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        } // TODO: find a workaround not to access ._clip looking like a private property\n\n        objects.mixer.addEventListener('loop', event => {\n          const tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return;\n          objects.looped = true;\n        });\n      }\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    },\n    _setupCameraAnimation: function (camera, animation) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      const objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    },\n    _setupMeshPhysics: function (mesh, params) {\n      const objects = this.objects.get(mesh); // shared physics is experimental\n\n      if (params.world === undefined && this.sharedPhysics) {\n        const masterPhysics = this._getMasterPhysics();\n        if (masterPhysics !== null) world = masterPhysics.world; // eslint-disable-line no-undef\n      }\n\n      objects.physics = this._createMMDPhysics(mesh, params);\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n        objects.physics.reset();\n      }\n      objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60);\n      this._optimizeIK(mesh, true);\n    },\n    _animateMesh: function (mesh, delta) {\n      const objects = this.objects.get(mesh);\n      const mixer = objects.mixer;\n      const ikSolver = objects.ikSolver;\n      const grantSolver = objects.grantSolver;\n      const physics = objects.physics;\n      const looped = objects.looped; // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n        mixer.update(delta);\n        this._saveBones(mesh);\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    },\n    _animateCamera: function (camera, delta) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    },\n    _optimizeIK: function (mesh, physicsEnabled) {\n      const iks = mesh.geometry.userData.MMD.iks;\n      const bones = mesh.geometry.userData.MMD.bones;\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const links = ik.links;\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          const link = links[j];\n          if (physicsEnabled === true) {\n            // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n            // because its rotation will be overriden by physics\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    },\n    _createCCDIKSolver: function (mesh) {\n      if (CCDIKSolver === undefined) {\n        throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.');\n      }\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    },\n    _createMMDPhysics: function (mesh, params) {\n      if (MMDPhysics === undefined) {\n        throw new Error('THREE.MMDPhysics: Import MMDPhysics.');\n      }\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    },\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n    _syncDuration: function () {\n      let max = 0.0;\n      const objects = this.objects;\n      const meshes = this.meshes;\n      const camera = this.camera;\n      const audioManager = this.audioManager; // get the longest duration\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === undefined) continue;\n        for (let j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            var clip = mixer._actions[i]._clip;\n            if (!objects.has(clip)) {\n              objects.set(clip, {\n                duration: clip.duration\n              });\n            }\n            max = Math.max(max, objects.get(clip).duration);\n          }\n        }\n      }\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n      max += this.configuration.afterglow; // update the duration\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var mixer = this.objects.get(this.meshes[i]).mixer;\n        if (mixer === undefined) continue;\n        for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n          mixer._actions[j]._clip.duration = max;\n        }\n      }\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            mixer._actions[i]._clip.duration = max;\n          }\n        }\n      }\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    },\n    // workaround\n    _updatePropertyMixersBuffer: function (mesh) {\n      const mixer = this.objects.get(mesh).mixer;\n      const propertyMixers = mixer._bindings;\n      const accuIndex = mixer._accuIndex;\n      for (let i = 0, il = propertyMixers.length; i < il; i++) {\n        const propertyMixer = propertyMixers[i];\n        const buffer = propertyMixer.buffer;\n        const stride = propertyMixer.valueSize;\n        const offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    },\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n    _saveBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const bones = mesh.skeleton.bones;\n      let backupBones = objects.backupBones;\n      if (backupBones === undefined) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    },\n    _restoreBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const backupBones = objects.backupBones;\n      if (backupBones === undefined) return;\n      const bones = mesh.skeleton.bones;\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    },\n    // experimental\n    _getMasterPhysics: function () {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        const physics = this.meshes[i].physics;\n        if (physics !== undefined && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n      return null;\n    },\n    _updateSharedPhysics: function (delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n      const physics = this._getMasterPhysics();\n      if (physics === null) return;\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n        if (p !== null && p !== undefined) {\n          p.updateRigidBodies();\n        }\n      }\n      physics.stepSimulation(delta);\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n        if (p !== null && p !== undefined) {\n          p.updateBones();\n        }\n      }\n    }\n  }; //\n\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n\n  function AudioManager(audio, params) {\n    params = params || {};\n    this.audio = audio;\n    this.elapsedTime = 0.0;\n    this.currentTime = 0.0;\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  AudioManager.prototype = {\n    constructor: AudioManager,\n    /**\n     * @param {Number} delta\n     * @return {AudioManager}\n     */\n    control: function (delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    },\n    // private methods\n    _shouldStartAudio: function () {\n      if (this.audio.isPlaying) return false;\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n      if (this.currentTime < this.delayTime) return false; // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    },\n    _shouldStopAudio: function () {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  };\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} grants\n   */\n\n  function GrantSolver(mesh, grants) {\n    this.mesh = mesh;\n    this.grants = grants || [];\n  }\n  GrantSolver.prototype = {\n    constructor: GrantSolver,\n    /**\n     * @return {GrantSolver}\n     */\n    update: (() => {\n      const quaternion = new Quaternion();\n      return function () {\n        const bones = this.mesh.skeleton.bones;\n        const grants = this.grants;\n        for (let i = 0, il = grants.length; i < il; i++) {\n          const grant = grants[i];\n          const bone = bones[grant.index];\n          const parentBone = bones[grant.parentIndex];\n          if (grant.isLocal) {\n            // TODO: implement\n            if (grant.affectPosition) ; // TODO: implement\n\n            if (grant.affectRotation) ;\n          } else {\n            // TODO: implement\n            if (grant.affectPosition) ;\n            if (grant.affectRotation) {\n              quaternion.set(0, 0, 0, 1);\n              quaternion.slerp(parentBone.quaternion, grant.ratio);\n              bone.quaternion.multiply(quaternion);\n            }\n          }\n        }\n        return this;\n      };\n    })()\n  };\n  return MMDAnimationHelper;\n})();\nexport { MMDAnimationHelper };","map":{"version":3,"names":["Quaternion","Object3D","Vector3","AnimationMixer","CCDIKSolver","MMDPhysics","MMDAnimationHelper","params","meshes","camera","cameraTarget","name","audio","audioManager","objects","WeakMap","configuration","sync","undefined","afterglow","resetPhysicsOnLoop","enabled","animation","ik","grant","physics","cameraAnimation","onBeforePhysics","sharedPhysics","masterPhysics","prototype","constructor","add","object","isSkinnedMesh","_addMesh","isCamera","_setupCamera","type","_setupAudio","Error","_syncDuration","remove","_removeMesh","_clearCamera","_clearAudio","update","delta","control","i","length","_animateMesh","_updateSharedPhysics","_animateCamera","pose","mesh","vpd","resetPose","bones","skeleton","boneParams","boneNameDictionary","il","vector","quaternion","boneParam","boneIndex","bone","position","fromArray","translation","multiply","updateMatrixWorld","_createCCDIKSolver","saveOriginalBonesBeforeIK","createGrantSolver","enable","key","_optimizeIK","GrantSolver","geometry","userData","MMD","grants","indexOf","push","set","looped","_setupMeshAnimation","_setupMeshPhysics","clearCamera","_setupCameraAnimation","clearAudio","AudioManager","duration","found","writeIndex","delete","get","animations","Array","isArray","mixer","clipAction","play","addEventListener","event","tracks","action","_clip","slice","ikSolver","grantSolver","world","_getMasterPhysics","_createMMDPhysics","animationWarmup","reset","warmup","_restoreBones","_saveBones","updateProjectionMatrix","up","applyQuaternion","lookAt","physicsEnabled","iks","links","j","jl","link","index","rigidBodyType","rigidBodies","constraints","max","_actions","clip","has","Math","_updatePropertyMixersBuffer","propertyMixers","_bindings","accuIndex","_accuIndex","propertyMixer","buffer","stride","valueSize","offset","binding","getValue","backupBones","Float32Array","toArray","p","updateRigidBodies","stepSimulation","updateBones","elapsedTime","currentTime","delayTime","audioDuration","elapsed","_shouldStopAudio","stop","_shouldStartAudio","isPlaying","parentBone","parentIndex","isLocal","affectPosition","affectRotation","slerp","ratio"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/animation/MMDAnimationHelper.js"],"sourcesContent":["import { Quaternion, Object3D, Vector3, AnimationMixer } from 'three';\nimport { CCDIKSolver } from './CCDIKSolver.js';\nimport { MMDPhysics } from './MMDPhysics.js';\n\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\n\nconst MMDAnimationHelper = (() => {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper(params) {\n    params = params || {};\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = 'target';\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = new WeakMap();\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n\n    this.onBeforePhysics = () =>\n    /* mesh */\n    {}; // experimental\n\n\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n\n  MMDAnimationHelper.prototype = {\n    constructor: MMDAnimationHelper,\n\n    /**\n     * Adds an Three.js Object to helper and setups animation.\n     * The anmation durations of added objects are synched\n     * if this.configuration.sync is true.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @param {Object} params - (optional)\n     * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n     * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n     * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n     * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n     * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n     * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n     * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n     * @return {MMDAnimationHelper}\n     */\n    add: function (object, params) {\n      params = params || {};\n\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === 'Audio') {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.add: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n    remove: function (object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === 'Audio') {\n        this._clearAudio(object);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.remove: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n    update: function (delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n\n      for (let i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    },\n\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n    pose: function (mesh, vpd, params) {\n      params = params || {};\n      if (params.resetPose !== false) mesh.pose();\n      const bones = mesh.skeleton.bones;\n      const boneParams = vpd.bones;\n      const boneNameDictionary = {};\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n\n      const vector = new Vector3();\n      const quaternion = new Quaternion();\n\n      for (let i = 0, il = boneParams.length; i < il; i++) {\n        const boneParam = boneParams[i];\n        const boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === undefined) continue;\n        const bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n\n      mesh.updateMatrixWorld(true);\n\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK); // this param is experimental\n\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n\n      return this;\n    },\n\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n    enable: function (key, enabled) {\n      if (this.enabled[key] === undefined) {\n        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);\n      }\n\n      this.enabled[key] = enabled;\n\n      if (key === 'physics') {\n        for (let i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n    createGrantSolver: function (mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    },\n    // private methods\n    _addMesh: function (mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);\n      }\n\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n\n      this._setupMeshAnimation(mesh, params.animation);\n\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n\n      return this;\n    },\n    _setupCamera: function (camera, params) {\n      if (this.camera === camera) {\n        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);\n      }\n\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n\n      if (params.animation !== undefined) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n\n      return this;\n    },\n    _setupAudio: function (audio, params) {\n      if (this.audio === audio) {\n        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);\n      }\n\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    },\n    _removeMesh: function (mesh) {\n      let found = false;\n      let writeIndex = 0;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n\n      if (!found) {\n        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);\n      }\n\n      this.meshes.length = writeIndex;\n      return this;\n    },\n    _clearCamera: function (camera) {\n      if (camera !== this.camera) {\n        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);\n      }\n\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    },\n    _clearAudio: function (audio) {\n      if (audio !== this.audio) {\n        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);\n      }\n\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    },\n    _setupMeshAnimation: function (mesh, animation) {\n      const objects = this.objects.get(mesh);\n\n      if (animation !== undefined) {\n        const animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n\n        for (let i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        } // TODO: find a workaround not to access ._clip looking like a private property\n\n\n        objects.mixer.addEventListener('loop', event => {\n          const tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return;\n          objects.looped = true;\n        });\n      }\n\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    },\n    _setupCameraAnimation: function (camera, animation) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      const objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    },\n    _setupMeshPhysics: function (mesh, params) {\n      const objects = this.objects.get(mesh); // shared physics is experimental\n\n      if (params.world === undefined && this.sharedPhysics) {\n        const masterPhysics = this._getMasterPhysics();\n\n        if (masterPhysics !== null) world = masterPhysics.world; // eslint-disable-line no-undef\n      }\n\n      objects.physics = this._createMMDPhysics(mesh, params);\n\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n\n        objects.physics.reset();\n      }\n\n      objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60);\n\n      this._optimizeIK(mesh, true);\n    },\n    _animateMesh: function (mesh, delta) {\n      const objects = this.objects.get(mesh);\n      const mixer = objects.mixer;\n      const ikSolver = objects.ikSolver;\n      const grantSolver = objects.grantSolver;\n      const physics = objects.physics;\n      const looped = objects.looped; // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n\n        mixer.update(delta);\n\n        this._saveBones(mesh);\n\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    },\n    _animateCamera: function (camera, delta) {\n      const mixer = this.objects.get(camera).mixer;\n\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    },\n    _optimizeIK: function (mesh, physicsEnabled) {\n      const iks = mesh.geometry.userData.MMD.iks;\n      const bones = mesh.geometry.userData.MMD.bones;\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const links = ik.links;\n\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          const link = links[j];\n\n          if (physicsEnabled === true) {\n            // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n            // because its rotation will be overriden by physics\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    },\n    _createCCDIKSolver: function (mesh) {\n      if (CCDIKSolver === undefined) {\n        throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.');\n      }\n\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    },\n    _createMMDPhysics: function (mesh, params) {\n      if (MMDPhysics === undefined) {\n        throw new Error('THREE.MMDPhysics: Import MMDPhysics.');\n      }\n\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    },\n\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n    _syncDuration: function () {\n      let max = 0.0;\n      const objects = this.objects;\n      const meshes = this.meshes;\n      const camera = this.camera;\n      const audioManager = this.audioManager; // get the longest duration\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === undefined) continue;\n\n        for (let j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            var clip = mixer._actions[i]._clip;\n\n            if (!objects.has(clip)) {\n              objects.set(clip, {\n                duration: clip.duration\n              });\n            }\n\n            max = Math.max(max, objects.get(clip).duration);\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n\n      max += this.configuration.afterglow; // update the duration\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var mixer = this.objects.get(this.meshes[i]).mixer;\n        if (mixer === undefined) continue;\n\n        for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n          mixer._actions[j]._clip.duration = max;\n        }\n      }\n\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            mixer._actions[i]._clip.duration = max;\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    },\n    // workaround\n    _updatePropertyMixersBuffer: function (mesh) {\n      const mixer = this.objects.get(mesh).mixer;\n      const propertyMixers = mixer._bindings;\n      const accuIndex = mixer._accuIndex;\n\n      for (let i = 0, il = propertyMixers.length; i < il; i++) {\n        const propertyMixer = propertyMixers[i];\n        const buffer = propertyMixer.buffer;\n        const stride = propertyMixer.valueSize;\n        const offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    },\n\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n    _saveBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const bones = mesh.skeleton.bones;\n      let backupBones = objects.backupBones;\n\n      if (backupBones === undefined) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    },\n    _restoreBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const backupBones = objects.backupBones;\n      if (backupBones === undefined) return;\n      const bones = mesh.skeleton.bones;\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    },\n    // experimental\n    _getMasterPhysics: function () {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        const physics = this.meshes[i].physics;\n\n        if (physics !== undefined && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n\n      return null;\n    },\n    _updateSharedPhysics: function (delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n\n      const physics = this._getMasterPhysics();\n\n      if (physics === null) return;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== undefined) {\n          p.updateRigidBodies();\n        }\n      }\n\n      physics.stepSimulation(delta);\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== undefined) {\n          p.updateBones();\n        }\n      }\n    }\n  }; //\n\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n\n  function AudioManager(audio, params) {\n    params = params || {};\n    this.audio = audio;\n    this.elapsedTime = 0.0;\n    this.currentTime = 0.0;\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n\n  AudioManager.prototype = {\n    constructor: AudioManager,\n\n    /**\n     * @param {Number} delta\n     * @return {AudioManager}\n     */\n    control: function (delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    },\n    // private methods\n    _shouldStartAudio: function () {\n      if (this.audio.isPlaying) return false;\n\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n\n      if (this.currentTime < this.delayTime) return false; // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    },\n    _shouldStopAudio: function () {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  };\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} grants\n   */\n\n  function GrantSolver(mesh, grants) {\n    this.mesh = mesh;\n    this.grants = grants || [];\n  }\n\n  GrantSolver.prototype = {\n    constructor: GrantSolver,\n\n    /**\n     * @return {GrantSolver}\n     */\n    update: (() => {\n      const quaternion = new Quaternion();\n      return function () {\n        const bones = this.mesh.skeleton.bones;\n        const grants = this.grants;\n\n        for (let i = 0, il = grants.length; i < il; i++) {\n          const grant = grants[i];\n          const bone = bones[grant.index];\n          const parentBone = bones[grant.parentIndex];\n\n          if (grant.isLocal) {\n            // TODO: implement\n            if (grant.affectPosition) ; // TODO: implement\n\n\n            if (grant.affectRotation) ;\n          } else {\n            // TODO: implement\n            if (grant.affectPosition) ;\n\n            if (grant.affectRotation) {\n              quaternion.set(0, 0, 0, 1);\n              quaternion.slerp(parentBone.quaternion, grant.ratio);\n              bone.quaternion.multiply(quaternion);\n            }\n          }\n        }\n\n        return this;\n      };\n    })()\n  };\n  return MMDAnimationHelper;\n})();\n\nexport { MMDAnimationHelper };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}