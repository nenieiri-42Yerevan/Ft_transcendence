{"ast":null,"code":"import { Vector2 } from 'three';\n\n/**\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\n\nvar UVsDebug = function (geometry, size) {\n  // handles wrapping of uv.x > 1 only\n  var abc = 'abc';\n  var a = new Vector2();\n  var b = new Vector2();\n  var uvs = [new Vector2(), new Vector2(), new Vector2()];\n  var face = [];\n  var canvas = document.createElement('canvas');\n  var width = size || 1024; // power of 2 required for wrapping\n\n  var height = size || 1024;\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\n  ctx.textAlign = 'center'; // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\n  ctx.fillRect(0, 0, width, height);\n  if (geometry.isGeometry) {\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\n    return;\n  } else {\n    var index = geometry.index;\n    var uvAttribute = geometry.attributes.uv;\n    if (index) {\n      // indexed geometry\n      for (let i = 0, il = index.count; i < il; i += 3) {\n        face[0] = index.getX(i);\n        face[1] = index.getX(i + 1);\n        face[2] = index.getX(i + 2);\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    } else {\n      // non-indexed geometry\n      for (let i = 0, il = uvAttribute.count; i < il; i += 3) {\n        face[0] = i;\n        face[1] = i + 1;\n        face[2] = i + 2;\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    }\n  }\n  return canvas;\n  function processFace(face, uvs, index) {\n    // draw contour of face\n    ctx.beginPath();\n    a.set(0, 0);\n    for (let j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      a.x += uv.x;\n      a.y += uv.y;\n      if (j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n    ctx.closePath();\n    ctx.stroke(); // calculate center of face\n\n    a.divideScalar(uvs.length); // label the face number\n\n    ctx.font = '18px Arial';\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\n    } //\n\n    ctx.font = '12px Arial';\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\n\n    for (j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      b.addVectors(a, uv).divideScalar(2);\n      var vnum = face[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n      if (b.x > 0.95) {\n        // wrap x\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n};\nexport { UVsDebug };","map":{"version":3,"names":["Vector2","UVsDebug","geometry","size","abc","a","b","uvs","face","canvas","document","createElement","width","height","ctx","getContext","lineWidth","strokeStyle","textAlign","fillStyle","fillRect","isGeometry","console","error","index","uvAttribute","attributes","uv","i","il","count","getX","fromBufferAttribute","processFace","beginPath","set","j","jl","length","x","y","moveTo","lineTo","closePath","stroke","divideScalar","font","fillText","addVectors","vnum"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/utils/UVsDebug.js"],"sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\n\nvar UVsDebug = function (geometry, size) {\n  // handles wrapping of uv.x > 1 only\n  var abc = 'abc';\n  var a = new Vector2();\n  var b = new Vector2();\n  var uvs = [new Vector2(), new Vector2(), new Vector2()];\n  var face = [];\n  var canvas = document.createElement('canvas');\n  var width = size || 1024; // power of 2 required for wrapping\n\n  var height = size || 1024;\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\n  ctx.textAlign = 'center'; // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\n  ctx.fillRect(0, 0, width, height);\n\n  if (geometry.isGeometry) {\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\n    return;\n  } else {\n    var index = geometry.index;\n    var uvAttribute = geometry.attributes.uv;\n\n    if (index) {\n      // indexed geometry\n      for (let i = 0, il = index.count; i < il; i += 3) {\n        face[0] = index.getX(i);\n        face[1] = index.getX(i + 1);\n        face[2] = index.getX(i + 2);\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    } else {\n      // non-indexed geometry\n      for (let i = 0, il = uvAttribute.count; i < il; i += 3) {\n        face[0] = i;\n        face[1] = i + 1;\n        face[2] = i + 2;\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    }\n  }\n\n  return canvas;\n\n  function processFace(face, uvs, index) {\n    // draw contour of face\n    ctx.beginPath();\n    a.set(0, 0);\n\n    for (let j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      a.x += uv.x;\n      a.y += uv.y;\n\n      if (j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke(); // calculate center of face\n\n    a.divideScalar(uvs.length); // label the face number\n\n    ctx.font = '18px Arial';\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\n\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\n    } //\n\n\n    ctx.font = '12px Arial';\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\n\n    for (j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      b.addVectors(a, uv).divideScalar(2);\n      var vnum = face[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n\n      if (b.x > 0.95) {\n        // wrap x\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n};\n\nexport { UVsDebug };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}