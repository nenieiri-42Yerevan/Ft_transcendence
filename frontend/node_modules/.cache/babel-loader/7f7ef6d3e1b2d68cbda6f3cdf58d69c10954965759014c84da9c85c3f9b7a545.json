{"ast":null,"code":"import { Vector2, Matrix4 } from 'three';\nconst SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    cameraNear: {\n      value: 1\n    },\n    cameraFar: {\n      value: 100\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    scale: {\n      value: 1.0\n    },\n    intensity: {\n      value: 0.1\n    },\n    bias: {\n      value: 0.5\n    },\n    minResolution: {\n      value: 0.0\n    },\n    kernelRadius: {\n      value: 100.0\n    },\n    randomSeed: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\n};\nexport { SAOShader };","map":{"version":3,"names":["Vector2","Matrix4","SAOShader","defines","NUM_SAMPLES","NUM_RINGS","NORMAL_TEXTURE","DIFFUSE_TEXTURE","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDepth","value","tDiffuse","tNormal","size","cameraNear","cameraFar","cameraProjectionMatrix","cameraInverseProjectionMatrix","scale","intensity","bias","minResolution","kernelRadius","randomSeed","vertexShader","join","fragmentShader"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/shaders/SAOShader.js"],"sourcesContent":["import { Vector2, Matrix4 } from 'three';\n\nconst SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    cameraNear: {\n      value: 1\n    },\n    cameraFar: {\n      value: 100\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    scale: {\n      value: 1.0\n    },\n    intensity: {\n      value: 0.1\n    },\n    bias: {\n      value: 0.5\n    },\n    minResolution: {\n      value: 0.0\n    },\n    kernelRadius: {\n      value: 100.0\n    },\n    randomSeed: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\n};\n\nexport { SAOShader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}