{"ast":null,"code":"import { Matrix4, Vector3 } from 'three';\nconst inverseProjectionMatrix = new Matrix4();\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n      }\n    });\n    return this.vertices;\n  }\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n    target.length = breaks.length;\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n}\nexport { CSMFrustum };","map":{"version":3,"names":["Matrix4","Vector3","inverseProjectionMatrix","CSMFrustum","constructor","data","vertices","near","far","projectionMatrix","undefined","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","split","breaks","target","length","push","i","cascade","j","lerpVectors","toSpace","cameraMatrix"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/csm/CSMFrustum.js"],"sourcesContent":["import { Matrix4, Vector3 } from 'three';\n\nconst inverseProjectionMatrix = new Matrix4();\n\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n      }\n    });\n    return this.vertices;\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n\n    target.length = breaks.length;\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n\n}\n\nexport { CSMFrustum };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}