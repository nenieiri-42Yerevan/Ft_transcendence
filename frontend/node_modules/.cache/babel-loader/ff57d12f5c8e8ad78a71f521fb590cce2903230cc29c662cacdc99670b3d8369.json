{"ast":null,"code":"import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from 'three';\nconst isCubeTexture = def => def && def.isCubeTexture;\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _ref, _texture$image$;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_ref = isCubeMap ? (_texture$image$ = texture.image[0]) === null || _texture$image$ === void 0 ? void 0 : _texture$image$.width : texture.image.width) != null ? _ref : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '', `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`, `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`, `#define CUBEUV_MAX_MIP ${_lodMax}.0`];\n    const vertexShader = /* glsl */\n    `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n    const fragmentShader = defines.join('\\n') + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n        }\n        `;\n    const uniforms = {\n      map: {\n        value: texture\n      },\n      height: {\n        value: (options === null || options === void 0 ? void 0 : options.height) || 15\n      },\n      radius: {\n        value: (options === null || options === void 0 ? void 0 : options.radius) || 100\n      }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\nexport { GroundProjectedEnv };","map":{"version":3,"names":["Mesh","IcosahedronGeometry","ShaderMaterial","DoubleSide","isCubeTexture","def","GroundProjectedEnv","constructor","texture","options","_ref","_texture$image$","isCubeMap","w","image","width","cubeSize","_lodMax","Math","floor","log2","_cubeSize","pow","max","height","defines","vertexShader","fragmentShader","join","uniforms","map","value","radius","geometry","material","side"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/objects/GroundProjectedEnv.js"],"sourcesContent":["import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from 'three';\n\nconst isCubeTexture = def => def && def.isCubeTexture;\n\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _ref, _texture$image$;\n\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_ref = isCubeMap ? (_texture$image$ = texture.image[0]) === null || _texture$image$ === void 0 ? void 0 : _texture$image$.width : texture.image.width) != null ? _ref : 1024;\n    const cubeSize = w / 4;\n\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n\n    const _cubeSize = Math.pow(2, _lodMax);\n\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '', `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`, `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`, `#define CUBEUV_MAX_MIP ${_lodMax}.0`];\n    const vertexShader =\n    /* glsl */\n    `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n    const fragmentShader = defines.join('\\n') +\n    /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n        }\n        `;\n    const uniforms = {\n      map: {\n        value: texture\n      },\n      height: {\n        value: (options === null || options === void 0 ? void 0 : options.height) || 15\n      },\n      radius: {\n        value: (options === null || options === void 0 ? void 0 : options.radius) || 100\n      }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n\n}\n\nexport { GroundProjectedEnv };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}