{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\nvar AssimpLoader = function (manager) {\n  Loader.call(this, manager);\n};\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new Vector3();\n      this.quaternion = new Quaternion();\n      this.scale = new Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n        this.init();\n      };\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n        this.init();\n      };\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n        t.init();\n        return t;\n      };\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n        return null;\n      }\n      return find(root, target.name);\n    };\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n      this.setTime = function (time) {\n        this.time = time;\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n      };\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n        return n;\n      };\n    };\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n      return rootBone;\n    }\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w;\n      }\n      sum = Math.sqrt(sum);\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum;\n        indexes[i] = pairs[i].i;\n        weights[i] = pairs[i].w;\n      }\n    }\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n      return undefined;\n    }\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n        for (let i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n        var skeleton = new Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\n        }\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\n        }\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        }\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        }\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\n        }\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\n        }\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n          for (let i = 0; i < this.mBones.length; i++) {\n            for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n          for (let i in bones) {\n            sortWeights(bones[i], weights[i]);\n          }\n          var _weights = [];\n          var _bones = [];\n          for (let i = 0; i < weights.length; i++) {\n            for (let j = 0; j < 4; j++) {\n              if (weights[i] && bones[i]) {\n                _weights.push(weights[i][j]);\n                _bones.push(bones[i][j]);\n              } else {\n                _weights.push(0);\n                _bones.push(0);\n              }\n            }\n          }\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n        var mesh;\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n        if (this.mBones.length > 0) {\n          mesh = new SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.toTHREE = function () {\n        return new Vector3(this.x, this.y, this.z);\n      };\n    }\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n      this.toTHREE = function () {\n        return new Color(this.r, this.g, this.b);\n      };\n    }\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n      this.toTHREE = function () {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n    function aiString() {\n      this.data = [];\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n        for (let i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n        for (let i = 0; i < this.mMeshes.length; i++) {\n          o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n        }\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new Color(r, g, b);\n      };\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n        return textureLoader.load(path);\n      };\n    }\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n      this.toTHREE = function () {\n        var mat = new MeshPhongMaterial();\n        for (let i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n        function t(t) {\n          t.mTime /= tps;\n        }\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n        for (let i = 0; i < length; i += 0.05) {\n          var matrix = new Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][i];\n            tracks.push(t2);\n          }\n        }\n        return tracks;\n      };\n    }\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n        for (let i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n          for (let j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n        if (root.mName == name) {\n          return root;\n        }\n        for (let i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n        return null;\n      };\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n        for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n      this.toTHREE = function () {\n        var m = new Matrix4();\n        for (let i = 0; i < 4; ++i) {\n          for (let i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n        return m;\n      };\n    }\n    var littleEndian = true;\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n      return m;\n    }\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n    }\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n    }\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n    }\n    function ReadBounds(stream, T\n    /*p*/, n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n      if (node.mNumChildren) {\n        node.mChildren = [];\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[i] = node2;\n        }\n      }\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n      return b;\n    }\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n      mesh.mTexCoordsBuffers = [];\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[n] = [];\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[a]);\n        }\n      }\n    }\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n        mat.mProperties = [];\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\n        }\n      } // Read all animations\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\n        }\n      } // Read all textures\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[i]);\n        }\n      } // Read lights\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[i]);\n        }\n      } // Read cameras\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[i]);\n        }\n      }\n    }\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n    function extendStream(stream) {\n      stream.readOffset = 0;\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n      };\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n    var shortened, compressed;\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n      return pScene.toTHREE();\n    }\n    return InternReadFile(buffer);\n  }\n});\nexport { AssimpLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","TextureLoader","Vector3","Quaternion","Matrix4","Skeleton","BufferGeometry","MeshLambertMaterial","BufferAttribute","Mesh","SkinnedMesh","Object3D","MeshPhongMaterial","Bone","Color","AssimpLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","e","console","error","itemError","textureLoader","resourcePath","setCrossOrigin","crossOrigin","Virtulous","KeyFrame","time","matrix","clone","position","quaternion","scale","decompose","n","lerp","nextKey","dist","l","l2","keypos","keyrot","key2pos","key2rot","tempAniPos","x","y","z","tempAniQuat","set","w","slerp","tempAniMatrix","compose","tempAniScale","KeyFrameTrack","keys","target","length","_accelTable","fps","addKey","key","push","init","sortKeys","j","i","parseFromThree","data","node","track","hierarchy","targets","parseFromCollada","sort","keySortFunc","a","b","t","reTarget","root","compareitor","TrackTargetNodeNameCompare","keySearchAccel","Math","floor","setTime","abs","key0","key1","matrixAutoUpdate","copy","matrixWorldNeedsUpdate","find","name","children","r","Animation","tracks","addTrack","max","ASSBIN_CHUNK_AICAMERA","ASSBIN_CHUNK_AILIGHT","ASSBIN_CHUNK_AITEXTURE","ASSBIN_CHUNK_AIMESH","ASSBIN_CHUNK_AINODEANIM","ASSBIN_CHUNK_AISCENE","ASSBIN_CHUNK_AIBONE","ASSBIN_CHUNK_AIANIMATION","ASSBIN_CHUNK_AINODE","ASSBIN_CHUNK_AIMATERIAL","ASSBIN_CHUNK_AIMATERIALPROPERTY","ASSBIN_MESH_HAS_POSITIONS","ASSBIN_MESH_HAS_NORMALS","ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS","ASSBIN_MESH_HAS_TEXCOORD_BASE","ASSBIN_MESH_HAS_COLOR_BASE","AI_MAX_NUMBER_OF_COLOR_SETS","AI_MAX_NUMBER_OF_TEXTURECOORDS","aiLightSource_DIRECTIONAL","aiLightSource_SPOT","aiTextureType_DIFFUSE","aiTextureType_NORMALS","aiTextureType_OPACITY","aiTextureType_LIGHTMAP","BONESPERVERT","ASSBIN_MESH_HAS_TEXCOORD","ASSBIN_MESH_HAS_COLOR","markBones","scene","mMeshes","mesh","k","mBones","boneNode","findNode","mName","isBone","cloneTreeToBones","rootBone","matrixWorld","nodeCount","toString","nodeToBoneMap","child","add","sortWeights","indexes","weights","pairs","sum","sqrt","findMatchingBone","indexOf","ret","undefined","aiMesh","mPrimitiveTypes","mNumVertices","mNumFaces","mNumBones","mMaterialIndex","mVertices","mNormals","mTangents","mBitangents","mColors","mTextureCoords","mFaces","hookupSkeletons","allBones","offsetMatrix","skeletonRoot","mParent","threeSkeletonRoot","toTHREE","threeSkeletonRootBone","threeNode","bone","tbone","mOffsetMatrix","skeleton","bind","material","skinning","geometry","mat","mMaterials","setIndex","Uint32Array","mIndexArray","setAttribute","mVertexBuffer","mNormalBuffer","mColorBuffer","mTexCoordsBuffers","Float32Array","mTangentBuffer","mBitangentBuffer","bones","mWeights","weight","mVertexId","mWeight","parseInt","_weights","_bones","normalizeSkinWeights","aiFace","mNumIndices","mIndices","aiVector3D","aiColor3D","g","aiQuaternion","aiVertexWeight","aiString","str","forEach","String","fromCharCode","replace","aiVectorKey","mTime","mValue","aiQuatKey","aiNode","mTransformation","mNumChildren","mNumMeshes","mChildren","o","aiBone","mNumWeights","aiMaterialProperty","mKey","mSemantic","mIndex","mData","mDataLength","mType","dataAsColor","array","Uint8Array","reader","DataView","getFloat32","dataAsFloat","dataAsBool","dataAsString","s","dataAsMap","substr","lastIndexOf","namePropMapping","nameTypeMapping","aiMaterial","mNumAllocated","mNumProperties","mProperties","prop","map","normalMap","lightMap","alphaMap","ambient","color","veclerp","v1","v2","v","lm1","quatlerp","q1","q2","sampleTrack","lne","Infinity","timeDist","dT","T","aiNodeAnim","mNodeName","mNumPositionKeys","mNumRotationKeys","mNumScalingKeys","mPositionKeys","mRotationKeys","mScalingKeys","mPreState","mPostState","tps","comp","getLength","apply","pos","rotation","t2","aiAnimation","mDuration","mTicksPerSecond","mNumChannels","mChannels","animationHandle","aiTexture","mWidth","mHeight","texAchFormatHint","pcData","aiLight","mAttenuationConstant","mAttenuationLinear","mAttenuationQuadratic","mAngleInnerCone","mAngleOuterCone","mColorDiffuse","mColorSpecular","mColorAmbient","aiCamera","mPosition","mLookAt","mUp","mHorizontalFOV","mClipPlaneNear","mClipPlaneFar","mAspect","aiScene","versionMajor","versionMinor","versionRevision","compileFlags","mFlags","mNumMaterials","mNumAnimations","mNumTextures","mNumLights","mNumCameras","mRootNode","mAnimations","mLights","mCameras","object","animation","aiMatrix4","elements","m","i2","littleEndian","readFloat","dataview","val","readOffset","Read_double","getFloat64","Read_uint8_t","getUint8","Read_uint16_t","getUint16","Read_unsigned_int","getUint32","Read_uint32_t","Read_aiVector3D","stream","Read_aiColor3D","c","Read_aiQuaternion","Read_aiString","stringlengthbytes","ReadBytes","Read_aiVertexWeight","Read_aiMatrix4x4","Read_aiVectorKey","Read_aiQuatKey","ReadArray_aiVertexWeight","size","ReadArray_aiVectorKey","ReadArray_aiQuatKey","ReadBounds","Seek","sizeof","aiOrigin_CUR","ai_assert","bool","ReadBinaryNode","parent","depth","chunkID","mDepth","node2","ReadBinaryBone","shortened","ReadBinaryMesh","mNumUVComponents","subArray32","uv","f","Error","ReadBinaryMaterialProperty","ReadBinaryMaterial","ReadBinaryNodeAnim","nd","ReadBinaryAnim","anim","ReadBinaryTexture","tex","achFormatHint","ReadBinaryLight","ReadBinaryCamera","cam","ReadBinaryScene","mTextures","aiOrigin_BEG","extendStream","off","ori","buff","bytes","start","end","newbuff","slice","subArrayUint16","Uint16Array","subArrayUint8","subArrayUint32","compressed","InternReadFile","pFiledata","pScene","uncompressedSize","compressedSize","FileSize","Tell","compressedData","Read","uncompressedData","uncompress","ArrayBuffer"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/AssimpLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\n\nvar AssimpLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new Vector3();\n      this.quaternion = new Quaternion();\n      this.scale = new Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n\n        this.init();\n      };\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n\n        this.init();\n      };\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n\n        t.init();\n        return t;\n      };\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n\n        return null;\n      }\n\n      return find(root, target.name);\n    };\n\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n\n      this.setTime = function (time) {\n        this.time = time;\n\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n      };\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n\n        return n;\n      };\n    };\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n\n      return rootBone;\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w;\n      }\n\n      sum = Math.sqrt(sum);\n\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum;\n        indexes[i] = pairs[i].i;\n        weights[i] = pairs[i].w;\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n\n      return undefined;\n    }\n\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n\n        for (let i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n\n        var skeleton = new Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\n\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\n        }\n\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\n        }\n\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        }\n\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        }\n\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\n        }\n\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\n        }\n\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n\n          for (let i = 0; i < this.mBones.length; i++) {\n            for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n\n          for (let i in bones) {\n            sortWeights(bones[i], weights[i]);\n          }\n\n          var _weights = [];\n          var _bones = [];\n\n          for (let i = 0; i < weights.length; i++) {\n            for (let j = 0; j < 4; j++) {\n              if (weights[i] && bones[i]) {\n                _weights.push(weights[i][j]);\n\n                _bones.push(bones[i][j]);\n              } else {\n                _weights.push(0);\n\n                _bones.push(0);\n              }\n            }\n          }\n\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n\n        var mesh;\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n\n        if (this.mBones.length > 0) {\n          mesh = new SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n\n      this.toTHREE = function () {\n        return new Vector3(this.x, this.y, this.z);\n      };\n    }\n\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n\n      this.toTHREE = function () {\n        return new Color(this.r, this.g, this.b);\n      };\n    }\n\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n\n      this.toTHREE = function () {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n\n    function aiString() {\n      this.data = [];\n\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n\n        for (let i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n\n        for (let i = 0; i < this.mMeshes.length; i++) {\n          o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n        }\n\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new Color(r, g, b);\n      };\n\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n\n        return textureLoader.load(path);\n      };\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n\n      this.toTHREE = function () {\n        var mat = new MeshPhongMaterial();\n\n        for (let i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n\n        function t(t) {\n          t.mTime /= tps;\n        }\n\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n\n        for (let i = 0; i < length; i += 0.05) {\n          var matrix = new Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][i];\n            tracks.push(t2);\n          }\n        }\n\n        return tracks;\n      };\n    }\n\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n\n        for (let i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n\n          for (let j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n\n        if (root.mName == name) {\n          return root;\n        }\n\n        for (let i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n\n        return null;\n      };\n\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n\n        for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n\n      this.toTHREE = function () {\n        var m = new Matrix4();\n\n        for (let i = 0; i < 4; ++i) {\n          for (let i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n\n        return m;\n      };\n    }\n\n    var littleEndian = true;\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n\n      return m;\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n    }\n\n    function ReadBounds(stream, T\n    /*p*/\n    , n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = [];\n\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[i] = node2;\n        }\n      }\n\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n\n      return b;\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n\n      mesh.mTexCoordsBuffers = [];\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[n] = [];\n\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[a]);\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n\n        mat.mProperties = [];\n\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\n        }\n      } // Read all animations\n\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\n        }\n      } // Read all textures\n\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[i]);\n        }\n      } // Read lights\n\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[i]);\n        }\n      } // Read cameras\n\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[i]);\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n\n    function extendStream(stream) {\n      stream.readOffset = 0;\n\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n      };\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n\n    var shortened, compressed;\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n\n      return pScene.toTHREE();\n    }\n\n    return InternReadFile(buffer);\n  }\n});\n\nexport { AssimpLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}