{"ast":null,"code":"import { Vector2 } from 'three';\n\n/**\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nconst TriangleBlurShader = {\n  uniforms: {\n    texture: {\n      value: null\n    },\n    delta: {\n      value: new Vector2(1, 1)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;',\n  // randomize the lookup values to hide the fixed number of samples\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\n};\nexport { TriangleBlurShader };","map":{"version":3,"names":["Vector2","TriangleBlurShader","uniforms","texture","value","delta","vertexShader","join","fragmentShader"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/shaders/TriangleBlurShader.js"],"sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nconst TriangleBlurShader = {\n  uniforms: {\n    texture: {\n      value: null\n    },\n    delta: {\n      value: new Vector2(1, 1)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\n};\n\nexport { TriangleBlurShader };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,kBAAkB,GAAG;EACzBC,QAAQ,EAAE;IACRC,OAAO,EAAE;MACPC,KAAK,EAAE;IACT,CAAC;IACDC,KAAK,EAAE;MACLD,KAAK,EAAE,IAAIJ,OAAO,CAAC,CAAC,EAAE,CAAC;IACzB;EACF,CAAC;EACDM,YAAY,EAAE,CAAC,mBAAmB,EAAE,eAAe,EAAE,YAAY,EAAE,4EAA4E,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAChKC,cAAc,EAAE,CAAC,mBAAmB,EAAE,yBAAyB,EAAE,4BAA4B,EAAE,qBAAqB,EAAE,mBAAmB,EAAE,eAAe,EAAE,4BAA4B,EAAE,qBAAqB;EAAE;EACjN,8BAA8B,EAAE,yDAAyD,EAAE,sDAAsD,EAAE,wCAAwC,EAAE,kEAAkE,EAAE,oBAAoB,EAAE,IAAI,EAAE,gCAAgC,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;AAC/U,CAAC;AAED,SAASN,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}