{"ast":null,"code":"import * as THREE from 'three';\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    } // front and rear face center vertices\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    } // construct front and rear face\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster(); // create cursor\n\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n}\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","Object3D","constructor","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","addEventListener","event","xrInputSource","data","visible","createPointer","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","material","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","isPinched","setAttached","isAttached","intersectObject","object","recursive","intersectObjects","objects","checkIntersections","intersections","length","intersection","setCursor"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    } // front and rear face center vertices\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    } // construct front and rear face\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster(); // create cursor\n\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n\n      this._updatePointerVertices(rearRadius);\n\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.pointerGeometry) {\n      this._updatePointer();\n\n      this._updateRaycaster();\n    }\n  }\n\n  isPinched() {\n    return this.pinched;\n  }\n\n  setAttached(attached) {\n    this.attached = attached;\n  }\n\n  isAttached() {\n    return this.attached;\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n\n}\n\nexport { OculusHandPointerModel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}