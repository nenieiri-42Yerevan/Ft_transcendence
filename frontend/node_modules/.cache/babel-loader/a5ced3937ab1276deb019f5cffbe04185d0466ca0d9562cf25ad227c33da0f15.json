{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\nclass VTKLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = []; // triangles vertices\n\n      var positions = []; // red, green, blue colors in the range 0 to 1\n\n      var colors = []; // normal vector, one per vertex\n\n      var normals = [];\n      var result; // pattern for detecting the end of a number sequence\n\n      var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n      var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n      var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data.split('\\n');\n      for (var i in lines) {\n        var line = lines[i].trim();\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      }\n      if (colors.length !== indices.length) {\n        // stagger\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        // cell\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n          for (var i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0];\n            var g = colors[3 * i + 1];\n            var b = colors[3 * i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n        }\n      }\n      return geometry;\n    }\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data);\n      var dataView = new DataView(data); // Points and normals, by default, are empty\n\n      var points = [];\n      var normals = [];\n      var indices = []; // Going to make a big array of strings\n      var index = 0;\n      function findString(buffer, start) {\n        var index = start;\n        var c = buffer[index];\n        var s = [];\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n        return {\n          start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('')\n        };\n      }\n      var state, line;\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (line.indexOf('POINTS') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          } // increment our next pointer\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // retrieves the n-2 triangles from the triangle strip\n\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          } // increment our next pointer\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // divide the polygon in n-2 triangle\n\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          } // increment our next pointer\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n          state = findString(buffer, state.next); // Now grab the binary data\n\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          } // Increment past our data\n\n          state.next = state.next + count;\n        } // Increment index\n\n        index = state.next;\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      }\n      return geometry;\n    }\n    function Float32Concat(first, second) {\n      const firstLength = first.length,\n        result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n        result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {};\n        if (xml.nodeType === 1) {\n          // element\n          // do attributes\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n              for (var j = 0; j < xml.attributes.length; j++) {\n                var attribute = xml.attributes.item(j);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n          obj = xml.nodeValue.trim();\n        } // do children\n\n        if (xml.hasChildNodes()) {\n          for (var i = 0; i < xml.childNodes.length; i++) {\n            var item = xml.childNodes.item(i);\n            var nodeName = item.nodeName;\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName].push(tmp);\n            }\n          }\n        }\n        return obj;\n      } // Taken from Base64-js\n\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        var i;\n        var lookup = [];\n        var revLookup = [];\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var len = code.length;\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i];\n        }\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n        var j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        arr = new Arr(len * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len - 4 : len;\n        var L = 0;\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xff0000) >> 16;\n          arr[L++] = (tmp & 0xff00) >> 8;\n          arr[L++] = tmp & 0xff;\n        }\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xff;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xff;\n          arr[L++] = tmp & 0xff;\n        }\n        return arr;\n      }\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0;\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        } // Check the format\n\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array();\n          } // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n          rawData = ele['#text'];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n          for (var i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | byteData[i] << i * numBytes;\n          }\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n\n          cSizeStart = 3 * numBytes;\n          for (var i = 0; i < blocks; i++) {\n            var currentBlockSize = byteData[i * numBytes + cSizeStart];\n            for (var j = 1; j < numBytes - 1; j++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n            }\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n          for (var i = 0; i < dataOffsets.length - 1; i++) {\n            var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n            content = data.buffer;\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n          delete ele['#text'];\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n          delete ele['#text']; // Get the content and optimize it\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content);\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n        return txt;\n      } // Main part\n      // Get Dom\n\n      var dom = null;\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n          dom.async = false;\n          if (!dom.loadXML()) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error('Cannot parse xml string!');\n      } // Get the doc\n\n      var doc = dom.documentElement; // Convert to json\n\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n        // Loop through the sections\n\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n        var sectionIndex = 0,\n          numberOfSections = sections.length;\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n            var dataArrayIndex = 0,\n              numberOfDataArrays = arr.length;\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n              dataArrayIndex++;\n            }\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n                break;\n              // if it is points\n\n              case 'Points':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n                break;\n              // if it is strips\n\n              case 'Strips':\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                  }\n                }\n                break;\n              // if it is polys\n\n              case 'Polys':\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                    connectivityIndex = 0;\n                  var i = 0,\n                    len = numberOfPolys,\n                    len0 = 0;\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                      len1 = offset[i];\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n                    var j = 1;\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n                break;\n            }\n          }\n          sectionIndex++;\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n        return geometry;\n      } else {\n        throw new Error('Unsupported DATASET type');\n      }\n    } // get the 5 first lines of the files to check if there is the key word binary\n\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n}\nexport { VTKLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","BufferAttribute","unzlibSync","VTKLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","parseASCII","indices","positions","colors","normals","result","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","split","i","line","trim","indexOf","dataset","Error","exec","x","parseFloat","y","z","push","numVertices","parseInt","inds","i0","i1","i2","k","j","r","g","b","nx","ny","nz","geometry","setIndex","setAttribute","length","toNonIndexed","numTriangles","attributes","position","count","newColors","parseBinary","pointIndex","numberOfPoints","s","buffer","Uint8Array","dataView","DataView","points","index","findString","start","c","String","fromCharCode","end","next","parsedString","join","state","Float32Array","getFloat32","numberOfStrips","size","Uint32Array","indicesIndex","indexCount","getInt32","strip","byteLength","Float32Concat","first","second","firstLength","set","Int32Concat","Int32Array","parseXML","stringFile","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","tmp","old","Base64toByteArray","b64","Arr","Array","lookup","revLookup","code","len","charCodeAt","l","placeHolders","arr","L","parseDataArray","ele","compressed","numBytes","json","header_type","format","rawData","content","byteData","blocks","cSizeStart","headerSize","padding","dataOffsets","currentOffset","type","txt","currentBlockSize","slice","filter","el","idx","dom","window","DOMParser","parseFromString","ActiveXObject","async","loadXML","parseError","reason","srcText","doc","documentElement","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","Object","prototype","toString","call","dataArrayIndex","numberOfDataArrays","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","NumberOfStrips","connectivity","offset","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","meta","decodeText","includes"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/loaders/VTKLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\n\nclass VTKLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = []; // triangles vertices\n\n      var positions = []; // red, green, blue colors in the range 0 to 1\n\n      var colors = []; // normal vector, one per vertex\n\n      var normals = [];\n      var result; // pattern for detecting the end of a number sequence\n\n      var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n      var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n      var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data.split('\\n');\n\n      for (var i in lines) {\n        var line = lines[i].trim();\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      }\n\n      if (colors.length !== indices.length) {\n        // stagger\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        // cell\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n\n          for (var i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0];\n            var g = colors[3 * i + 1];\n            var b = colors[3 * i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n        }\n      }\n\n      return geometry;\n    }\n\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data);\n      var dataView = new DataView(data); // Points and normals, by default, are empty\n\n      var points = [];\n      var normals = [];\n      var indices = []; // Going to make a big array of strings\n      var index = 0;\n\n      function findString(buffer, start) {\n        var index = start;\n        var c = buffer[index];\n        var s = [];\n\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n\n        return {\n          start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('')\n        };\n      }\n\n      var state, line;\n\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (line.indexOf('POINTS') === 0) {\n\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // retrieves the n-2 triangles from the triangle strip\n\n\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // divide the polygon in n-2 triangle\n\n\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n          state = findString(buffer, state.next); // Now grab the binary data\n\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          } // Increment past our data\n\n\n          state.next = state.next + count;\n        } // Increment index\n\n\n        index = state.next;\n\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      }\n\n      return geometry;\n    }\n\n    function Float32Concat(first, second) {\n      const firstLength = first.length,\n            result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {};\n\n        if (xml.nodeType === 1) {\n          // element\n          // do attributes\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n\n              for (var j = 0; j < xml.attributes.length; j++) {\n                var attribute = xml.attributes.item(j);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n          obj = xml.nodeValue.trim();\n        } // do children\n\n\n        if (xml.hasChildNodes()) {\n          for (var i = 0; i < xml.childNodes.length; i++) {\n            var item = xml.childNodes.item(i);\n            var nodeName = item.nodeName;\n\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName].push(tmp);\n            }\n          }\n        }\n\n        return obj;\n      } // Taken from Base64-js\n\n\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        var i;\n        var lookup = [];\n        var revLookup = [];\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var len = code.length;\n\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i];\n        }\n\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n        var j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        arr = new Arr(len * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len - 4 : len;\n        var L = 0;\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xff0000) >> 16;\n          arr[L++] = (tmp & 0xff00) >> 8;\n          arr[L++] = tmp & 0xff;\n        }\n\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xff;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xff;\n          arr[L++] = tmp & 0xff;\n        }\n\n        return arr;\n      }\n\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0;\n\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        } // Check the format\n\n\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array();\n          } // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\n          rawData = ele['#text'];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n\n          for (var i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | byteData[i] << i * numBytes;\n          }\n\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n\n          cSizeStart = 3 * numBytes;\n\n          for (var i = 0; i < blocks; i++) {\n            var currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n            for (var j = 1; j < numBytes - 1; j++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n            }\n\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n\n          for (var i = 0; i < dataOffsets.length - 1; i++) {\n            var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n            content = data.buffer;\n\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n\n          delete ele['#text'];\n\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n\n          delete ele['#text']; // Get the content and optimize it\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content);\n\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n\n        return txt;\n      } // Main part\n      // Get Dom\n\n\n      var dom = null;\n\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n          dom.async = false;\n\n          if (!dom.loadXML()) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error('Cannot parse xml string!');\n      } // Get the doc\n\n\n      var doc = dom.documentElement; // Convert to json\n\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n        // Loop through the sections\n\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n        var sectionIndex = 0,\n            numberOfSections = sections.length;\n\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n\n            var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n\n              dataArrayIndex++;\n            }\n\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n\n                break;\n              // if it is points\n\n              case 'Points':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n\n                break;\n              // if it is strips\n\n              case 'Strips':\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                  }\n                }\n\n                break;\n              // if it is polys\n\n              case 'Polys':\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                      connectivityIndex = 0;\n                  var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                        len1 = offset[i];\n\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n\n                    var j = 1;\n\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n\n                break;\n            }\n          }\n\n          sectionIndex++;\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      } else {\n        throw new Error('Unsupported DATASET type');\n      }\n    } // get the 5 first lines of the files to check if there is the key word binary\n\n\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n\n}\n\nexport { VTKLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}