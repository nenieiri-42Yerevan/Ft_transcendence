{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\nconst cb = new Vector3(),\n  ab = new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"faces\", void 0);\n    _defineProperty(this, \"neighbors\", void 0);\n    _defineProperty(this, \"collapseCost\", void 0);\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n    _defineProperty(this, \"minCost\", 0);\n    _defineProperty(this, \"totalCost\", 0);\n    _defineProperty(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n    neighbors.splice(offset, 1);\n  }\n} // we use a triangle class to represent structure of face slightly differently\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n    _defineProperty(this, \"b\", void 0);\n    _defineProperty(this, \"c\", void 0);\n    _defineProperty(this, \"v1\", void 0);\n    _defineProperty(this, \"v2\", void 0);\n    _defineProperty(this, \"v3\", void 0);\n    _defineProperty(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n        il = u.faces.length,\n        face,\n        sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n      const borders = 0;\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n      let i;\n      const tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n      const geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n      let nextVertex;\n      let z = count;\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n    removeFromArray(vertices, v);\n  }\n}\nexport { SimplifyModifier };","map":{"version":3,"names":["_defineProperty","Vector3","BufferGeometry","Float32BufferAttribute","mergeVertices","cb","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","Vertex","constructor","v","id","position","faces","neighbors","collapseCost","collapseNeighbor","addUniqueNeighbor","vertex","removeIfNonNeighbor","n","offset","i","length","hasVertex","Triangle","v1","v2","v3","a","b","c","computeNormal","vA","vB","vC","subVectors","cross","normalize","normal","copy","replaceVertex","oldv","newv","SimplifyModifier","u","edgelength","distanceTo","curvature","sideFaces","il","face","sideFace","minCurvature","j","dotProd","dot","Math","min","max","borders","amt","computeEdgeCollapseCost","minCost","totalCost","costCount","f","vs","vertices","removeVertex","tmpVertices","removeFace","computeEdgeCostAtVertex","least","geometry","count","clone","attributes","name","deleteAttribute","positionAttribute","getAttribute","fromBufferAttribute","geomIndex","getIndex","getX","triangle","nextVertex","z","minimumCostEdge","console","log","collapse","simplifiedGeometry","index","x","y","setAttribute","setIndex","assert","pop"],"sources":["/Users/tumolabsstudent/Desktop/app/node_modules/three-stdlib/modifiers/SimplifyModifier.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\n\nconst cb = new Vector3(),\n      ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      const borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n\n      let i;\n      const tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      const geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n\n      let nextVertex;\n      let z = count;\n\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n}\n\nexport { SimplifyModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}